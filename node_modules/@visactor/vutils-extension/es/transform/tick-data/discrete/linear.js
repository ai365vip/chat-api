import { isFunction, isValid, maxInArray, minInArray } from "@visactor/vutils";

import { convertDomainToTickData, getCartesianLabelBounds, isAxisHorizontal } from "../util";

import { binaryFuzzySearchInNumberRange } from "../../../algorithm";

const getOneDimensionalLabelBounds = (scale, domain, op, isHorizontal) => getCartesianLabelBounds(scale, domain, op).map((bounds => isHorizontal ? [ bounds.x1, bounds.x2, bounds.width() ] : [ bounds.y1, bounds.y2, bounds.height() ])), boundsOverlap = (prevBounds, nextBounds, gap = 0) => Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;

export const boundsDistance = (prevBounds, nextBounds) => prevBounds[1] < nextBounds[0] ? nextBounds[0] - prevBounds[1] : nextBounds[1] < prevBounds[0] ? prevBounds[0] - nextBounds[1] : 0;

export const linearDiscreteTicks = (scale, op) => {
    var _a;
    const domain = scale.domain();
    if (!domain.length) return [];
    const {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, labelGap: labelGap = 4, axisOrientType: axisOrientType, labelStyle: labelStyle} = op, isHorizontal = isAxisHorizontal(axisOrientType), range = scale.range(), rangeSize = scale.calculateWholeRangeSize();
    if (rangeSize < 2) return op.labelLastVisible ? convertDomainToTickData([ domain[domain.length - 1] ]) : convertDomainToTickData([ domain[0] ]);
    let scaleTicks;
    if (isValid(tickStep)) scaleTicks = scale.stepTicks(tickStep); else if (isValid(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount); else if (isValid(tickCount)) {
        const count = isFunction(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.ticks(count);
    } else if (op.sampling) {
        const fontSize = (null !== (_a = op.labelStyle.fontSize) && void 0 !== _a ? _a : 12) + 2, rangeStart = minInArray(range), rangeEnd = maxInArray(range);
        if (domain.length <= rangeSize / fontSize) {
            const incrementUnit = (rangeEnd - rangeStart) / domain.length, labelBoundsList = getOneDimensionalLabelBounds(scale, domain, op, isHorizontal), minBoundsLength = Math.min(...labelBoundsList.map((bounds => bounds[2]))), stepResult = getStep(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), !1);
            scaleTicks = scale.stepTicks(stepResult.step), op.labelLastVisible && (stepResult.delCount && (scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount)), 
            scaleTicks.push(domain[domain.length - 1]));
        } else {
            const tempDomain = [ domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1] ], tempList = getOneDimensionalLabelBounds(scale, tempDomain, op, isHorizontal);
            let maxBounds = null;
            tempList.forEach((current => {
                maxBounds ? maxBounds[2] < current[2] && (maxBounds = current) : maxBounds = current;
            }));
            const step = rangeEnd - rangeStart - labelGap > 0 ? Math.ceil(domain.length * (labelGap + maxBounds[2]) / (rangeEnd - rangeStart - labelGap)) : domain.length - 1;
            scaleTicks = scale.stepTicks(step), !op.labelLastVisible || scaleTicks.length && scaleTicks[scaleTicks.length - 1] === domain[domain.length - 1] || (scaleTicks.length && Math.abs(scale.scale(scaleTicks[scaleTicks.length - 1]) - scale.scale(domain[domain.length - 1])) < maxBounds[2] && (scaleTicks = scaleTicks.slice(0, -1)), 
            scaleTicks.push(domain[domain.length - 1]));
        }
    } else scaleTicks = scale.domain();
    return convertDomainToTickData(scaleTicks);
};

const getStep = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
    let resultDelCount = 0, resultStep = 0, resultTickCount = -1, minDiff = Number.MAX_VALUE;
    const validateStep = step => {
        let success = !0, ptr = 0;
        do {
            ptr + step < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = !1), 
            ptr += step;
        } while (success && ptr < domain.length);
        return success;
    }, minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, (step => validateStep(step) ? 1 : -1));
    let step = minValidStep;
    do {
        if (step > minValidStep && !areAllBoundsSame && !validateStep(step)) step++; else {
            if (!labelLastVisible) {
                resultStep = step;
                break;
            }
            {
                const lastIndex = domain.length - 1;
                let ptr, delCount = 0;
                ptr = domain.length % step > 0 ? domain.length - domain.length % step + step : domain.length;
                do {
                    if (ptr -= step, ptr !== lastIndex && !boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) break;
                    delCount++;
                } while (ptr > 0);
                if (ptr === lastIndex) {
                    resultStep = step, resultDelCount = delCount;
                    break;
                }
                {
                    const tickCount = Math.floor(domain.length / step) - delCount + 1;
                    if (tickCount < resultTickCount) break;
                    {
                        resultTickCount = tickCount;
                        const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]), distance2 = ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1, diff = Math.abs(distance1 - distance2);
                        if (diff < minDiff && (minDiff = diff, resultStep = step, resultDelCount = delCount), 
                        distance1 <= distance2) break;
                    }
                }
            }
            step++;
        }
    } while (step <= domain.length);
    return {
        step: resultStep,
        delCount: resultDelCount
    };
};
//# sourceMappingURL=linear.js.map