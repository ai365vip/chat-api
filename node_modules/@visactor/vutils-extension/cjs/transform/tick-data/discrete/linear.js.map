{"version":3,"sources":["../src/transform/tick-data/discrete/linear.ts"],"names":[],"mappings":"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","file":"linear.js","sourcesContent":["import type { BandScale, IBaseScale } from '@visactor/vscale';\nimport { isFunction, isValid, maxInArray, minInArray } from '@visactor/vutils';\nimport type { ICartesianTickDataOpt, ITickData } from '../interface';\nimport { convertDomainToTickData, getCartesianLabelBounds, isAxisHorizontal } from '../util';\nimport { binaryFuzzySearchInNumberRange } from '../../../algorithm';\n\n/** x1, x2, length */\ntype OneDimensionalBounds = [number, number, number];\n\nconst getOneDimensionalLabelBounds = (\n  scale: IBaseScale,\n  domain: any[],\n  op: ICartesianTickDataOpt,\n  isHorizontal: boolean\n): OneDimensionalBounds[] => {\n  const labelBoundsList = getCartesianLabelBounds(scale, domain, op);\n  return labelBoundsList.map(bounds => {\n    if (isHorizontal) {\n      return [bounds.x1, bounds.x2, bounds.width()];\n    } else {\n      return [bounds.y1, bounds.y2, bounds.height()];\n    }\n  });\n};\n\n/** 判断两个 bounds 是否有重叠情况 */\nconst boundsOverlap = (prevBounds: OneDimensionalBounds, nextBounds: OneDimensionalBounds, gap = 0): boolean => {\n  return Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;\n};\n\n/** 判断两个不相交的 bounds 相隔的距离 */\nexport const boundsDistance = (prevBounds: OneDimensionalBounds, nextBounds: OneDimensionalBounds): number => {\n  if (prevBounds[1] < nextBounds[0]) {\n    return nextBounds[0] - prevBounds[1];\n  } else if (nextBounds[1] < prevBounds[0]) {\n    return prevBounds[0] - nextBounds[1];\n  }\n  return 0;\n};\n\n/**\n * 对于离散轴：\n * - 如果spec配了tickCount、forceTickCount、tickStep，则直接输出BandScale的ticks()、forceTicks()、stepTicks()结果；\n * - 估算所有轴label的宽度（或高度，在竖轴的情况下）并存为数组domainLengthList；\n * - 通过循环来寻找最小的step，使：如果在这个step下采样，轴标签互不遮挡（此处用到domainLengthList和scale.range()）；\n * - 如果用户配置了spec.label.lastVisible，则处理右边界：强制采样最后一个tick数据，并删掉这个tick的label所覆盖的那些tick数据。\n *\n * @param scale\n * @param op\n * @returns\n */\nexport const linearDiscreteTicks = (scale: BandScale, op: ICartesianTickDataOpt): ITickData[] => {\n  const domain = scale.domain();\n  if (!domain.length) {\n    return [];\n  }\n  const { tickCount, forceTickCount, tickStep, labelGap = 4, axisOrientType, labelStyle } = op;\n  const isHorizontal = isAxisHorizontal(axisOrientType);\n  const range = scale.range();\n\n  // if range is so small\n  const rangeSize = scale.calculateWholeRangeSize();\n  if (rangeSize < 2) {\n    if (op.labelLastVisible) {\n      return convertDomainToTickData([domain[domain.length - 1]]);\n    }\n    return convertDomainToTickData([domain[0]]);\n  }\n\n  let scaleTicks;\n  if (isValid(tickStep)) {\n    scaleTicks = scale.stepTicks(tickStep);\n  } else if (isValid(forceTickCount)) {\n    scaleTicks = scale.forceTicks(forceTickCount);\n  } else if (isValid(tickCount)) {\n    const count = isFunction(tickCount) ? tickCount({ axisLength: rangeSize, labelStyle }) : tickCount;\n    scaleTicks = scale.ticks(count);\n  } else if (op.sampling) {\n    const fontSize = (op.labelStyle.fontSize ?? 12) + 2;\n    const rangeStart = minInArray(range);\n    const rangeEnd = maxInArray(range);\n\n    if (domain.length <= rangeSize / fontSize) {\n      const incrementUnit = (rangeEnd - rangeStart) / domain.length;\n      const labelBoundsList = getOneDimensionalLabelBounds(scale, domain, op, isHorizontal);\n      const minBoundsLength = Math.min(...labelBoundsList.map(bounds => bounds[2]));\n\n      const stepResult = getStep(\n        domain,\n        labelBoundsList,\n        labelGap,\n        op.labelLastVisible,\n        Math.floor(minBoundsLength / incrementUnit), // 给step赋上合适的初值，有效改善外层循环次数\n        false\n      );\n\n      scaleTicks = (scale as BandScale).stepTicks(stepResult.step);\n      if (op.labelLastVisible) {\n        if (stepResult.delCount) {\n          scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount);\n        }\n        scaleTicks.push(domain[domain.length - 1]);\n      }\n    } else {\n      // only check first middle last, use the max size to sampling\n      const tempDomain = [domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1]];\n      const tempList = getOneDimensionalLabelBounds(scale, tempDomain, op, isHorizontal);\n      let maxBounds: OneDimensionalBounds = null;\n      tempList.forEach(current => {\n        if (!maxBounds) {\n          maxBounds = current;\n          return;\n        }\n        if (maxBounds[2] < current[2]) {\n          maxBounds = current;\n        }\n      });\n\n      const step =\n        rangeEnd - rangeStart - labelGap > 0\n          ? Math.ceil((domain.length * (labelGap + maxBounds[2])) / (rangeEnd - rangeStart - labelGap))\n          : domain.length - 1;\n\n      scaleTicks = (scale as BandScale).stepTicks(step);\n\n      if (\n        op.labelLastVisible &&\n        (!scaleTicks.length || scaleTicks[scaleTicks.length - 1] !== domain[domain.length - 1])\n      ) {\n        if (\n          scaleTicks.length &&\n          Math.abs(scale.scale(scaleTicks[scaleTicks.length - 1]) - scale.scale(domain[domain.length - 1])) <\n            maxBounds[2]\n        ) {\n          scaleTicks = scaleTicks.slice(0, -1);\n        }\n        scaleTicks.push(domain[domain.length - 1]);\n      }\n    }\n  } else {\n    scaleTicks = scale.domain();\n  }\n\n  return convertDomainToTickData(scaleTicks);\n};\n\n/** 计算合适的step */\nconst getStep = (\n  domain: any[],\n  labelBoundsList: OneDimensionalBounds[],\n  labelGap: number,\n  labelLastVisible: boolean,\n  defaultStep: number,\n  areAllBoundsSame: boolean\n) => {\n  let resultDelCount = 0;\n  let resultStep = 0;\n  let resultTickCount = -1;\n  let minDiff = Number.MAX_VALUE;\n\n  /** 验证在当前 step 下是否会产生重叠 */\n  const validateStep = (step: number) => {\n    let success = true;\n    let ptr = 0;\n    do {\n      if (ptr + step < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap)) {\n        success = false;\n      }\n      ptr += step;\n    } while (success && ptr < domain.length);\n    return success;\n  };\n\n  // 通过二分来寻找最小的step，使：如果在这个step下采样，轴标签互不遮挡\n  const minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, step =>\n    validateStep(step) ? 1 : -1\n  );\n\n  // 对 step 进行微调\n  let step = minValidStep;\n  do {\n    if (step > minValidStep && !areAllBoundsSame) {\n      if (!validateStep(step)) {\n        step++;\n        continue;\n      }\n    }\n    if (labelLastVisible) {\n      const lastIndex = domain.length - 1;\n      let delCount = 0;\n      let ptr;\n      if (domain.length % step > 0) {\n        ptr = domain.length - (domain.length % step) + step;\n      } else {\n        ptr = domain.length;\n      }\n      do {\n        ptr -= step; // 获取最后一个label位置\n        if (ptr === lastIndex || boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) {\n          delCount++;\n        } else {\n          break;\n        }\n      } while (ptr > 0);\n      if (ptr === lastIndex) {\n        // 采到的最后的一个 label 刚好是最后一项，直接退出\n        resultStep = step;\n        resultDelCount = delCount;\n        break;\n      } else {\n        // 尝试获取最均匀的结果，防止倒数第二项和最后一项有大的空档\n        const tickCount = Math.floor(domain.length / step) - delCount + 1;\n        if (tickCount < resultTickCount) {\n          break;\n        } else {\n          resultTickCount = tickCount;\n          const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]); // 倒数第2项和最后一项的距离\n          const distance2 =\n            ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1; // 倒数第3项和倒数第2项的距离\n          const diff = Math.abs(distance1 - distance2);\n          if (diff < minDiff) {\n            minDiff = diff;\n            resultStep = step; // 记录最均匀的 step\n            resultDelCount = delCount;\n          }\n          if (distance1 <= distance2) {\n            break;\n          }\n        }\n      }\n    } else {\n      resultStep = step;\n      break;\n    }\n    step++;\n  } while (step <= domain.length);\n\n  return {\n    step: resultStep,\n    delCount: resultDelCount\n  };\n};\n"]}