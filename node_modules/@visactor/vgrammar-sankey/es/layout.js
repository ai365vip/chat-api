import { calculateNodeValue } from "./hierarchy";

import { isNil, clamp, minInArray, isFunction, isNumber, isString, Logger } from "@visactor/vutils";

import { field, isVertical } from "@visactor/vgrammar-util";

function left(node) {
    return node.depth;
}

function right(node, maxDepth) {
    return maxDepth - 1 - node.endDepth;
}

function justify(node, maxDepth) {
    return node.sourceLinks.length ? node.depth : maxDepth - 1;
}

function center(node, maxDepth, nodeMap) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minInArray(node.sourceLinks.map((link => nodeMap[link.target].depth))) - 1 : 0;
}

const ascendingNodeBreadth = (a, b) => a.y0 - b.y0, calcDivideValue = (node, isTarget) => {
    if (isNil(node.value)) return null;
    const res = (isTarget ? node.targetLinks : node.sourceLinks).reduce(((res, sLink) => (isNil(sLink.value) ? res.count += 1 : res.sum += sLink.value, 
    res)), {
        sum: 0,
        count: 0
    });
    return res.count > 0 ? (node.value - res.sum) / res.count : null;
}, alignFunctions = {
    left: left,
    right: right,
    justify: justify,
    center: center,
    start: left,
    end: right
};

export class SankeyLayout {
    constructor(options) {
        this._ascendingSourceBreadth = (a, b) => ascendingNodeBreadth(this._nodeMap[a.source], this._nodeMap[b.source]) || a.index - b.index, 
        this._ascendingTargetBreadth = (a, b) => ascendingNodeBreadth(this._nodeMap[a.target], this._nodeMap[b.target]) || a.index - b.index, 
        this.options = Object.assign({}, SankeyLayout.defaultOptions, options);
        const keyOption = this.options.nodeKey, keyFunc = isFunction(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
        this._getNodeKey = keyFunc, this._logger = Logger.getInstance(), this._alignFunc = isFunction(this.options.setNodeLayer) ? node => this.options.setNodeLayer(node.datum) : alignFunctions[this.options.nodeAlign];
    }
    layout(data, config) {
        if (!data) return null;
        const viewBox = "width" in config ? {
            x0: 0,
            x1: config.width,
            y0: 0,
            y1: config.height,
            width: config.width,
            height: config.height
        } : {
            x0: Math.min(config.x0, config.x1),
            x1: Math.max(config.x0, config.x1),
            y0: Math.min(config.y0, config.y1),
            y1: Math.max(config.y0, config.y1),
            width: Math.abs(config.x1 - config.x0),
            height: Math.abs(config.y1 - config.y0)
        };
        isVertical(this.options.direction) ? this._viewBox = {
            x0: viewBox.y0,
            x1: viewBox.y1,
            y0: viewBox.x0,
            y1: viewBox.x1,
            width: viewBox.height,
            height: viewBox.width
        } : this._viewBox = viewBox;
        const result = this.computeNodeLinks(data), nodes = result.nodes, links = result.links;
        if (this._nodeMap = result.nodeMap, this.computeNodeValues(nodes), this.computeNodeDepths(nodes), 
        [ "right", "end", "justify" ].includes(this.options.nodeAlign) && this.computeNodeEndDepths(nodes), 
        this._maxDepth <= 1) return null;
        const columns = this.computeNodeBreadths(nodes);
        return this.computeLinkBreadths(nodes), isVertical(this.options.direction) && (nodes.forEach((node => {
            const y0 = node.y0, y1 = node.y1;
            node.y0 = node.x0, node.y1 = node.x1, node.x0 = y0, node.x1 = y1;
        })), links.forEach((link => {
            link.vertical = !0;
            const x0 = link.x0, x1 = link.x1;
            link.x0 = link.y0, link.x1 = link.y1, link.y0 = x0, link.y1 = x1;
        }))), links.forEach((link => {
            const sourceNode = this._nodeMap[link.source], targetNode = this._nodeMap[link.target];
            link.sourceRect = {
                x0: sourceNode.x0,
                x1: sourceNode.x1,
                y0: sourceNode.y0,
                y1: sourceNode.y1
            }, link.targetRect = {
                x0: targetNode.x0,
                x1: targetNode.x1,
                y1: targetNode.y1,
                y0: targetNode.y0
            };
        })), {
            nodes: nodes,
            links: links,
            columns: columns
        };
    }
    computeHierarchicNodeLinks(originalNodes) {
        const nodes = [], links = [], nodeMap = {}, linkMap = {}, originalLinks = [];
        calculateNodeValue(originalNodes);
        const doSubTree = (subTree, depth, parents) => {
            subTree.forEach(((node, index) => {
                var _a, _b;
                const nodeKey = this._getNodeKey ? this._getNodeKey(node) : parents ? `${parents[parents.length - 1].key}-${index}` : `${depth}-${index}`;
                if (nodeMap[nodeKey]) nodeMap[nodeKey].value = void 0; else {
                    const nodeElement = {
                        depth: depth,
                        datum: node,
                        index: index,
                        key: nodeKey,
                        value: null !== (_a = node.value) && void 0 !== _a ? _a : 0,
                        sourceLinks: [],
                        targetLinks: []
                    };
                    nodeMap[nodeKey] = nodeElement, nodes.push(nodeElement);
                }
                parents && originalLinks.push({
                    source: parents[parents.length - 1].key,
                    target: nodeKey,
                    value: null !== (_b = node.value) && void 0 !== _b ? _b : 0,
                    parents: parents
                }), node.children && node.children.length && doSubTree(node.children, depth + 1, parents ? parents.concat([ nodeMap[nodeKey] ]) : [ nodeMap[nodeKey] ]);
            }));
        };
        return doSubTree(originalNodes, 0, null), originalLinks.forEach(((link, index) => {
            const key = `${link.source}-${link.target}`;
            if (linkMap[key]) return linkMap[key].value += link.value, void linkMap[key].datum.push(link);
            const linkElement = {
                index: index,
                key: `${link.source}-${link.target}`,
                source: link.source,
                target: link.target,
                datum: [ link ],
                value: link.value,
                parents: link.parents.map((parent => parent.key))
            };
            links.push(linkElement), nodeMap[link.source].sourceLinks.push(linkElement), nodeMap[link.target].targetLinks.push(linkElement), 
            linkMap[key] = linkElement;
        })), {
            nodes: nodes,
            links: links,
            nodeMap: nodeMap
        };
    }
    computeSourceTargetNodeLinks(data) {
        const nodes = [], links = [], nodeMap = {};
        data.nodes && data.nodes.forEach(((node, index) => {
            const nodeElement = {
                depth: -1,
                datum: node,
                index: index,
                key: this._getNodeKey ? this._getNodeKey(node) : index,
                value: node.value,
                sourceLinks: [],
                targetLinks: []
            };
            nodeMap[nodeElement.key] = nodeElement, nodes.push(nodeElement);
        }));
        const invalidLinks = [];
        return data.links.forEach(((link, index) => {
            if (isNil(link.source) || isNil(link.target)) return;
            if (data.nodes && (!nodeMap[link.source] || !nodeMap[link.target])) return;
            data.nodes || nodeMap[link.source] || (nodeMap[link.source] = {
                value: void 0,
                depth: -1,
                index: nodes.length,
                key: link.source,
                datum: null,
                sourceLinks: [],
                targetLinks: []
            }, nodes.push(nodeMap[link.source])), data.nodes || nodeMap[link.target] || (nodeMap[link.target] = {
                value: void 0,
                depth: -1,
                index: nodes.length,
                key: link.target,
                datum: null,
                sourceLinks: [],
                targetLinks: []
            }, nodes.push(nodeMap[link.target]));
            const linkElement = {
                index: index,
                source: link.source,
                target: link.target,
                datum: link,
                value: link.value
            };
            this.options.divideNodeValueToLink && isNil(link.value) && invalidLinks.push(linkElement), 
            links.push(linkElement), nodeMap[link.source].sourceLinks.push(linkElement), nodeMap[link.target].targetLinks.push(linkElement);
        })), this.options.divideNodeValueToLink && invalidLinks.length && invalidLinks.forEach((link => {
            const values = [ calcDivideValue(nodeMap[link.source]), calcDivideValue(nodeMap[link.target], !0) ].filter((entry => !isNil(entry)));
            values.length && (link.value = minInArray(values));
        })), {
            nodeMap: nodeMap,
            nodes: nodes,
            links: links
        };
    }
    computeNodeLinks(data) {
        let res;
        "links" in data ? res = this.computeSourceTargetNodeLinks(data) : (this._isHierarchic = !0, 
        res = this.computeHierarchicNodeLinks(data.nodes));
        let nodes = res.nodes;
        const links = res.links;
        if (this.options.linkSortBy) for (let i = 0, len = nodes.length; i < len; i++) nodes[i].sourceLinks.sort(this.options.linkSortBy), 
        nodes[i].targetLinks.sort(this.options.linkSortBy);
        return this.options.dropIsolatedNode && (nodes = nodes.filter((node => node.targetLinks.length || node.sourceLinks.length))), 
        {
            nodes: nodes,
            links: links,
            nodeMap: res.nodeMap
        };
    }
    computeNodeValues(nodes) {
        for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            node.value = Math.max(isNil(node.value) ? 0 : node.value, node.sourceLinks.reduce(((sum, link) => {
                var _a;
                return sum + (null !== (_a = link.value) && void 0 !== _a ? _a : 0);
            }), 0), node.targetLinks.reduce(((sum, link) => {
                var _a;
                return sum + (null !== (_a = link.value) && void 0 !== _a ? _a : 0);
            }), 0));
        }
    }
    computeNodeDepths(nodes) {
        const n = nodes.length;
        let next, nextMap, current = nodes, depth = 0;
        for (;current.length && depth < n; ) {
            next = [], nextMap = {};
            for (let i = 0, curLen = current.length; i < curLen; i++) {
                const node = current[i];
                node.depth = depth;
                for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                    const link = node.sourceLinks[j];
                    nextMap[link.target] || (next.push(this._nodeMap[link.target]), nextMap[link.target] = !0);
                }
            }
            current = next, depth += 1;
        }
        depth > n && this._logger.warn("Error: there is a circular link"), this._maxDepth = depth;
    }
    computeNodeEndDepths(nodes) {
        const n = nodes.length;
        let next, nextMap, current = nodes, depth = 0;
        for (;current.length && depth < n; ) {
            next = [], nextMap = {};
            for (let i = 0, curLen = current.length; i < curLen; i++) {
                const node = current[i];
                node.endDepth = depth;
                for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                    const link = node.targetLinks[j];
                    nextMap[link.source] || (next.push(this._nodeMap[link.source]), nextMap[link.source] = !0);
                }
            }
            current = next, depth += 1;
        }
        depth > n && this._logger.warn("Error: there is a circular link");
    }
    computeNodeLayers(nodes) {
        const nodeWidthOption = this.options.nodeWidth, linkWidthOption = this.options.linkWidth, minStepWidth = this.options.minStepWidth, width = this._viewBox.width;
        let nodeWidth = null, linkWidth = null, isEvenWidth = !1;
        if (isString(nodeWidthOption)) {
            const ratio = clamp(parseFloat(nodeWidthOption.replace("%", "")) / 100, 0, 1);
            let stepWidth = width / (this._maxDepth - 1 + ratio);
            minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), nodeWidth = stepWidth * ratio, 
            linkWidth = stepWidth * (1 - ratio), isEvenWidth = !0;
        } else if (isNumber(nodeWidthOption)) {
            if (nodeWidth = nodeWidthOption, isNumber(linkWidthOption)) linkWidth = linkWidthOption; else if (isNil(linkWidthOption)) {
                let stepWidth = (width - nodeWidthOption) / (this._maxDepth - 1);
                minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), linkWidth = stepWidth - nodeWidthOption;
            }
            isEvenWidth = !0;
        } else isFunction(nodeWidthOption) && isNumber(linkWidthOption) && (linkWidth = linkWidthOption);
        const columns = [];
        for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            node.layer = this._isHierarchic ? node.depth : clamp(Math.floor(this._alignFunc(node, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);
            const layer = node.layer;
            layer === this._maxDepth - 1 && (node.isLastLayer = !0), isEvenWidth && (node.x0 = this._viewBox.x0 + layer * (nodeWidth + linkWidth), 
            node.x1 = node.x0 + nodeWidth), columns[layer] ? columns[layer].push(node) : columns[layer] = [ node ];
        }
        if (this.options.nodeSortBy) for (let j = 0, colLen = columns.length; j < colLen; j++) columns[j].sort(this.options.nodeSortBy);
        if (!isEvenWidth && isFunction(nodeWidthOption)) {
            let curLayerX = this._viewBox.x0;
            for (let i = 0; i < this._maxDepth; i++) {
                const column = columns[i];
                let maxNodeWidth = 0, maxLinkWidth = 0;
                for (let j = 0, colLen = column.length; j < colLen; j++) {
                    const node = column[j], curNodeWidth = nodeWidthOption(node);
                    node.x0 = curLayerX, node.x1 = curLayerX + curNodeWidth, maxNodeWidth = Math.max(nodeWidth, curNodeWidth);
                    const sourceLinks = node.sourceLinks;
                    for (let k = 0, linkLen = sourceLinks.length; k < linkLen; k++) {
                        const link = sourceLinks[k], curLinkWidth = isFunction(linkWidthOption) ? linkWidthOption(link) : linkWidth;
                        maxLinkWidth = Math.max(maxLinkWidth, curLinkWidth);
                    }
                }
                curLayerX += maxNodeWidth;
            }
        }
        return columns;
    }
    initializeNodeBreadths(columns) {
        const minLinkHeight = this.options.minLinkHeight;
        let minNodeHeight = this.options.minNodeHeight;
        (isNil(minNodeHeight) || minNodeHeight < minLinkHeight) && (minNodeHeight = minLinkHeight);
        let ky = 0, getGapY = null;
        if (isFunction(this.options.nodeGap)) getGapY = this.options.nodeGap, ky = columns.reduce(((val, column) => {
            const sumValue = column.reduce(((sum, node) => sum + node.value), 0), sumGapY = column.reduce(((sum, node) => sum + this.options.nodeGap(node)), 0);
            return Math.min(val, (this._viewBox.height - sumGapY) / sumValue);
        }), 1 / 0); else {
            const maxRowCount = columns.reduce(((cnt, column) => Math.max(cnt, column.length)), 0), gapY = Math.min(minNodeHeight > 0 ? Math.max(this.options.nodeGap, minNodeHeight) : this.options.nodeGap, this._viewBox.height / maxRowCount);
            getGapY = () => gapY, this._gapY = gapY, ky = columns.reduce(((val, column) => {
                const sumValue = column.reduce(((sum, node) => sum + node.value), 0);
                return Math.min(val, (this._viewBox.height - (column.length - 1) * gapY) / sumValue);
            }), 1 / 0);
        }
        const isStartGap = "start" === this.options.gapPosition, isMiddleGap = !isStartGap && "end" !== this.options.gapPosition;
        for (let i = 0, columnCount = columns.length; i < columnCount; i++) {
            const nodes = columns[i];
            let y = this._viewBox.y0, gapY = 0;
            for (let j = 0, len = nodes.length; j < len; j++) {
                const node = nodes[j];
                gapY = getGapY(node), isStartGap && (y += gapY), node.y0 = y, node.y1 = y + (minNodeHeight > 0 && 0 !== node.value ? Math.max(node.value * ky, minNodeHeight) : node.value * ky), 
                y = isStartGap ? node.y1 : node.y1 + gapY;
                for (let k = 0, linkLen = node.sourceLinks.length; k < linkLen; k++) {
                    const link = node.sourceLinks[k];
                    link.thickness = minLinkHeight > 0 && 0 !== link.value ? Math.max(link.value * ky, minLinkHeight) : link.value * ky;
                }
            }
            let deltaY = this._viewBox.y1 - y + (isMiddleGap ? gapY : 0);
            if (deltaY > 0) if ("start" === this.options.crossNodeAlign) ; else if ("end" === this.options.crossNodeAlign) for (let j = 0, len = nodes.length; j < len; ++j) {
                const node = nodes[j];
                node.y0 += deltaY, node.y1 += deltaY;
            } else {
                deltaY /= nodes.length + 1;
                for (let j = 0, len = nodes.length; j < len; ++j) {
                    const node = nodes[j];
                    node.y0 += deltaY * (j + 1), node.y1 += deltaY * (j + 1);
                }
            } else if (deltaY < 0 && nodes.length > 1 && (deltaY /= nodes.length - 1, gapY + deltaY > 0)) {
                gapY += deltaY;
                for (let j = 1, len = nodes.length; j < len; ++j) {
                    const node = nodes[j];
                    node.y0 += deltaY * j, node.y1 += deltaY * j;
                }
            }
            this.reorderLinks(nodes);
        }
    }
    computeNodeBreadths(nodes) {
        const columns = this.computeNodeLayers(nodes);
        this.initializeNodeBreadths(columns);
        const iterations = this.options.iterations;
        if (!this._isHierarchic && !isFunction(this.options.setNodeLayer) && !isFunction(this.options.nodeGap)) for (let i = 0; i < iterations; ++i) {
            const alpha = Math.pow(.99, i), beta = Math.max(1 - alpha, (i + 1) / iterations);
            this.relaxRightToLeft(columns, alpha, beta), this.relaxLeftToRight(columns, alpha, beta);
        }
        return columns;
    }
    relaxLeftToRight(columns, alpha, beta) {
        for (let i = 1, n = columns.length; i < n; ++i) {
            const column = columns[i];
            for (let j = 0, colLen = column.length; j < colLen; j++) {
                const target = column[j];
                let y = 0, w = 0;
                for (let k = 0, linkLen = target.targetLinks.length; k < linkLen; k++) {
                    const link = target.targetLinks[k], v = link.value * (target.layer - this._nodeMap[link.source].layer);
                    y += this.targetTop(this._nodeMap[link.source], target) * v, w += v;
                }
                if (!(w > 0)) continue;
                const dy = (y / w - target.y0) * alpha;
                target.y0 += dy, target.y1 += dy, this.reorderNodeLinks(target);
            }
            isNil(this.options.nodeSortBy) && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
        }
    }
    relaxRightToLeft(columns, alpha, beta) {
        for (let i = columns.length - 2; i >= 0; --i) {
            const column = columns[i];
            for (let j = 0, colLen = column.length; j < colLen; j++) {
                const source = column[j];
                let y = 0, w = 0;
                for (let k = 0, linkLen = source.sourceLinks.length; k < linkLen; k++) {
                    const link = source.sourceLinks[k], v = link.value * (this._nodeMap[link.target].layer - source.layer);
                    y += this.sourceTop(source, this._nodeMap[link.target]) * v, w += v;
                }
                if (!(w > 0)) continue;
                const dy = (y / w - source.y0) * alpha;
                source.y0 += dy, source.y1 += dy, this.reorderNodeLinks(source);
            }
            void 0 === this.options.nodeSortBy && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
        }
    }
    resolveCollisions(nodes, alpha) {
        const i = nodes.length >> 1, subject = nodes[i];
        this.resolveCollisionsBottomToTop(nodes, subject.y0 - this._gapY, i - 1, alpha), 
        this.resolveCollisionsTopToBottom(nodes, subject.y1 + this._gapY, i + 1, alpha), 
        this.resolveCollisionsBottomToTop(nodes, this._viewBox.y1, nodes.length - 1, alpha), 
        this.resolveCollisionsTopToBottom(nodes, this._viewBox.y0, 0, alpha);
    }
    resolveCollisionsTopToBottom(nodes, y, i, alpha) {
        for (;i < nodes.length; ++i) {
            const node = nodes[i], dy = (y - node.y0) * alpha;
            dy > 1e-6 && (node.y0 += dy, node.y1 += dy), y = node.y1 + this._gapY;
        }
    }
    resolveCollisionsBottomToTop(nodes, y, i, alpha) {
        for (;i >= 0; --i) {
            const node = nodes[i], dy = (node.y1 - y) * alpha;
            dy > 1e-6 && (node.y0 -= dy, node.y1 -= dy), y = node.y0 - this._gapY;
        }
    }
    targetTop(source, target) {
        let i, len, link, y = source.y0 - (source.sourceLinks.length - 1) * this._gapY / 2;
        for (i = 0, len = source.sourceLinks.length; i < len && (link = source.sourceLinks[i], 
        link.target !== target.key); i++) y += link.thickness + this._gapY;
        for (i = 0, len = target.targetLinks.length; i < len && (link = target.targetLinks[i], 
        link.source !== source.key); i++) y -= link.thickness;
        return y;
    }
    sourceTop(source, target) {
        let i, len, link, y = target.y0 - (target.targetLinks.length - 1) * this._gapY / 2;
        for (i = 0, len = target.targetLinks.length; i < len && (link = target.targetLinks[i], 
        link.source !== source.key); i++) y += link.thickness + this._gapY;
        for (i = 0, len = source.sourceLinks.length; i < len && (link = source.sourceLinks[i], 
        link.target !== target.key); i++) y -= link.thickness;
        return y;
    }
    computeLinkBreadths(nodes) {
        for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            let y0 = node.y0, y1 = y0;
            for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                const link = node.sourceLinks[j];
                link.y0 = y0 + link.thickness / 2, link.x0 = node.x1, y0 += link.thickness;
            }
            for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                const link = node.targetLinks[j];
                link.y1 = y1 + link.thickness / 2, link.x1 = node.x0, y1 += link.thickness;
            }
        }
    }
    reorderNodeLinks(node) {
        if (isNil(this.options.linkSortBy)) {
            const targetLinks = node.targetLinks, sourceLinks = node.sourceLinks;
            for (let j = 0, linkLen = targetLinks.length; j < linkLen; j++) {
                const link = targetLinks[j];
                this._nodeMap[link.source].sourceLinks.sort(this._ascendingTargetBreadth);
            }
            for (let j = 0, linkLen = sourceLinks.length; j < linkLen; j++) {
                const link = sourceLinks[j];
                this._nodeMap[link.target].targetLinks.sort(this._ascendingSourceBreadth);
            }
        }
    }
    reorderLinks(nodes) {
        if (isNil(this.options.linkSortBy)) for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            node.sourceLinks.sort(this._ascendingTargetBreadth), node.targetLinks.sort(this._ascendingSourceBreadth);
        }
    }
}

SankeyLayout.defaultOptions = {
    iterations: 6,
    nodeAlign: "justify",
    direction: "horizontal",
    nodeWidth: 24,
    nodeGap: 8,
    crossNodeAlign: "middle",
    dropIsolatedNode: !0
};
//# sourceMappingURL=layout.js.map