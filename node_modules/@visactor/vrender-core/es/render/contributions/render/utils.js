import { isArray, abs, acos, atan2, cos, epsilon, min, pi, sin, sqrt, pi2 } from "@visactor/vutils";

import { renderCommandList } from "../../../common/render-command-list";

import { getTheme } from "../../../graphic/theme";

export function runFill(fill, background) {
    return !(!fill && !background);
}

export function runStroke(stroke, lineWidth) {
    let s;
    return s = isArray(stroke) ? stroke.some((item => item || void 0 === item)) : !!stroke, 
    s && lineWidth > 0;
}

export function fillVisible(opacity, fillOpacity, fill) {
    return fill && opacity * fillOpacity > 0;
}

export function rectFillVisible(opacity, fillOpacity, width, height, fill) {
    return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}

export function strokeVisible(opacity, strokeOpacity) {
    return opacity * strokeOpacity > 0;
}

export function rectStrokeVisible(opacity, strokeOpacity, width, height) {
    return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}

export function drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (!graphic.pathProxy) return !1;
    const themeAttributes = getTheme(graphic, null == params ? void 0 : params.theme)[graphic.type], {fill: fill = themeAttributes.fill, stroke: stroke = themeAttributes.stroke, opacity: opacity = themeAttributes.opacity, fillOpacity: fillOpacity = themeAttributes.fillOpacity, lineWidth: lineWidth = themeAttributes.lineWidth, strokeOpacity: strokeOpacity = themeAttributes.strokeOpacity, visible: visible = themeAttributes.visible} = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke, lineWidth);
    if (!visible) return !0;
    if (!doFill && !doStroke) return !0;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
    context.beginPath();
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), 
    doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x, y, themeAttributes), 
    context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x, y, themeAttributes), 
    context.fill())), !0;
}

export function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    const x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2;
    let t = y32 * x10 - x32 * y10;
    return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [ x0 + t * x10, y0 + t * y10 ]);
}

export function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
    const x01 = x0 - x1, y01 = y0 - y1, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
    let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;
    const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), 
    {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
    };
}

export function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= epsilon) context.moveTo(cx, cy); else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), 
    context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), 
    context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise)); else {
        const cornerRadius = arc.getParsedCornerRadius(), {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
        let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
        const xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
        let xore, yore, xirs, yirs;
        if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), 
        yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), 
        yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
            const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
            if (oc) {
                const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
            }
        }
        if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), 
        collapsedToLine = !0; else if (limitedOcr > epsilon) {
            const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
            limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), 
            cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
        } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
        if (!(innerRadius > epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        collapsedToLine = !0; else if (limitedIcr > epsilon) {
            const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
            if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                const arcEndAngle = atan2(t1.y01, t1.x01);
                !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
            } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), 
            cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
        } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    }
    return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), 
    collapsedToLine;
}
//# sourceMappingURL=utils.js.map
