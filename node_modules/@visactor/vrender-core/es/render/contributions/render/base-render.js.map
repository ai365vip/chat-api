{"version":3,"sources":["../src/render/contributions/render/base-render.ts"],"names":[],"mappings":"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","file":"base-render.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\nimport { injectable } from '../../../common/inversify-lite';\nimport type {\n  IGraphicAttribute,\n  ICamera,\n  IContext2d,\n  IGraphic,\n  mat4,\n  IRenderService,\n  IDrawContext,\n  IGraphicRenderDrawParams,\n  IMarkAttribute,\n  IThemeAttribute,\n  IContributionProvider,\n  ICircleRenderContribution,\n  IBaseRenderContribution\n} from '../../../interface';\nimport { getModelMatrix, multiplyMat4Mat4, shouldUseMat4 } from '../../../graphic';\nimport { mat4Allocate } from '../../../allocator/matrix-allocate';\nimport { drawPathProxy, fillVisible, runFill, runStroke, strokeVisible } from './utils';\nimport { BaseRenderContributionTime } from '../../../common/enums';\n\nconst result: IPointLike & { z: number; lastModelMatrix: mat4 } = { x: 0, y: 0, z: 0, lastModelMatrix: null };\n\nexport abstract class BaseRender<T extends IGraphic> {\n  camera: ICamera;\n  declare z: number;\n\n  builtinContributions: IBaseRenderContribution<T, T['attribute']>[];\n\n  // declare renderContribitions: IContributionProvider<IBaseRenderContribution<T, T['attribute']>> | null;\n\n  protected _beforeRenderContribitions: IBaseRenderContribution<T, T['attribute']>[];\n  protected _afterRenderContribitions: IBaseRenderContribution<T, T['attribute']>[];\n  protected _renderContribitions: IBaseRenderContribution<T, T['attribute']>[];\n\n  init(contributions?: IContributionProvider<IBaseRenderContribution<T, T['attribute']>>) {\n    if (contributions) {\n      // this.renderContribitions = contributions;\n      this._renderContribitions = contributions.getContributions();\n    }\n    if (!this._renderContribitions) {\n      this._renderContribitions = [];\n    }\n    this.builtinContributions && this.builtinContributions.forEach(item => this._renderContribitions.push(item));\n    if (this._renderContribitions.length) {\n      this._renderContribitions.sort((a, b) => b.order - a.order);\n      this._beforeRenderContribitions = this._renderContribitions.filter(\n        c => c.time === BaseRenderContributionTime.beforeFillStroke\n      );\n      this._afterRenderContribitions = this._renderContribitions.filter(\n        c => c.time === BaseRenderContributionTime.afterFillStroke\n      );\n    }\n  }\n\n  beforeRenderStep(\n    graphic: T,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    graphicAttribute: Required<T['attribute']>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    params?: any\n  ) {\n    this._beforeRenderContribitions &&\n      this._beforeRenderContribitions.forEach(c => {\n        c.drawShape(\n          graphic,\n          context,\n          x,\n          y,\n          doFill,\n          doStroke,\n          fVisible,\n          sVisible,\n          graphicAttribute,\n          drawContext,\n          fillCb,\n          strokeCb,\n          params\n        );\n      });\n  }\n\n  afterRenderStep(\n    graphic: T,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    graphicAttribute: Required<T['attribute']>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    params?: any\n  ) {\n    this._afterRenderContribitions &&\n      this._afterRenderContribitions.forEach(c => {\n        c.drawShape(\n          graphic,\n          context,\n          x,\n          y,\n          doFill,\n          doStroke,\n          fVisible,\n          sVisible,\n          graphicAttribute,\n          drawContext,\n          fillCb,\n          strokeCb,\n          params\n        );\n      });\n  }\n\n  valid(graphic: IGraphic, defaultAttribute: IGraphicAttribute, fillCb?: any, strokeCb?: any) {\n    const {\n      fill = defaultAttribute.fill,\n      background,\n      stroke = defaultAttribute.stroke,\n      opacity = defaultAttribute.opacity,\n      fillOpacity = defaultAttribute.fillOpacity,\n      lineWidth = defaultAttribute.lineWidth,\n      strokeOpacity = defaultAttribute.strokeOpacity,\n      visible = defaultAttribute.visible\n    } = graphic.attribute;\n    const fVisible = fillVisible(opacity, fillOpacity, fill);\n    const sVisible = strokeVisible(opacity, strokeOpacity);\n    const doFill = runFill(fill, background);\n    const doStroke = runStroke(stroke, lineWidth);\n\n    if (!(graphic.valid && visible)) {\n      return false;\n    }\n\n    if (!(doFill || doStroke)) {\n      return false;\n    }\n\n    // 如果存在fillCb和strokeCb，以及background那就不直接跳过\n    if (!(fVisible || sVisible || fillCb || strokeCb || background)) {\n      return false;\n    }\n    return {\n      fVisible,\n      sVisible,\n      doFill,\n      doStroke\n    };\n  }\n\n  /**\n   * 进行2d或3d变换\n   * @param graphic\n   * @param graphicAttribute\n   * @param context\n   * @param use3dMatrixIn3dMode 是否在3d模式使用3d矩阵\n   * @returns\n   */\n  transform(\n    graphic: IGraphic,\n    graphicAttribute: IGraphicAttribute,\n    context: IContext2d,\n    use3dMatrixIn3dMode: boolean = false\n  ): IPointLike & { z: number; lastModelMatrix: mat4 } {\n    // const transMatrix = graphic.transMatrix;\n    const {\n      x = graphicAttribute.x,\n      y = graphicAttribute.y,\n      z = graphicAttribute.z,\n      scaleX = graphicAttribute.scaleX,\n      scaleY = graphicAttribute.scaleY,\n      angle = graphicAttribute.angle,\n      postMatrix\n    } = graphic.attribute;\n    // const onlyTranslate = transMatrix.onlyTranslate() && !postMatrix;\n\n    // 存在3d变换的时候，需要计算3d矩阵\n    const lastModelMatrix = context.modelMatrix;\n    const camera = context.camera;\n    // const result: IPointLike & { z: number; lastModelMatrix: mat4 } = { x, y, z, lastModelMatrix };\n    result.x = x;\n    result.y = y;\n    result.z = z;\n    result.lastModelMatrix = lastModelMatrix;\n\n    // 是否应该进行3d变换\n    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic));\n\n    // 是否仅有translate\n    const onlyTranslate = shouldTransform3d\n      ? graphic.transMatrix.onlyTranslate() && !postMatrix\n      : scaleX === 1 && scaleY === 1 && angle === 0 && !postMatrix;\n\n    if (shouldTransform3d) {\n      const nextModelMatrix = mat4Allocate.allocate();\n      // 计算模型矩阵\n      const modelMatrix = mat4Allocate.allocate();\n      getModelMatrix(modelMatrix, graphic, graphicAttribute);\n      // 合并模型矩阵\n      if (lastModelMatrix) {\n        multiplyMat4Mat4(nextModelMatrix, lastModelMatrix, modelMatrix);\n      } else {\n        multiplyMat4Mat4(nextModelMatrix, nextModelMatrix, modelMatrix);\n      }\n      result.x = 0;\n      result.y = 0;\n      result.z = 0;\n      context.modelMatrix = nextModelMatrix;\n      context.setTransform(1, 0, 0, 1, 0, 0, true);\n      mat4Allocate.free(modelMatrix);\n      // 有旋转的情况下需要手动计算模型矩阵\n      // TODO: 这里暂时都使用模型矩阵，因为视角旋转的时候如果当不固定角度那也需要用到模型矩阵\n    }\n\n    // 如果只有位移，且没计算3d变换矩阵，那么不设置context的2d矩阵\n    if (onlyTranslate && !lastModelMatrix) {\n      const point = graphic.getOffsetXY(graphicAttribute);\n      result.x += point.x;\n      result.y += point.y;\n      result.z = z;\n      // 当前context有rotate/scale，重置matrix\n      context.setTransformForCurrent();\n    } else if (shouldTransform3d) {\n      // 如果计算了3d矩阵，那么就不需要2d矩阵计算了\n      result.x = 0;\n      result.y = 0;\n      result.z = 0;\n      context.setTransform(1, 0, 0, 1, 0, 0, true);\n    } else {\n      if (camera && context.project) {\n        const point = graphic.getOffsetXY(graphicAttribute);\n        result.x += point.x;\n        result.y += point.y;\n        // result.x = 0;\n        // result.y = 0;\n        // 位置直接通过project设置，而2d变换通过变换矩阵完成\n        this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);\n      } else {\n        // 如果是纯2d的情况，那么直接设置context的2d矩阵\n        // 性能较差\n        context.transformFromMatrix(graphic.transMatrix, true);\n        result.x = 0;\n        result.y = 0;\n        result.z = 0;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * 将3d的transform转成context2d的transform\n   * @param graphic\n   * @param graphicAttribute\n   * @param z\n   * @param context\n   */\n  transformUseContext2d(graphic: IGraphic, graphicAttribute: IGraphicAttribute, z: number, context: IContext2d) {\n    const camera = context.camera;\n    this.camera = camera;\n    if (camera) {\n      const bounds = graphic.AABBBounds;\n      const width = bounds.x2 - bounds.x1;\n      const height = bounds.y2 - bounds.y1;\n      const p1 = context.project(0, 0, z);\n      const p2 = context.project(width, 0, z);\n      const p3 = context.project(width, height, z);\n      const _p1 = { x: 0, y: 0 };\n      const _p2 = { x: width, y: 0 };\n      const _p3 = { x: width, y: height };\n\n      context.camera = null;\n\n      // 生成3维矩阵\n      /* Adapted from phoria.js by ecomfe\n      * https://github.com/kevinroast/phoria.js\n      * Licensed under the BSD-3-Clause\n\n      * url: https://github.com/kevinroast/phoria.js/blob/736c6b854a679df180f8a6e689aeb218efa6dc01/scripts/phoria-renderer.js\n      * License: https://github.com/kevinroast/phoria.js/blob/master/LICENSE\n      * @license\n      */\n      const denom = 1.0 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y);\n      // calculate context transformation matrix\n      const m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom;\n      const m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom;\n      const m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom;\n      const m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom;\n      const dx =\n        (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) +\n          _p1.y * (_p2.x * p3.x - _p3.x * p2.x) +\n          (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) *\n        denom;\n      const dy =\n        (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) +\n          _p1.y * (_p2.x * p3.y - _p3.x * p2.y) +\n          (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) *\n        denom;\n\n      context.setTransform(m11, m12, m21, m22, dx, dy, true);\n    }\n  }\n\n  /**\n   * transformUseContext2d的后处理\n   * @param graphic\n   * @param graphicAttribute\n   * @param z\n   * @param context\n   */\n  restoreTransformUseContext2d(graphic: IGraphic, graphicAttribute: IGraphicAttribute, z: number, context: IContext2d) {\n    if (this.camera) {\n      context.camera = this.camera;\n    }\n  }\n\n  protected transformWithoutTranslate(\n    context: IContext2d,\n    x: number,\n    y: number,\n    z: number,\n    scaleX: number,\n    scaleY: number,\n    angle: number\n  ) {\n    const p = context.project(x, y, z);\n    context.translate(p.x, p.y, false);\n    context.scale(scaleX, scaleY, false);\n    context.rotate(angle, false);\n    context.translate(-p.x, -p.y, false);\n    context.setTransformForCurrent();\n  }\n\n  _draw(\n    graphic: T,\n    defaultAttr: IGraphicAttribute,\n    computed3dMatrix: boolean,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams\n  ) {\n    const { context } = drawContext;\n    if (!context) {\n      return;\n    }\n\n    context.highPerformanceSave();\n\n    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix);\n    const { x, y, z, lastModelMatrix } = data;\n\n    this.z = z;\n    if (drawPathProxy(graphic, context, x, y, drawContext, params)) {\n      context.highPerformanceRestore();\n      return;\n    }\n\n    this.drawShape(graphic, context, x, y, drawContext, params);\n    this.z = 0;\n\n    if (context.modelMatrix !== lastModelMatrix) {\n      mat4Allocate.free(context.modelMatrix);\n    }\n    context.modelMatrix = lastModelMatrix;\n\n    context.highPerformanceRestore();\n  }\n\n  drawShape?(\n    path: T,\n    context: IContext2d,\n    x: number,\n    y: number,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ): void;\n\n  // abstract drawShape(\n  //   graphic: T,\n  //   context: IContext2d,\n  //   x: number,\n  //   y: number,\n  //   drawContext: IDrawContext,\n  //   params?: IGraphicRenderDrawParams,\n  //   fillCb?: (\n  //     ctx: IContext2d,\n  //     markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n  //     themeAttribute: IThemeAttribute\n  //   ) => boolean,\n  //   strokeCb?: (\n  //     ctx: IContext2d,\n  //     markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n  //     themeAttribute: IThemeAttribute\n  //   ) => boolean\n  // ): void;\n\n  // drawPathProxy(\n  //   graphic: T,\n  //   context: IContext2d,\n  //   x: number,\n  //   y: number,\n  //   drawContext: IDrawContext,\n  //   params?: IGraphicRenderDrawParams,\n  //   fillCb?: (\n  //     ctx: IContext2d,\n  //     markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n  //     themeAttribute: IThemeAttribute\n  //   ) => boolean,\n  //   strokeCb?: (\n  //     ctx: IContext2d,\n  //     markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n  //     themeAttribute: IThemeAttribute\n  //   ) => boolean\n  // ) {\n  //   if (!graphic.pathProxy) {\n  //     return false;\n  //   }\n\n  //   const themeAttributes = getTheme(graphic)[graphic.type];\n\n  //   const {\n  //     fill = themeAttributes.fill == null ? !!graphic.attribute.fillColor : themeAttributes.fill,\n  //     stroke = themeAttributes.stroke == null ? !!graphic.attribute.strokeColor : themeAttributes.stroke,\n  //     opacity = themeAttributes.opacity,\n  //     fillOpacity = themeAttributes.fillOpacity,\n  //     lineWidth = themeAttributes.lineWidth,\n  //     strokeOpacity = themeAttributes.strokeOpacity,\n  //     visible = themeAttributes.visible\n  //   } = graphic.attribute;\n  //   // 不绘制或者透明\n  //   const fVisible = fillVisible(opacity, fillOpacity);\n  //   const sVisible = strokeVisible(opacity, strokeOpacity);\n  //   const doFill = runFill(fill);\n  //   const doStroke = runStroke(stroke, lineWidth);\n\n  //   if (!visible) {\n  //     return true;\n  //   }\n\n  //   if (!(doFill || doStroke)) {\n  //     return true;\n  //   }\n\n  //   // 如果存在fillCb和strokeCb，那就不直接跳过\n  //   if (!(fVisible || sVisible || fillCb || strokeCb)) {\n  //     return true;\n  //   }\n\n  //   context.beginPath();\n\n  //   const path = typeof graphic.pathProxy === 'function' ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;\n  //   renderCommandList(path.commandList, context, x, y);\n\n  //   // shadow\n  //   context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes);\n\n  //   if (doStroke) {\n  //     if (strokeCb) {\n  //       strokeCb(context, graphic.attribute, themeAttributes);\n  //     } else if (sVisible) {\n  //       context.setStrokeStyle(graphic, graphic.attribute, 0, 0, themeAttributes);\n  //       context.stroke();\n  //     }\n  //   }\n  //   if (doFill) {\n  //     if (fillCb) {\n  //       fillCb(context, graphic.attribute, themeAttributes);\n  //     } else if (fVisible) {\n  //       context.setCommonStyle(graphic, graphic.attribute, 0, 0, themeAttributes);\n  //       context.fill();\n  //     }\n  //   }\n  //   return true;\n  // }\n}\n"]}