import type { INode } from './node-tree';
import type { Dict, IBounds } from '@visactor/vutils';
import type { Cursor, IGraphicAttribute } from './graphic';
import type { IDomRectLike, IEventElement } from './common';
import type { ICanvas } from './canvas';
import type { IGlobal } from './global';
export type EventPoint = {
    x: number;
    y: number;
};
export interface IEventManager {
    rootTarget: IEventTarget;
    dispatch: any;
    cursor: Cursor | string;
    addEventMapping: (type: string, fn: (e: IFederatedEvent, target: IEventTarget) => void) => void;
    dispatchEvent: (e: IFederatedEvent, type?: string) => void;
    mapEvent: (e: IFederatedEvent) => void;
    propagate: (e: IFederatedEvent, type?: string) => void;
    propagationPath: (target: IEventTarget) => IEventTarget[];
    copyWheelData: (from: IFederatedWheelEvent, to: IFederatedWheelEvent) => void;
    copyPointerData: (from: IFederatedEvent, to: IFederatedEvent) => void;
    copyMouseData: (from: IFederatedEvent, to: IFederatedEvent) => void;
    copyData: (from: IFederatedEvent, to: IFederatedEvent) => void;
}
export interface IFederatedEvent<N = Event> {
    bubbles: boolean;
    cancelBubble: boolean;
    cancelable: boolean;
    composed: boolean;
    currentTarget: IEventTarget | null;
    defaultPrevented: boolean;
    eventPhase: number;
    isTrusted: boolean;
    returnValue: boolean;
    srcElement: IEventTarget;
    target: IEventTarget | null;
    timeStamp: number;
    type: string;
    nativeEvent: N;
    originalEvent: IFederatedEvent<N> | null;
    propagationStopped: boolean;
    propagationImmediatelyStopped: boolean;
    path: IEventTarget[];
    manager?: IEventManager;
    detail: any;
    view: any;
    layer: EventPoint;
    get layerX(): number;
    get layerY(): number;
    page: EventPoint;
    get pageX(): number;
    get pageY(): number;
    canvas: EventPoint;
    get x(): number;
    get y(): number;
    get canvasX(): number;
    get canvasY(): number;
    viewport: EventPoint;
    get viewX(): number;
    get viewY(): number;
    composedPath: () => IEventTarget[];
    preventDefault: () => void;
    stopImmediatePropagation: () => void;
    stopPropagation: () => void;
    initEvent: () => void;
    initUIEvent: () => void;
    clone: () => void;
    which: number;
}
export interface IFederatedMouseEvent extends IFederatedEvent {
    altKey: boolean;
    button: number;
    buttons: number;
    ctrlKey: boolean;
    metaKey: boolean;
    relatedTarget: EventTarget | null;
    shiftKey: boolean;
    client: EventPoint;
    get clientX(): number;
    get clientY(): number;
    detail: number;
    movement: EventPoint;
    get movementX(): number;
    get movementY(): number;
    offset: EventPoint;
    get offsetX(): number;
    get offsetY(): number;
    global: EventPoint;
    get globalX(): number;
    get globalY(): number;
    screen: EventPoint;
    get screenX(): number;
    get screenY(): number;
    getModifierState: (key: string) => boolean;
    initMouseEvent: (_typeArg: string, _canBubbleArg: boolean, _cancelableArg: boolean, _viewArg: Window, _detailArg: number, _screenXArg: number, _screenYArg: number, _clientXArg: number, _clientYArg: number, _ctrlKeyArg: boolean, _altKeyArg: boolean, _shiftKeyArg: boolean, _metaKeyArg: boolean, _buttonArg: number, _relatedTargetArg: EventTarget) => void;
}
export interface IFederatedWheelEvent extends IFederatedMouseEvent {
    deltaMode: number;
    deltaX: number;
    deltaY: number;
    deltaZ: number;
    clone: () => IFederatedWheelEvent;
}
export interface IFederatedPointerEvent extends IFederatedMouseEvent {
    pointerId: number;
    width: number;
    height: number;
    isPrimary: boolean;
    pointerType: string;
    pressure: number;
    tangentialPressure: number;
    tiltX: number;
    tiltY: number;
    twist: number;
    detail: number;
    getCoalescedEvents: () => PointerEvent[];
    getPredictedEvents: () => PointerEvent[];
    clone: () => IFederatedPointerEvent;
}
export interface IEventTarget extends INode {
    pickable: boolean;
    parent: IEventTarget | null;
    visible: boolean;
    children?: IEventTarget[];
    childrenPickable?: boolean;
    attribute?: Partial<IGraphicAttribute>;
    emit: (eventName: any, data: Dict<any>) => boolean;
    getCursor: () => string;
    setCursor: (c?: string) => void;
}
export interface IRender {
    visualCanvas: {
        getCanvas: () => HTMLElement;
    };
    pickEvent: (position: [number, number], children: IEventTarget[], geoPick?: boolean) => IEventTarget | null;
    [key: string]: any;
}
export interface IEventExtension {
    initEvents: () => void;
    removeEvents: () => void;
    release: () => void;
}
export type LooseFunction = (...args: any[]) => any;
export type IElementLike = Omit<IEventElement, 'on' | 'off' | 'once' | 'emit' | 'removeAllListeners'> & {
    style: CSSStyleDeclaration | Record<string, any>;
    getNativeHandler?: () => ICanvas;
    getBoundingClientRect: () => IDomRectLike;
};
export type RenderConfig = {
    targetElement: IElementLike;
    resolution: number;
    rootNode: IEventTarget;
    global: IGlobal;
    autoPreventDefault?: boolean;
    viewport: {
        x: number;
        y: number;
        width: number;
        height: number;
        viewBox?: IBounds;
    };
    clickInterval?: number;
    supportsTouchEvents?: boolean;
    supportsPointerEvents?: boolean;
};
export type NativeEvent = MouseEvent | PointerEvent | TouchEvent;
export type GraphicEventType = 'pointerdown' | 'pointerup' | 'pointerupoutside' | 'pointertap' | 'pointerover' | 'pointerenter' | 'pointerleave' | 'pointerout' | 'mousedown' | 'mouseup' | 'mouseupoutside' | 'rightdown' | 'rightup' | 'rightupoutside' | 'click' | 'dblclick' | 'mousemove' | 'mouseover' | 'mouseout' | 'mouseenter' | 'mouseleave' | 'wheel' | 'tap' | 'touchstart' | 'touchend' | 'touchendoutside' | 'touchmove' | 'touchcancel' | 'dragstart' | 'drag' | 'dragenter' | 'dragleave' | 'dragover' | 'dragend' | 'drop' | 'pan' | 'panstart' | 'panend' | 'press' | 'pressup' | 'pressend' | 'pinch' | 'pinchstart' | 'pinchend' | 'swipe';
