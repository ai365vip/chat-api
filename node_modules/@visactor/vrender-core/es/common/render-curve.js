import { min } from "@visactor/vutils";

import { Direction } from "./enums";

import { drawSegItem } from "./render-utils";

export function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
    var _a;
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0, mode: mode = "none", drawConnect: drawConnect = !1, zeroX: zeroX = 0, zeroY: zeroY = 0} = params || {};
    if (drawConnect && "none" === mode) return;
    if (!segPath) return;
    let needMoveTo = !0;
    const {curves: curves} = segPath;
    if (percent >= 1) {
        if (drawConnect) {
            let lastCurve, defined0 = !0;
            curves.forEach(((curve, i) => {
                var _a;
                let p0 = curve.p0;
                if (curve.originP1 !== curve.originP2) {
                    if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), 
                    curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), 
                    defined0 = !defined0); else {
                        const {originP1: originP1, originP2: originP2} = curve;
                        let validP;
                        if (originP1 && !1 !== originP1.defined ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), 
                        defined0) {
                            defined0 = !defined0;
                            const x = validP ? validP.x : curve.p0.x, y = validP ? validP.y : curve.p0.y;
                            path.moveTo(x + offsetX, y + offsetY, offsetZ);
                        } else validP && (defined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
                    }
                    lastCurve = curve;
                } else lastCurve = curve;
            }));
        } else curves.forEach((curve => {
            curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
            drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
        }));
        return;
    }
    if (percent <= 0) return;
    let direction;
    "x" === clipRangeByDimension ? direction = Direction.ROW : "y" === clipRangeByDimension ? direction = Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
    const totalDrawLength = percent * segPath.tryUpdateLength(direction);
    let drawedLengthUntilLast = 0, defined0 = !0, lastCurve = null;
    for (let i = 0, n = curves.length; i < n; i++) {
        const curve = curves[i], curCurveLength = curve.getLength(direction), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
        if (drawConnect) {
            let p0 = curve.p0;
            if (curve.originP1 === curve.originP2) {
                lastCurve = curve;
                continue;
            }
            if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), 
            curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), 
            defined0 = !defined0); else {
                const {originP1: originP1, originP2: originP2} = curve;
                let validP;
                if (originP1 && !1 !== originP1.defined ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), 
                defined0) {
                    defined0 = !defined0;
                    const x = validP ? validP.x : curve.p0.x, y = validP ? validP.y : curve.p0.y;
                    path.moveTo(x + offsetX, y + offsetY, offsetZ);
                } else validP && (defined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
            }
            lastCurve = curve;
        } else {
            if (!curve.defined) {
                needMoveTo = !0;
                continue;
            }
            needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
            drawSegItem(path, curve, min(_p, 1), params), needMoveTo = !1;
        }
    }
}

export function drawIncrementalSegments(path, lastSeg, segments, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach((p => {
        !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    }));
}

export function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, {points: points} = segments, definedPointsList = [];
    let lastIdx = 0;
    for (let i = 0; i < points.length; i++) !1 === points[i].defined && (lastIdx + 1 !== i && definedPointsList.slice(lastIdx, i), 
    lastIdx = i);
    definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach(((points, i) => {
        var _a, _b, _c, _d;
        const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];
        path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach((p => {
            !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
        }));
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        }
        path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), 
        path.closePath();
    }));
}