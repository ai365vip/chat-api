var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

export function foreach(graphic, defaultZIndex, cb, reverse = !1, sort3d = !1) {
    const childMap = {}, zIdxArray = [];
    let needSort = !1;
    if (sort3d) needSort = !0; else {
        let lastZIndex;
        graphic.forEachChildren(((item, i) => {
            const {zIndex: zIndex = defaultZIndex} = item.attribute;
            if (0 === i) lastZIndex = zIndex; else if (lastZIndex !== zIndex) return needSort = !0, 
            !0;
            return !1;
        }), reverse);
    }
    if (needSort) {
        graphic.forEachChildren((item => {
            const {zIndex: zIndex = defaultZIndex} = item.attribute;
            childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [ item ], zIdxArray.push(zIndex));
        }), reverse), zIdxArray.sort(((a, b) => reverse ? b - a : a - b));
        let skip = !1;
        for (let i = 0; i < zIdxArray.length && !skip; i++) {
            const idx = zIdxArray[i], children = childMap[idx];
            sort3d && children.sort(((a, b) => {
                var _a, _b;
                return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a.attribute.z) && void 0 !== _b ? _b : 0));
            }));
            for (let i = 0; i < children.length; i++) if (cb(children[i], i)) {
                skip = !0;
                break;
            }
        }
    } else graphic.forEachChildren(cb, reverse);
}

export function foreachAsync(graphic, defaultZIndex, cb, reverse = !1) {
    return __awaiter(this, void 0, void 0, (function*() {
        yield graphic.forEachChildrenAsync(cb, reverse);
    }));
}

export function findNextGraphic(graphic, id, defaultZIndex, reverse = !1) {
    const childMap = {}, zIdxArray = [];
    let needSort = !1;
    graphic.forEachChildren(((item, i) => {
        const {zIndex: zIndex = defaultZIndex} = item.attribute;
        if (0 === i) ; else if (undefined !== zIndex) return needSort = !0, !0;
        return !1;
    }), reverse);
    let result = null, next = !1;
    if (needSort) {
        graphic.forEachChildren((item => {
            const {zIndex: zIndex = defaultZIndex} = item.attribute;
            childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [ item ], zIdxArray.push(zIndex));
        }), reverse), zIdxArray.sort(((a, b) => reverse ? b - a : a - b));
        let skip = !1;
        for (let i = 0; i < zIdxArray.length && !skip; i++) {
            const idx = zIdxArray[i], children = childMap[idx];
            for (let i = 0; i < children.length; i++) {
                if (next) {
                    skip = !0, result = children[i];
                    break;
                }
                children[i]._uid !== id || (next = !0);
            }
        }
    } else graphic.forEachChildren((item => next ? (result = item, !0) : (item._uid === id && (next = !0), 
    !1)), reverse);
    return result;
}
//# sourceMappingURL=sort.js.map