import { isBoolean, halfPi, pi, pi2, sin, cos, isArray, pointAt, Point, isString } from "@visactor/vutils";

export var Edge;

!function(Edge) {
    Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", 
    Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
}(Edge || (Edge = {}));

const _strokeVec4 = [ !1, !1, !1, !1 ];

export const parseStroke = stroke => {
    var _a;
    let isFullStroke = !0;
    if (isBoolean(stroke, !0)) {
        for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
        isFullStroke = stroke;
    } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], 
    isFullStroke && (isFullStroke = !!_strokeVec4[i]); else _strokeVec4[0] = !1, _strokeVec4[1] = !1, 
    _strokeVec4[2] = !1, _strokeVec4[3] = !1;
    return {
        isFullStroke: isFullStroke,
        stroke: _strokeVec4
    };
};

const _paddingVec4 = [ 0, 0, 0, 0 ];

export const parsePadding = padding => padding ? isArray(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], 
_paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], 
_paddingVec4) : padding : padding : 0;

const _coords = [ {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
} ], indexList = [ 1, 2, 3, 0, 1, 2, 3, 0 ];

export function circleBounds(startAngle, endAngle, radius, bounds) {
    for (;startAngle >= pi2; ) startAngle -= pi2;
    for (;startAngle < 0; ) startAngle += pi2;
    for (;startAngle > endAngle; ) endAngle += pi2;
    _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
    const startIdx = Math.ceil(startAngle / halfPi) % 4, endIdx = Math.ceil(endAngle / halfPi) % 4;
    if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), 
    startIdx !== endIdx || endAngle - startAngle > pi) {
        let match = !1;
        for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
            if (match && endIdx === indexList[i]) break;
            if (match) {
                const p = _coords[indexList[i]];
                bounds.add(p.x, p.y);
            }
        } else {
            match = !0;
            const p = _coords[startIdx];
            bounds.add(p.x, p.y);
        }
    }
}

export function pointsEqual(pointsA, pointsB) {
    return !(!pointsA || !pointsB) && (Array.isArray(pointsA) && Array.isArray(pointsB) ? pointsA.length === pointsB.length && pointsA.every(((point, index) => pointEqual(point, pointsB[index]))) : !Number.isNaN(pointsA.x + pointsA.y) && pointEqual(pointsA, pointsB));
}

export function pointEqual(pointA, pointB) {
    return pointA.x === pointB.x && pointA.y === pointB.y && pointA.x1 === pointB.x1 && pointA.y1 === pointB.y1 && pointA.defined === pointB.defined;
}

export function pointInterpolation(pointA, pointB, ratio) {
    const {x: x, y: y} = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point = new Point(x, y, x1, y1);
    return point.defined = pointB.defined, point;
}

export function pointInterpolationHighPerformance(pointA, pointB, ratio, point) {
    const {x: x, y: y} = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
    return point.x = x, point.y = y, point.x1 = x1, point.y1 = y1, point.defined = pointB.defined, 
    point;
}

export function pointsInterpolation(pointsA, pointsB, ratio) {
    if (!pointsA || !pointsB) return [];
    Array.isArray(pointsA) || (pointsA = [ pointsA ]), Array.isArray(pointsB) || (pointsB = [ pointsB ]);
    let points = [];
    if (pointsA.length > pointsB.length) {
        points = pointsB.map((point => {
            const p = new Point(point.x, point.y, point.x1, point.y1);
            return p.defined = point.defined, p;
        }));
        for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
    } else {
        points = pointsB.map((point => {
            const p = new Point(point.x, point.y, point.x1, point.y1);
            return p.defined = point.defined, p;
        }));
        for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
    }
    return points;
}

export const transformKeys = [ "x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "scrollX", "scrollY" ];

export const isTransformKey = key => transformKeys.includes(key);

export function getAttributeFromDefaultAttrList(attr, key) {
    if (isArray(attr)) {
        let val;
        for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
        return val;
    }
    return attr[key];
}

export class RafBasedSTO {
    constructor() {
        this.durations = [], this.timeout = RafBasedSTO.TimeOut, this.lastDate = 0, this.durationsListThreshold = 30;
    }
    call(cb) {
        return this.lastDate = Date.now(), setTimeout((() => {
            this.appendDuration(Date.now() - this.lastDate), cb(0);
        }), this.timeout, !0);
    }
    clear(h) {
        clearTimeout(h);
    }
    appendDuration(d) {
        this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), 
        this.timeout = Math.min(Math.max(this.durations.reduce(((a, b) => a + b), 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
    }
}

RafBasedSTO.TimeOut = 1e3 / 60;

export const rafBasedSto = new RafBasedSTO;

export const calculateLineHeight = (lineHeight, fontSize) => {
    if (isString(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
        return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
    }
    return lineHeight;
};
//# sourceMappingURL=utils.js.map