import { Generator } from "../generator";

import { Binding } from "./binding";

import { BindingScopeEnum, BindingTypeEnum } from "./literal_types";

import { INJECT_TAG, MULTI_INJECT_TAG, NAMED_TAG } from "./metadata_keys";

import { MetadataReader } from "./metadata_reader";

import { BindingToSyntax } from "./syntax/binding_to_syntax";

export class Container {
    constructor(containerOptions) {
        const options = containerOptions || {};
        options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, 
        this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = new Map, this._metadataReader = new MetadataReader;
    }
    load(module) {
        const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
        module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
    }
    get(serviceIdentifier) {
        const getArgs = this._getNotAllArgs(serviceIdentifier, !1);
        return this._get(getArgs);
    }
    getAll(serviceIdentifier) {
        const getArgs = this._getAllArgs(serviceIdentifier);
        return this._get(getArgs);
    }
    getTagged(serviceIdentifier, key, value) {
        const getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
        return this._get(getArgs);
    }
    getNamed(serviceIdentifier, named) {
        return this.getTagged(serviceIdentifier, NAMED_TAG, named);
    }
    isBound(serviceIdentifier) {
        return this._bindingDictionary.has(serviceIdentifier);
    }
    bind(serviceIdentifier) {
        const scope = this.options.defaultScope, binding = new Binding(serviceIdentifier, scope), list = this._bindingDictionary.get(serviceIdentifier) || [];
        return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), 
        new BindingToSyntax(binding);
    }
    unbind(serviceIdentifier) {
        this._bindingDictionary.delete(serviceIdentifier);
    }
    rebind(serviceIdentifier) {
        return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
    }
    _getContainerModuleHelpersFactory() {
        const setModuleId = (bindingToSyntax, moduleId) => {
            bindingToSyntax._binding.moduleId = moduleId;
        }, getBindFunction = moduleId => serviceIdentifier => {
            const bindingToSyntax = this.bind(serviceIdentifier);
            return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
        }, getUnbindFunction = () => serviceIdentifier => this.unbind(serviceIdentifier), getIsboundFunction = () => serviceIdentifier => this.isBound(serviceIdentifier), getRebindFunction = moduleId => serviceIdentifier => {
            const bindingToSyntax = this.rebind(serviceIdentifier);
            return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
        };
        return mId => ({
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(),
            unbindAsyncFunction: serviceIdentifier => null
        });
    }
    _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
        return {
            avoidConstraints: !1,
            isMultiInject: isMultiInject,
            serviceIdentifier: serviceIdentifier,
            key: key,
            value: value
        };
    }
    _getAllArgs(serviceIdentifier) {
        return {
            avoidConstraints: !0,
            isMultiInject: !0,
            serviceIdentifier: serviceIdentifier
        };
    }
    _get(getArgs) {
        const result = [];
        return this._bindingDictionary.get(getArgs.serviceIdentifier).filter((b => b.constraint(getArgs))).forEach((binding => {
            result.push(this._resolveFromBinding(binding));
        })), getArgs.isMultiInject || 1 !== result.length ? result : result[0];
    }
    _getChildRequest(binding) {
        const constr = binding.implementationType, {userGeneratedMetadata: userGeneratedMetadata} = this._metadataReader.getConstructorMetadata(constr), keys = Object.keys(userGeneratedMetadata), arr = [];
        for (let i = 0; i < keys.length; i++) {
            const constructorArgsMetadata = userGeneratedMetadata[i], targetMetadataMap = {};
            constructorArgsMetadata.forEach((md => {
                targetMetadataMap[md.key] = md.value;
            }));
            const metadata = {
                inject: targetMetadataMap[INJECT_TAG],
                multiInject: targetMetadataMap[MULTI_INJECT_TAG]
            }, injectIdentifier = metadata.inject || metadata.multiInject, target = {
                serviceIdentifier: injectIdentifier,
                constructorArgsMetadata: constructorArgsMetadata
            }, request = {
                injectIdentifier: injectIdentifier,
                metadata: constructorArgsMetadata,
                bindings: this._bindingDictionary.get(injectIdentifier).filter((b => b.constraint(target)))
            };
            arr.push(request);
        }
        return arr;
    }
    _resolveFromBinding(binding) {
        const result = this._getResolvedFromBinding(binding);
        return this._saveToScope(binding, result), result;
    }
    _getResolvedFromBinding(binding) {
        let result;
        switch (binding.type) {
          case BindingTypeEnum.ConstantValue:
          case BindingTypeEnum.Function:
            result = binding.cache;
            break;

          case BindingTypeEnum.Instance:
            result = this._resolveInstance(binding, binding.implementationType);
            break;

          default:
            result = binding.dynamicValue({
                container: this
            });
        }
        return result;
    }
    _resolveInstance(binding, constr) {
        if (binding.activated) return binding.cache;
        const childRequests = this._getChildRequest(binding);
        return this._createInstance(constr, childRequests);
    }
    _createInstance(constr, childRequests) {
        if (childRequests.length) {
            return new constr(...this._resolveRequests(childRequests));
        }
        return new constr;
    }
    _resolveRequests(childRequests) {
        return childRequests.map((request => request.bindings.length > 1 ? request.bindings.map((binding => this._resolveFromBinding(binding))) : this._resolveFromBinding(request.bindings[0])));
    }
    _saveToScope(binding, result) {
        binding.scope === BindingScopeEnum.Singleton && (binding.cache = result, binding.activated = !0);
    }
}
//# sourceMappingURL=container.js.map
