import { getDecimalPlaces, isArray, isNumber, pi, pi2, Point, PointService } from "@visactor/vutils";

import { application } from "../application";

import { AttributeUpdateType } from "../common/enums";

import { CustomPath2D } from "../common/custom-path2d";

import { ACustomAnimate } from "./animate";

import { Easing } from "./easing";

import { pointInterpolation } from "../common/utils";

import { divideCubic } from "../common/segment/curve/cubic-bezier";

export class IncreaseCount extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    getEndProps() {
        return !1 === this.valid ? {} : {
            text: this.to
        };
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.fromNumber = isNumber(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), 
        this.toNumber = isNumber(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), 
        Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = !1), 
        !1 !== this.valid && (this.decimalLength = null !== (_h = null === (_g = this.params) || void 0 === _g ? void 0 : _g.fixed) && void 0 !== _h ? _h : Math.max(getDecimalPlaces(this.fromNumber), getDecimalPlaces(this.toNumber)));
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        !1 !== this.valid && (out.text = end ? this.toNumber : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(this.decimalLength));
    }
}

var Direction;

!function(Direction) {
    Direction[Direction.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction[Direction.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", 
    Direction[Direction.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction[Direction.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", 
    Direction[Direction.STROKE = 4] = "STROKE";
}(Direction || (Direction = {}));

export class FadeInPlus extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        const {direction: direction = Direction.LEFT_TO_RIGHT, fill: fill = !0, stroke: stroke = !0} = params || {};
        this.direction = direction, this.fill = fill, this.stroke = stroke, this.fillGradient = {
            gradient: "linear",
            stops: []
        }, this.strokeGradient = {
            gradient: "linear",
            stops: []
        };
    }
    getEndProps() {
        return {
            fill: this.toFill,
            stroke: this.toStroke
        };
    }
    onBind() {
        this.toFill = this.target.getComputedAttribute("fill"), this.toStroke = this.target.getComputedAttribute("stroke");
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        if (this.toFill && this.toStroke) switch (this.direction) {
          case Direction.RIGHT_TO_LEFT:
            this.rightToLeft(end, ratio, out);
            break;

          case Direction.TOP_TO_BOTTOM:
            this.topToBottom(end, ratio, out);
            break;

          case Direction.BOTTOM_TO_TOP:
            this.bottomToTop(end, ratio, out);
            break;

          case Direction.STROKE:
            this.strokePath(end, ratio, out);
            break;

          default:
            this.leftToRight(end, ratio, out);
        }
    }
    leftToRight(end, ratio, out) {
        if (this.fill) {
            const toFillColor = this.toFill;
            this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, 
            this.fillGradient.stops = [ {
                offset: 0,
                color: toFillColor
            }, {
                offset: ratio,
                color: toFillColor
            }, {
                offset: Math.min(1, 2 * ratio),
                color: "transparent"
            } ], out.fill = this.fillGradient;
        }
        if (this.stroke) {
            const toStrokeColor = this.toStroke;
            this.strokeGradient.x0 = 0, this.strokeGradient.y0 = 0, this.strokeGradient.x1 = 1, 
            this.strokeGradient.y1 = 0, this.strokeGradient.stops = [ {
                offset: 0,
                color: toStrokeColor
            }, {
                offset: ratio,
                color: toStrokeColor
            }, {
                offset: Math.min(1, 6 * ratio),
                color: "transparent"
            } ], out.stroke = this.strokeGradient;
        }
    }
    strokePath(end, ratio, out) {
        if (this.fill) {
            const toFillColor = this.toFill;
            this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, 
            this.fillGradient.stops = [ {
                offset: 0,
                color: toFillColor
            }, {
                offset: ratio,
                color: toFillColor
            }, {
                offset: Math.min(1, 2 * ratio),
                color: "transparent"
            } ], out.fill = this.fillGradient;
        }
        if (this.stroke) {
            const dashLen = 300, offset = ratio * dashLen;
            out.lineDash = [ offset, dashLen - offset ];
        }
    }
    rightToLeft(end, ratio, out) {}
    topToBottom(end, ratio, out) {}
    bottomToTop(end, ratio, out) {}
}

export class InputText extends ACustomAnimate {
    constructor() {
        super(...arguments), this.fromText = "", this.toText = "";
    }
    getEndProps() {
        return !1 === this.valid ? {} : {
            text: this.to
        };
    }
    onBind() {
        var _a, _b, _c, _d;
        if (this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : "", 
        this.toText = null !== (_d = null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) && void 0 !== _d ? _d : "", 
        !this.toText || isArray(this.toText)) this.valid = !1; else {
            this.toText = this.toText.toString();
            const root = this.target.attachShadow(), line = application.graphicService.creator.line({
                x: 0,
                y: 0,
                points: [ {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: this.target.getComputedAttribute("fontSize")
                } ],
                stroke: "black",
                lineWidth: 1
            });
            root.add(line);
        }
    }
    onEnd() {
        this.target.detachShadow();
    }
    onUpdate(end, ratio, out) {
        var _a;
        if (!1 === this.valid) return;
        const fromCount = this.fromText.length, toCount = this.toText.length, count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
        out.text = this.toText.substr(0, count);
        const line = null === (_a = this.target.shadowRoot) || void 0 === _a ? void 0 : _a.at(0), endX = this.target.clipedWidth + 2;
        line.setAttribute("x", endX);
    }
}

export class StreamLight extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    getEndProps() {
        return {};
    }
    onStart() {
        this.target && ("rect" === this.target.type ? this.onStartRect() : "line" === this.target.type ? this.onStartLineOrArea("line") : "area" === this.target.type && this.onStartLineOrArea("area"));
    }
    onStartLineOrArea(type) {
        var _a;
        const root = this.target.attachShadow(), line = application.graphicService.creator[type](Object.assign({}, null === (_a = this.params) || void 0 === _a ? void 0 : _a.attribute));
        this[type] = line, line.pathProxy = new CustomPath2D, root.add(line);
    }
    onStartRect() {
        var _a;
        const root = this.target.attachShadow(), height = this.target.AABBBounds.height(), rect = application.graphicService.creator.rect(Object.assign(Object.assign({
            height: height,
            fill: "#bcdeff",
            shadowBlur: 30,
            shadowColor: "#bcdeff"
        }, null === (_a = this.params) || void 0 === _a ? void 0 : _a.attribute), {
            x: 0,
            y: 0,
            width: 0
        }));
        this.rect = rect, root.add(rect);
    }
    onBind() {}
    onEnd() {
        this.target.detachShadow();
    }
    onUpdate(end, ratio, out) {
        return this.rect ? this.onUpdateRect(end, ratio, out) : this.line || this.area ? this.onUpdateLineOrArea(end, ratio, out) : void 0;
    }
    onUpdateRect(end, ratio, out) {
        var _a, _b, _c, _d, _e, _f;
        const parentWidth = null !== (_a = this.target.attribute.width) && void 0 !== _a ? _a : 250, streamLength = null !== (_c = null === (_b = this.params) || void 0 === _b ? void 0 : _b.streamLength) && void 0 !== _c ? _c : parentWidth, maxLength = null !== (_f = null === (_e = null === (_d = this.params) || void 0 === _d ? void 0 : _d.attribute) || void 0 === _e ? void 0 : _e.width) && void 0 !== _f ? _f : 60, startX = -maxLength, currentX = startX + (streamLength - startX) * ratio, x = Math.max(currentX, 0), w = Math.min(Math.min(currentX + maxLength, maxLength), streamLength - currentX), width = w + x > parentWidth ? Math.max(parentWidth - x, 0) : w;
        this.rect.setAttributes({
            x: x,
            width: width
        }, !1, {
            type: AttributeUpdateType.ANIMATE_PLAY,
            animationState: {
                ratio: ratio,
                end: end
            }
        });
    }
    onUpdateLineOrArea(end, ratio, out) {
        const target = this.line || this.area;
        if (!target) return;
        const customPath = target.pathProxy, targetLine = this.target;
        targetLine.cache || targetLine.cacheArea ? this._onUpdateLineOrAreaWithCache(customPath, targetLine, end, ratio, out) : this._onUpdateLineWithoutCache(customPath, targetLine, end, ratio, out);
        const targetAttrs = targetLine.attribute;
        target.setAttributes(Object.assign({
            stroke: targetAttrs.stroke
        }, target.attribute)), target.addUpdateBoundTag();
    }
    _onUpdateLineOrAreaWithCache(customPath, g, end, ratio, out) {
        if (customPath.clear(), "line" === g.type) {
            let cache = g.cache;
            Array.isArray(cache) || (cache = [ cache ]);
            const totalLen = cache.reduce(((l, c) => l + c.getLength()), 0), curves = [];
            return cache.forEach((c => {
                c.curves.forEach((ci => curves.push(ci)));
            })), this._updateCurves(customPath, curves, totalLen, ratio);
        }
        if ("area" === g.type) {
            const cache = g.cacheArea, totalLen = cache.top.curves.reduce(((a, b) => a + b.getLength()), 0);
            return this._updateCurves(customPath, cache.top.curves, totalLen, ratio);
        }
    }
    _updateCurves(customPath, curves, totalLen, ratio) {
        var _a, _b;
        const startLen = totalLen * ratio, endLen = Math.min(null !== (_b = startLen + (null === (_a = this.params) || void 0 === _a ? void 0 : _a.streamLength)) && void 0 !== _b ? _b : 10, totalLen);
        let lastLen = 0, start = !1;
        for (let i = 0; i < curves.length; i++) {
            const curveItem = curves[i], len = curveItem.getLength(), startPercent = 1 - (lastLen + len - startLen) / len;
            let curveForStart, endPercent = 1 - (lastLen + len - endLen) / len;
            if (lastLen < startLen && lastLen + len > startLen) if (start = !0, curveItem.p2 && curveItem.p3) {
                const [_, curve2] = divideCubic(curveItem, startPercent);
                customPath.moveTo(curve2.p0.x, curve2.p0.y), curveForStart = curve2;
            } else {
                const p = curveItem.getPointAt(startPercent);
                customPath.moveTo(p.x, p.y);
            }
            if (lastLen < endLen && lastLen + len > endLen) {
                if (curveItem.p2 && curveItem.p3) {
                    curveForStart && (endPercent = (endLen - startLen) / curveForStart.getLength());
                    const [curve1] = divideCubic(curveForStart || curveItem, endPercent);
                    customPath.bezierCurveTo(curve1.p1.x, curve1.p1.y, curve1.p2.x, curve1.p2.y, curve1.p3.x, curve1.p3.y);
                } else {
                    const p = curveItem.getPointAt(endPercent);
                    customPath.lineTo(p.x, p.y);
                }
                break;
            }
            if (start) if (curveItem.p2 && curveItem.p3) {
                const curve = curveForStart || curveItem;
                customPath.bezierCurveTo(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y, curve.p3.x, curve.p3.y);
            } else customPath.lineTo(curveItem.p1.x, curveItem.p1.y);
            lastLen += len;
        }
    }
    _onUpdateLineWithoutCache(customPath, line, end, ratio, out) {
        var _a, _b;
        const {points: points, curveType: curveType} = line.attribute;
        if (!points || points.length < 2 || "linear" !== curveType) return;
        let totalLen = 0;
        for (let i = 1; i < points.length; i++) totalLen += PointService.distancePP(points[i], points[i - 1]);
        const startLen = totalLen * ratio, endLen = Math.min(null !== (_b = startLen + (null === (_a = this.params) || void 0 === _a ? void 0 : _a.streamLength)) && void 0 !== _b ? _b : 10, totalLen), nextPoints = [];
        let lastLen = 0;
        for (let i = 1; i < points.length; i++) {
            const len = PointService.distancePP(points[i], points[i - 1]);
            if (lastLen < startLen && lastLen + len > startLen && nextPoints.push(PointService.pointAtPP(points[i - 1], points[i], 1 - (lastLen + len - startLen) / len)), 
            lastLen < endLen && lastLen + len > endLen) {
                nextPoints.push(PointService.pointAtPP(points[i - 1], points[i], 1 - (lastLen + len - endLen) / len));
                break;
            }
            nextPoints.length && nextPoints.push(points[i]), lastLen += len;
        }
        if (nextPoints.length && !(nextPoints.length < 2)) {
            customPath.clear(), customPath.moveTo(nextPoints[0].x, nextPoints[0].y);
            for (let i = 1; i < nextPoints.length; i++) customPath.lineTo(nextPoints[i].x, nextPoints[i].y);
        }
    }
}

export class Meteor extends ACustomAnimate {
    get lastPos() {
        return this.posList[this.posList.length - 1];
    }
    constructor(size, duration, easing, params) {
        super(null, null, duration, easing, params), this.size = size, this.posList = [];
    }
    onBind() {
        const root = this.target.attachShadow();
        this.root = root;
        for (let i = 0; i < this.size; i++) {
            const g = this.target.clone(), scale = Math.min((this.size - i) / this.size * 3, 1), opacity = Math.min(.2 + .7 / this.size);
            g.setAttributes({
                x: 0,
                y: 0,
                dx: 0,
                dy: 0,
                scaleX: scale,
                scaleY: scale,
                opacity: opacity
            }, !1, {
                type: AttributeUpdateType.ANIMATE_BIND
            }), root.add(g);
        }
    }
    onUpdate(end, ratio, out) {
        if (end) return this.target.detachShadow(), void (this.posList.length = 0);
        const x = this.target.getComputedAttribute("x"), y = this.target.getComputedAttribute("y"), nextPos = new Point(x, y);
        this.posList.length ? (this.target.shadowRoot.forEachChildren(((g, i) => {
            const pos = this.posList[Math.max(this.posList.length - i - 1, 0)];
            g.setAttributes({
                x: pos.x - x,
                y: pos.y - y
            }, !1);
        })), this.posList.push(nextPos)) : this.posList.push(nextPos);
    }
}

export class MotionPath extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a;
        super(from, to, duration, easing, params), params && (this.pathLength = params.path.getLength(), 
        this.path = params.path, this.distance = params.distance, this.to = params.distance * this.pathLength, 
        this.initAngle = null !== (_a = params.initAngle) && void 0 !== _a ? _a : 0, this.changeAngle = !!params.changeAngle, 
        this.cb = params.cb);
    }
    onUpdate(end, ratio, out) {
        const at = this.to * ratio, {pos: pos, angle: angle} = this.path.getAttrAt(at);
        out.x = pos.x, out.y = pos.y, this.changeAngle && (out.angle = angle + this.initAngle), 
        this.cb && this.cb(this.from, this.to, ratio, this.target);
    }
}

export class TagPointsUpdate extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params), this.newPointAnimateType = "appear" === (null == params ? void 0 : params.newPointAnimateType) ? "appear" : "grow";
    }
    onBind() {
        var _a, _b;
        const originFromPoints = null === (_a = this.from) || void 0 === _a ? void 0 : _a.points, originToPoints = null === (_b = this.to) || void 0 === _b ? void 0 : _b.points;
        this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [ originFromPoints ] : [], 
        this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [ originToPoints ] : [];
        const tagMap = new Map;
        this.fromPoints.forEach((point => {
            point.context && tagMap.set(point.context, point);
        }));
        let firstMatchedPoint, lastMatchedPoint, firstMatchedIndex = 1 / 0, lastMatchedIndex = -1 / 0;
        for (let i = 0; i < this.toPoints.length; i += 1) if (tagMap.has(this.toPoints[i].context)) {
            firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);
            break;
        }
        for (let i = this.toPoints.length - 1; i >= 0; i -= 1) if (tagMap.has(this.toPoints[i].context)) {
            lastMatchedIndex = i, lastMatchedPoint = tagMap.get(this.toPoints[i].context);
            break;
        }
        let prevMatchedPoint = this.toPoints[0];
        this.interpolatePoints = this.toPoints.map(((point, index) => {
            const matchedPoint = tagMap.get(point.context);
            return matchedPoint ? (prevMatchedPoint = matchedPoint, [ matchedPoint, point ]) : "appear" === this.newPointAnimateType ? [ point, point ] : index < firstMatchedIndex && firstMatchedPoint ? [ firstMatchedPoint, point ] : index > lastMatchedIndex && lastMatchedPoint ? [ lastMatchedPoint, point ] : [ prevMatchedPoint, point ];
        })), this.points = this.interpolatePoints.map((interpolate => {
            const fromPoint = interpolate[0], toPoint = interpolate[1], newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
            return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
        }));
    }
    onUpdate(end, ratio, out) {
        this.points = this.points.map(((point, index) => {
            const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
            return newPoint.context = point.context, newPoint;
        })), out.points = this.points;
    }
}

export class GraphicAnimate extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params), this.graphic = null == params ? void 0 : params.graphic;
    }
    onUpdate(end, ratio, out) {
        this.graphic && Object.keys(this.from).forEach((k => {
            out[k] = this.from[k] + (this.to[k] - this.from[k]) * ratio;
        }));
    }
}

export class ClipGraphicAnimate extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(null, null, duration, easing, params), this.clipFromAttribute = from, this.clipToAttribute = to, 
        this._group = null == params ? void 0 : params.group, this._clipGraphic = null == params ? void 0 : params.clipGraphic;
    }
    onBind() {
        this._group && this._clipGraphic && (this._lastClip = this._group.attribute.clip, 
        this._lastPath = this._group.attribute.path, this._group.setAttributes({
            clip: !0,
            path: [ this._clipGraphic ]
        }, !1, {
            type: AttributeUpdateType.ANIMATE_BIND
        }));
    }
    onEnd() {
        this._group && this._group.setAttributes({
            clip: this._lastClip,
            path: this._lastPath
        }, !1, {
            type: AttributeUpdateType.ANIMATE_END
        });
    }
    onUpdate(end, ratio, out) {
        if (!this._clipGraphic) return;
        const res = {};
        Object.keys(this.clipFromAttribute).forEach((k => {
            res[k] = this.clipFromAttribute[k] + (this.clipToAttribute[k] - this.clipFromAttribute[k]) * ratio;
        })), this._clipGraphic.setAttributes(res, !1, {
            type: AttributeUpdateType.ANIMATE_UPDATE,
            animationState: {
                ratio: ratio,
                end: end
            }
        });
    }
}

export class ClipAngleAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in", startAngle = null !== (_f = null == params ? void 0 : params.startAngle) && void 0 !== _f ? _f : 0, orient = null !== (_g = null == params ? void 0 : params.orient) && void 0 !== _g ? _g : "clockwise";
        let arcStartAngle = 0, arcEndAngle = 0;
        "anticlockwise" === orient ? (arcEndAngle = "in" === animationType ? startAngle + 2 * Math.PI : startAngle, 
        arcEndAngle = startAngle + 2 * Math.PI) : (arcStartAngle = startAngle, arcEndAngle = "out" === animationType ? startAngle + 2 * Math.PI : startAngle);
        const arc = application.graphicService.creator.arc({
            x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
            y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
            outerRadius: null !== (_m = null == params ? void 0 : params.radius) && void 0 !== _m ? _m : (width + height) / 2,
            innerRadius: 0,
            startAngle: arcStartAngle,
            endAngle: arcEndAngle,
            fill: !0
        });
        let fromAttributes, toAttributes;
        "anticlockwise" === orient ? (fromAttributes = {
            startAngle: startAngle + 2 * Math.PI
        }, toAttributes = {
            startAngle: startAngle
        }) : (fromAttributes = {
            endAngle: startAngle
        }, toAttributes = {
            endAngle: startAngle + 2 * Math.PI
        }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
            group: null == params ? void 0 : params.group,
            clipGraphic: arc
        });
    }
}

export class ClipRadiusAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in", startRadius = null !== (_f = null == params ? void 0 : params.startRadius) && void 0 !== _f ? _f : 0, endRadius = null !== (_g = null == params ? void 0 : params.endRadius) && void 0 !== _g ? _g : Math.sqrt((width / 2) ** 2 + (height / 2) ** 2), arc = application.graphicService.creator.arc({
            x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
            y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
            outerRadius: "out" === animationType ? endRadius : startRadius,
            innerRadius: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            fill: !0
        }), fromAttributes = {
            outerRadius: startRadius
        }, toAttributes = {
            outerRadius: endRadius
        };
        super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
            group: null == params ? void 0 : params.group,
            clipGraphic: arc
        });
    }
}

export class ClipDirectionAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_d = null !== (_c = null == params ? void 0 : params.width) && void 0 !== _c ? _c : groupAttribute.width) && void 0 !== _d ? _d : 0, height = null !== (_f = null !== (_e = null == params ? void 0 : params.height) && void 0 !== _e ? _e : groupAttribute.height) && void 0 !== _f ? _f : 0, animationType = null !== (_g = null == params ? void 0 : params.animationType) && void 0 !== _g ? _g : "in", direction = null !== (_h = null == params ? void 0 : params.direction) && void 0 !== _h ? _h : "x", orient = null !== (_j = null == params ? void 0 : params.orient) && void 0 !== _j ? _j : "positive", rect = application.graphicService.creator.rect({
            x: 0,
            y: 0,
            width: "in" === animationType && "x" === direction ? 0 : width,
            height: "in" === animationType && "y" === direction ? 0 : height,
            fill: !0
        });
        let fromAttributes = {}, toAttributes = {};
        "y" === direction ? "negative" === orient ? (fromAttributes = {
            y: height,
            height: 0
        }, toAttributes = {
            y: 0,
            height: height
        }) : (fromAttributes = {
            height: 0
        }, toAttributes = {
            height: height
        }) : "negative" === orient ? (fromAttributes = {
            x: width,
            width: 0
        }, toAttributes = {
            x: 0,
            width: width
        }) : (fromAttributes = {
            width: 0
        }, toAttributes = {
            width: width
        }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
            group: null == params ? void 0 : params.group,
            clipGraphic: rect
        });
    }
}

export class RotateBySphereAnimate extends ACustomAnimate {
    onStart() {
        const {center: center, r: r} = "function" == typeof this.params ? this.params() : this.params, startX = this.target.getComputedAttribute("x"), startY = this.target.getComputedAttribute("y"), startZ = this.target.getComputedAttribute("z"), phi = Math.acos((startY - center.y) / r);
        let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
        startZ - center.z < 0 && (theta = pi2 - theta), this.theta = theta, this.phi = phi;
    }
    onBind() {}
    onEnd() {}
    onUpdate(end, ratio, out) {
        if (null == this.phi || null == this.theta) return;
        const {center: center, r: r, cb: cb} = "function" == typeof this.params ? this.params() : this.params, deltaAngle = 2 * Math.PI * ratio, theta = this.theta + deltaAngle, phi = this.phi, x = r * Math.sin(phi) * Math.cos(theta) + center.x, y = r * Math.cos(phi) + center.y, z = r * Math.sin(phi) * Math.sin(theta) + center.z;
        for (out.x = x, out.y = y, out.z = z, out.alpha = theta + pi / 2; out.alpha > pi2; ) out.alpha -= pi2;
        out.alpha = pi2 - out.alpha, out.zIndex = -1e4 * out.z, cb && cb(out);
    }
}

export class GroupFadeIn extends ACustomAnimate {
    getEndProps() {
        return {};
    }
    onBind() {
        this.target.setTheme({
            common: {
                opacity: 0
            }
        });
    }
    onEnd() {
        this.target.setTheme({
            common: {
                opacity: 1
            }
        });
    }
    onUpdate(end, ratio, out) {
        this.target.setTheme({
            common: {
                opacity: ratio
            }
        });
    }
}

export class GroupFadeOut extends ACustomAnimate {
    getEndProps() {
        return {};
    }
    onBind() {
        this.target.setTheme({
            common: {
                opacity: 1
            }
        });
    }
    onEnd() {
        this.target.setTheme({
            common: {
                opacity: 0
            }
        });
    }
    onUpdate(end, ratio, out) {
        this.target.setTheme({
            common: {
                opacity: 1 - ratio
            }
        });
    }
}

export class AttributeAnimate extends ACustomAnimate {
    constructor(to, duration, easing) {
        super({}, to, duration, easing);
    }
    getEndProps() {
        return this.to;
    }
    onBind() {
        Object.keys(this.to).forEach((k => {
            this.from[k] = this.target.getComputedAttribute(k);
        }));
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this.to, this.from);
    }
}

export class AnimateGroup extends ACustomAnimate {
    constructor(duration, customAnimates) {
        super(null, null, duration, "linear"), this.customAnimates = customAnimates;
    }
    initAnimates() {
        this.customAnimates.forEach((a => {
            a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;
        }));
    }
    getEndProps() {
        const props = {};
        return this.customAnimates.forEach((a => {
            Object.assign(props, a.getEndProps());
        })), props;
    }
    onBind() {
        this.initAnimates(), this.customAnimates.forEach((a => {
            a.onBind();
        }));
    }
    onEnd() {
        this.customAnimates.forEach((a => {
            a.onEnd();
        }));
    }
    onStart() {
        this.customAnimates.forEach((a => {
            a.onStart();
        }));
    }
    onUpdate(end, ratio, out) {
        this.updating || (this.updating = !0, this.customAnimates.forEach((a => {
            const easing = a.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing;
            ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
        })), this.updating = !1);
    }
}

export class AnimateGroup1 extends ACustomAnimate {
    constructor(duration, customAnimates) {
        super(null, null, duration, "linear"), this.customAnimates = customAnimates;
    }
    initAnimates() {
        this.customAnimates.forEach((a => {
            a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;
        }));
    }
    getEndProps() {
        const props = {};
        return this.customAnimates.forEach((a => {
            Object.assign(props, a.getEndProps());
        })), props;
    }
    onBind() {
        this.initAnimates(), this.customAnimates.forEach((a => {
            a.onBind();
        }));
    }
    onEnd() {
        this.customAnimates.forEach((a => {
            a.onEnd();
        }));
    }
    onUpdate(end, ratio, out) {
        this.updating || (this.updating = !0, this.customAnimates.forEach((a => {
            const easing = a.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing;
            ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
        })), this.updating = !1);
    }
}
//# sourceMappingURL=custom-animate.js.map