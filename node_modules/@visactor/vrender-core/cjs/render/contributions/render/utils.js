"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawArcPath = exports.cornerTangents = exports.intersect = exports.drawPathProxy = exports.rectStrokeVisible = exports.strokeVisible = exports.rectFillVisible = exports.fillVisible = exports.runStroke = exports.runFill = void 0;

const vutils_1 = require("@visactor/vutils"), render_command_list_1 = require("../../../common/render-command-list"), theme_1 = require("../../../graphic/theme");

function runFill(fill, background) {
    return !(!fill && !background);
}

function runStroke(stroke, lineWidth) {
    let s;
    return s = (0, vutils_1.isArray)(stroke) ? stroke.some((item => item || void 0 === item)) : !!stroke, 
    s && lineWidth > 0;
}

function fillVisible(opacity, fillOpacity, fill) {
    return fill && opacity * fillOpacity > 0;
}

function rectFillVisible(opacity, fillOpacity, width, height, fill) {
    return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}

function strokeVisible(opacity, strokeOpacity) {
    return opacity * strokeOpacity > 0;
}

function rectStrokeVisible(opacity, strokeOpacity, width, height) {
    return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}

function drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (!graphic.pathProxy) return !1;
    const themeAttributes = (0, theme_1.getTheme)(graphic, null == params ? void 0 : params.theme)[graphic.type], {fill: fill = themeAttributes.fill, stroke: stroke = themeAttributes.stroke, opacity: opacity = themeAttributes.opacity, fillOpacity: fillOpacity = themeAttributes.fillOpacity, lineWidth: lineWidth = themeAttributes.lineWidth, strokeOpacity: strokeOpacity = themeAttributes.strokeOpacity, visible: visible = themeAttributes.visible} = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke, lineWidth);
    if (!visible) return !0;
    if (!doFill && !doStroke) return !0;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
    context.beginPath();
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return (0, render_command_list_1.renderCommandList)(path.commandList, context, x, y), 
    context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), 
    doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x, y, themeAttributes), 
    context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x, y, themeAttributes), 
    context.fill())), !0;
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    const x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2;
    let t = y32 * x10 - x32 * y10;
    return t * t < vutils_1.epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, 
    [ x0 + t * x10, y0 + t * y10 ]);
}

function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
    const x01 = x0 - x1, y01 = y0 - y1, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
    let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;
    const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), 
    {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
    };
}

function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, 
    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= vutils_1.epsilon) context.moveTo(cx, cy); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + outerRadius * (0, 
    vutils_1.cos)(startAngle), cy + outerRadius * (0, vutils_1.sin)(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), 
    innerRadius > vutils_1.epsilon && (context.moveTo(cx + innerRadius * (0, vutils_1.cos)(endAngle), cy + innerRadius * (0, 
    vutils_1.sin)(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise)); else {
        const cornerRadius = arc.getParsedCornerRadius(), {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
        let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
        const xors = outerRadius * (0, vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, 
        vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, 
        vutils_1.sin)(innerEndAngle);
        let xore, yore, xirs, yirs;
        if ((maxInnerCornerRadius > vutils_1.epsilon || maxOuterCornerRadius > vutils_1.epsilon) && (xore = outerRadius * (0, 
        vutils_1.cos)(outerEndAngle), yore = outerRadius * (0, vutils_1.sin)(outerEndAngle), 
        xirs = innerRadius * (0, vutils_1.cos)(innerStartAngle), yirs = innerRadius * (0, 
        vutils_1.sin)(innerStartAngle), deltaAngle < vutils_1.pi)) {
            const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
            if (oc) {
                const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / (0, 
                vutils_1.sin)((0, vutils_1.acos)((ax * bx + ay * by) / ((0, vutils_1.sqrt)(ax * ax + ay * ay) * (0, 
                vutils_1.sqrt)(bx * bx + by * by))) / 2), lc = (0, vutils_1.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
                limitedIcr = (0, vutils_1.min)(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), 
                limitedOcr = (0, vutils_1.min)(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
            }
        }
        if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), 
        collapsedToLine = !0; else if (limitedOcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = (0, 
            vutils_1.min)(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
            limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, (0, vutils_1.atan2)(t0.y01, t0.x01), (0, 
            vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, (0, 
            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, outerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, 
            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, (0, 
            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * (0, 
            vutils_1.sin)(outerEndAngle));
        } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * (0, 
        vutils_1.cos)(outerEndAngle), cy + outerRadius * (0, vutils_1.sin)(outerEndAngle));
        if (!(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        collapsedToLine = !0; else if (limitedIcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = (0, 
            vutils_1.min)(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
            if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                const arcEndAngle = (0, vutils_1.atan2)(t1.y01, t1.x01);
                !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, (0, 
                vutils_1.atan2)(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + (0, 
                vutils_1.cos)(arcEndAngle), cy + t0.cy + (0, vutils_1.sin)(arcEndAngle));
            } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, (0, 
            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, innerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, 
            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, (0, 
            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
        } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * (0, 
        vutils_1.cos)(innerStartAngle), cy + innerRadius * (0, vutils_1.sin)(innerStartAngle));
    }
    return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * (0, vutils_1.cos)(startAngle), cy + outerRadius * (0, 
    vutils_1.sin)(startAngle)) : context.closePath(), collapsedToLine;
}

exports.runFill = runFill, exports.runStroke = runStroke, exports.fillVisible = fillVisible, 
exports.rectFillVisible = rectFillVisible, exports.strokeVisible = strokeVisible, 
exports.rectStrokeVisible = rectStrokeVisible, exports.drawPathProxy = drawPathProxy, 
exports.intersect = intersect, exports.cornerTangents = cornerTangents, exports.drawArcPath = drawArcPath;
//# sourceMappingURL=utils.js.map
