"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultIncrementalDrawContribution = void 0;

const inversify_lite_1 = require("../../../common/inversify-lite"), graphic_1 = require("../../../graphic"), draw_contribution_1 = require("./draw-contribution"), tapable_1 = require("../../../tapable"), symbol_1 = require("./symbol"), incremental_line_render_1 = require("./incremental-line-render"), incremental_area_render_1 = require("./incremental-area-render"), draw_interceptor_1 = require("./draw-interceptor"), contribution_provider_1 = require("../../../common/contribution-provider"), sort_1 = require("../../../common/sort");

var STATUS;

!function(STATUS) {
    STATUS[STATUS.NORMAL = 0] = "NORMAL", STATUS[STATUS.STOP = 1] = "STOP";
}(STATUS || (STATUS = {}));

let DefaultIncrementalDrawContribution = class extends draw_contribution_1.DefaultDrawContribution {
    constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
        super(contributions, drawItemInterceptorContributions), this.contributions = contributions, 
        this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, 
        this.rendering = !1, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS.NORMAL, 
        this.checkingForDrawPromise = null, this.hooks = {
            completeDraw: new tapable_1.SyncHook([])
        }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
    }
    draw(renderService, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (this.checkingForDrawPromise) return;
            this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
            const skipDraw = yield this.checkingForDrawPromise;
            if (this.checkingForDrawPromise = null, skipDraw) return;
            this.currentRenderService = renderService;
            const {context: context, x: x = 0, y: y = 0} = drawContext;
            context && (context.inuse = !0, context.clearMatrix(), context.setTransformForCurrent(!0), 
            context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), 
            context.translate(x, y, !0), context.save(), renderService.renderTreeRoots.sort(((a, b) => {
                var _a, _b;
                return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : graphic_1.DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : graphic_1.DefaultAttribute.zIndex);
            })).forEach((group => {
                this.renderGroup(group, drawContext);
            })), this.hooks.completeDraw.tap("top-draw", (() => {
                context.restore(), context.restore(), context.draw(), context.inuse = !1, this.rendering = !1;
            })));
        }));
    }
    _increaseRender(group, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            this.rendering = !0, yield this._renderIncrementalGroup(group, drawContext);
        }));
    }
    _renderIncrementalGroup(group, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            this.count = group.count, yield new Promise((resolve => {
                this.renderItem(group, drawContext, {
                    drawingCb: () => __awaiter(this, void 0, void 0, (function*() {
                        if (2 !== group.count) yield (0, sort_1.foreachAsync)(group, graphic_1.DefaultAttribute.zIndex, ((item, i) => {
                            if (this.status === STATUS.STOP) return !0;
                            if (item.isContainer) return !1;
                            if (i < this.currentIdx) return !1;
                            const frameTail = this.currFrameStartAt + group.incremental;
                            return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), 
                            i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
                        })), resolve(!1); else {
                            const graphic = group.getChildAt(0);
                            if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length; ) drawContext.multiGraphicOptions = {
                                startAtIdx: graphic.incrementalAt,
                                length: graphic.incremental
                            }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, 
                            yield this.waitToNextFrame(); else this.renderItem(graphic, drawContext);
                            resolve(!1);
                        }
                    }))
                });
            })), this.hooks.completeDraw.call();
        }));
    }
    waitToNextFrame() {
        return __awaiter(this, void 0, void 0, (function*() {
            return new Promise((resolve => {
                this.global.getRequestAnimationFrame()((() => {
                    resolve(!1);
                }));
            }));
        }));
    }
    checkForDraw(drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            let skip = this.rendering;
            return drawContext.restartIncremental && (skip = !1, yield this.forceStop(), this.resetToInit()), 
            skip;
        }));
    }
    forceStop() {
        return __awaiter(this, void 0, void 0, (function*() {
            this.rendering && (this.status = STATUS.STOP, yield new Promise((resolve => {
                this.hooks.completeDraw.tap("stopCb", (() => {
                    this.status = STATUS.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter((item => "stopCb" !== item.name)), 
                    resolve(!1);
                }));
            })));
        }));
    }
    resetToInit() {
        this.currFrameStartAt = 0, this.currentIdx = 0;
    }
    renderGroup(group, drawContext) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (!drawContext.break && !1 !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), 
            void (drawContext.break = !0)) : void (yield new Promise((resolve => {
                this.renderItem(group, drawContext, {
                    drawingCb: () => __awaiter(this, void 0, void 0, (function*() {
                        yield (0, sort_1.foreachAsync)(group, graphic_1.DefaultAttribute.zIndex, (item => __awaiter(this, void 0, void 0, (function*() {
                            drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
                        })))), resolve(!1);
                    }))
                });
            })));
        }));
    }
};

DefaultIncrementalDrawContribution = __decorate([ (0, inversify_lite_1.injectable)(), __param(0, (0, 
inversify_lite_1.multiInject)(symbol_1.GraphicRender)), __param(1, (0, inversify_lite_1.inject)(incremental_line_render_1.DefaultIncrementalCanvasLineRender)), __param(2, (0, 
inversify_lite_1.inject)(incremental_area_render_1.DefaultIncrementalCanvasAreaRender)), __param(3, (0, 
inversify_lite_1.inject)(contribution_provider_1.ContributionProvider)), __param(3, (0, 
inversify_lite_1.named)(draw_interceptor_1.DrawItemInterceptor)), __metadata("design:paramtypes", [ Array, Object, Object, Object ]) ], DefaultIncrementalDrawContribution), 
exports.DefaultIncrementalDrawContribution = DefaultIncrementalDrawContribution;
//# sourceMappingURL=incremental-draw-contribution.js.map
