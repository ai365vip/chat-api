{"version":3,"sources":["../src/common/polygon.ts"],"names":[],"mappings":"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","file":"polygon.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\nimport type { IPath2D } from '../interface';\n\n/**\n * 绘制闭合的常规多边形\n * TODO polygon 图元的xy属性没有意义\n * @param path\n * @param points\n * @param x\n * @param y\n */\nexport function drawPolygon(path: IPath2D, points: IPointLike[], x: number, y: number) {\n  path.moveTo(points[0].x + x, points[0].y + y);\n  for (let i = 1; i < points.length; i++) {\n    path.lineTo(points[i].x + x, points[i].y + y);\n  }\n}\n\n/**\n * algorithm detail see: https://stackoverflow.com/a/24780108\n */\nexport function drawRoundedPolygon(\n  path: IPath2D,\n  points: IPointLike[],\n  x: number,\n  y: number,\n  cornerRadius: number | number[],\n  closePath: boolean = true\n) {\n  if (points.length < 3) {\n    drawPolygon(path, points, x, y);\n    return;\n  }\n\n  let startI = 0;\n  let endI = points.length - 1;\n  if (!closePath) {\n    startI += 1;\n    endI -= 1;\n    path.moveTo(points[0].x + x, points[0].y + y);\n  }\n  for (let i = startI; i <= endI; i++) {\n    const p1 = points[i === 0 ? endI : (i - 1) % points.length];\n    const angularPoint = points[i % points.length];\n    const p2 = points[(i + 1) % points.length];\n\n    //Vector 1\n    const dx1 = angularPoint.x - p1.x;\n    const dy1 = angularPoint.y - p1.y;\n\n    //Vector 2\n    const dx2 = angularPoint.x - p2.x;\n    const dy2 = angularPoint.y - p2.y;\n\n    //Angle between vector 1 and vector 2 divided by 2\n    const angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2;\n\n    // The length of segment between angular point and the\n    // points of intersection with the circle of a given radius\n    const tan = Math.abs(Math.tan(angle));\n\n    // get config radius\n    let radius = Array.isArray(cornerRadius) ? cornerRadius[i % points.length] ?? 0 : cornerRadius;\n    let segment = radius / tan;\n\n    //Check the segment\n    const length1 = getLength(dx1, dy1);\n    const length2 = getLength(dx2, dy2);\n\n    const length = Math.min(length1, length2);\n\n    if (segment > length) {\n      segment = length;\n      radius = length * tan;\n    }\n\n    // Points of intersection are calculated by the proportion between\n    // the coordinates of the vector, length of vector and the length of the segment.\n    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1);\n    const p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2);\n\n    // Calculation of the coordinates of the circle\n    // center by the addition of angular vectors.\n    const dx = angularPoint.x * 2 - p1Cross.x - p2Cross.x;\n    const dy = angularPoint.y * 2 - p1Cross.y - p2Cross.y;\n\n    const L = getLength(dx, dy);\n    const d = getLength(segment, radius);\n\n    const circlePoint = getProportionPoint(angularPoint, d, L, dx, dy);\n\n    //StartAngle and EndAngle of arc\n    let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);\n    const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);\n\n    //Sweep angle\n    let sweepAngle = endAngle - startAngle;\n\n    //Some additional checks\n    if (sweepAngle < 0) {\n      startAngle = endAngle;\n      sweepAngle = -sweepAngle;\n    }\n\n    if (sweepAngle > Math.PI) {\n      sweepAngle = sweepAngle - Math.PI;\n    }\n\n    if (i === 0) {\n      path.moveTo(p1Cross.x + x, p1Cross.y + y);\n    } else {\n      path.lineTo(p1Cross.x + x, p1Cross.y + y);\n    }\n\n    if (sweepAngle) {\n      path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius);\n    }\n\n    path.lineTo(p2Cross.x + x, p2Cross.y + y);\n  }\n\n  if (!closePath) {\n    path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);\n  }\n}\n\nfunction getLength(dx: number, dy: number) {\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction getProportionPoint(point: IPointLike, segment: number, length: number, dx: number, dy: number) {\n  const factor = segment / length;\n\n  return {\n    x: point.x - dx * factor,\n    y: point.y - dy * factor\n  };\n}\n"]}