import { FactoryType } from '../utils/factory_type';
export declare namespace interfaces {
    type DynamicValue<T> = (context: interfaces.Context) => T;
    type ContainerResolution<T> = T | Promise<T> | (T | Promise<T>)[];
    type BindingScope = 'Singleton' | 'Transient' | 'Request';
    type BindingType = 'ConstantValue' | 'Constructor' | 'DynamicValue' | 'Factory' | 'Function' | 'Instance' | 'Invalid' | 'Provider';
    type TargetType = 'ConstructorArgument' | 'ClassProperty' | 'Variable';
    interface BindingScopeEnum {
        Singleton: interfaces.BindingScope;
        Transient: interfaces.BindingScope;
    }
    interface BindingTypeEnum {
        ConstantValue: interfaces.BindingType;
        Constructor: interfaces.BindingType;
        DynamicValue: interfaces.BindingType;
        Factory: interfaces.BindingType;
        Function: interfaces.BindingType;
        Instance: interfaces.BindingType;
        Invalid: interfaces.BindingType;
        Provider: interfaces.BindingType;
    }
    interface TargetTypeEnum {
        ConstructorArgument: interfaces.TargetType;
        ClassProperty: interfaces.TargetType;
        Variable: interfaces.TargetType;
    }
    type Newable<T> = new (...args: any[]) => T;
    type Instance<T> = T & Record<string, () => void>;
    interface Abstract<T> {
        prototype: T;
    }
    type ServiceIdentifier<T = unknown> = string | symbol | Newable<T> | Abstract<T>;
    interface Clonable<T> {
        clone(): T;
    }
    type BindingActivation<T = unknown> = (context: interfaces.Context, injectable: T) => T | Promise<T>;
    type BindingDeactivation<T = unknown> = (injectable: T) => void | Promise<void>;
    interface Binding<TActivated = unknown> extends Clonable<Binding<TActivated>> {
        id: number;
        moduleId: ContainerModuleBase['id'];
        activated: boolean;
        serviceIdentifier: ServiceIdentifier<TActivated>;
        constraint: ConstraintFunction;
        dynamicValue: DynamicValue<TActivated> | null;
        scope: BindingScope;
        type: BindingType;
        implementationType: Newable<TActivated> | TActivated | null;
        factory: FactoryCreator<unknown> | null;
        provider: ProviderCreator<unknown> | null;
        cache: null | TActivated | Promise<TActivated>;
    }
    type SimpleFactory<T, U extends unknown[] = unknown[]> = (...args: U) => T;
    type MultiFactory<T, U extends unknown[] = unknown[], V extends unknown[] = unknown[]> = (...args: U) => SimpleFactory<T, V>;
    type Factory<T, U extends unknown[] = unknown[], V extends unknown[] = unknown[]> = SimpleFactory<T, U> | MultiFactory<T, U, V>;
    type FactoryCreator<T, U extends unknown[] = unknown[], V extends unknown[] = unknown[]> = (context: Context) => Factory<T, U, V>;
    type AutoNamedFactory<T> = SimpleFactory<T, [string]>;
    type AutoFactory<T> = SimpleFactory<T, []>;
    type FactoryTypeFunction<T = unknown> = (context: interfaces.Context) => T | Promise<T>;
    interface FactoryDetails {
        factoryType: FactoryType;
        factory: FactoryTypeFunction | null;
    }
    type Provider<T> = (...args: any[]) => ((...args: any[]) => Promise<T>) | Promise<T>;
    type ProviderCreator<T> = (context: Context) => Provider<T>;
    interface NextArgs<T = unknown> {
        avoidConstraints: boolean;
        contextInterceptor: (contexts: Context) => Context;
        isMultiInject: boolean;
        targetType: TargetType;
        serviceIdentifier: interfaces.ServiceIdentifier<T>;
        key?: string | number | symbol | undefined;
        value?: unknown;
    }
    type Next = (args: NextArgs) => unknown | unknown[];
    type Middleware = (next: Next) => Next;
    type ContextInterceptor = (context: interfaces.Context) => interfaces.Context;
    interface Context {
        id: number;
        container: Container;
        plan: Plan;
        currentRequest: Request;
        addPlan(plan: Plan): void;
        setCurrentRequest(request: Request): void;
    }
    type MetadataOrMetadataArray = Metadata | Metadata[];
    interface Metadata<TValue = unknown> {
        key: string | number | symbol;
        value: TValue;
    }
    interface Plan {
        parentContext: Context;
        rootRequest: Request;
    }
    interface QueryableString {
        contains(searchString: string): boolean;
        equals(compareString: string): boolean;
        value(): string;
    }
    type ResolveRequestHandler = (request: interfaces.Request) => unknown;
    type RequestScope = Map<unknown, unknown>;
    interface Request {
        id: number;
        serviceIdentifier: ServiceIdentifier;
        parentContext: Context;
        parentRequest: Request | null;
        childRequests: Request[];
        target: Target;
        bindings: Binding<unknown>[];
        requestScope: RequestScope | null;
        addChildRequest(serviceIdentifier: ServiceIdentifier, bindings: Binding<unknown> | Binding<unknown>[], target: Target): Request;
    }
    interface Target {
        id: number;
        serviceIdentifier: ServiceIdentifier;
        type: TargetType;
        name: QueryableString;
        identifier: string | symbol;
        metadata: Metadata[];
        getNamedTag(): interfaces.Metadata<string> | null;
        getCustomTags(): interfaces.Metadata[] | null;
        hasTag(key: string | number | symbol): boolean;
        isArray(): boolean;
        matchesArray(name: interfaces.ServiceIdentifier): boolean;
        isNamed(): boolean;
        isTagged(): boolean;
        isOptional(): boolean;
        matchesNamedTag(name: string): boolean;
        matchesTag(key: string | number | symbol): (value: unknown) => boolean;
    }
    interface ContainerOptions {
        autoBindInjectable?: boolean;
        defaultScope?: BindingScope | undefined;
        skipBaseClassChecks?: boolean;
    }
    interface Container {
        id: number;
        parent: Container | null;
        options: ContainerOptions;
        bind<T>(serviceIdentifier: ServiceIdentifier<T>): BindingToSyntax<T>;
        rebind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>;
        unbind(serviceIdentifier: ServiceIdentifier): void;
        unbindAll(): void;
        isBound(serviceIdentifier: ServiceIdentifier): boolean;
        isCurrentBound<T>(serviceIdentifier: ServiceIdentifier<T>): boolean;
        isBoundNamed(serviceIdentifier: ServiceIdentifier, named: string | number | symbol): boolean;
        isBoundTagged(serviceIdentifier: ServiceIdentifier, key: string | number | symbol, value: unknown): boolean;
        get<T>(serviceIdentifier: ServiceIdentifier<T>): T;
        getNamed<T>(serviceIdentifier: ServiceIdentifier<T>, named: string | number | symbol): T;
        getTagged<T>(serviceIdentifier: ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T;
        getAll<T>(serviceIdentifier: ServiceIdentifier<T>): T[];
        getAllTagged<T>(serviceIdentifier: ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T[];
        getAllNamed<T>(serviceIdentifier: ServiceIdentifier<T>, named: string | number | symbol): T[];
        getAsync<T>(serviceIdentifier: ServiceIdentifier<T>): Promise<T>;
        resolve<T>(constructorFunction: interfaces.Newable<T>): T;
        load(...modules: ContainerModule[]): void;
        unload(...modules: ContainerModuleBase[]): void;
        applyCustomMetadataReader(metadataReader: MetadataReader): void;
    }
    type Bind = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => BindingToSyntax<T>;
    type Rebind = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => BindingToSyntax<T>;
    type Unbind = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => void;
    type UnbindAsync = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => Promise<void>;
    type IsBound = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => boolean;
    interface ContainerModuleBase {
        id: number;
    }
    interface ContainerModule extends ContainerModuleBase {
        registry: ContainerModuleCallBack;
    }
    interface ModuleActivationHandlers {
        onActivations: Lookup<BindingActivation<unknown>>;
        onDeactivations: Lookup<BindingDeactivation<unknown>>;
    }
    type ContainerModuleCallBack = (bind: interfaces.Bind, unbind: interfaces.Unbind, isBound: interfaces.IsBound, rebind: interfaces.Rebind) => void;
    interface Lookup<T> extends Clonable<Lookup<T>> {
        add(serviceIdentifier: ServiceIdentifier, value: T): void;
        getMap(): Map<interfaces.ServiceIdentifier, T[]>;
        get(serviceIdentifier: ServiceIdentifier): T[];
        remove(serviceIdentifier: interfaces.ServiceIdentifier): void;
        removeByCondition(condition: (item: T) => boolean): T[];
        removeIntersection(lookup: interfaces.Lookup<T>): void;
        hasKey(serviceIdentifier: ServiceIdentifier): boolean;
        clone(): Lookup<T>;
        traverse(func: (key: interfaces.ServiceIdentifier, value: T[]) => void): void;
    }
    interface BindingOnSyntax<T> {
    }
    interface BindingInSyntax<T> {
        inSingletonScope(): BindingInSyntax<T>;
        inTransientScope(): BindingInSyntax<T>;
        whenTargetNamed(name: string | number | symbol): BindingOnSyntax<T>;
    }
    interface BindingInWhenOnSyntax<T> extends BindingInSyntax<T>, BindingInSyntax<T> {
    }
    interface BindingToSyntax<T> {
        to(constructor: Newable<T>): BindingInWhenOnSyntax<T>;
        toSelf(): BindingInWhenOnSyntax<T>;
        toConstantValue(value: T): BindingInWhenOnSyntax<T>;
        toDynamicValue(func: DynamicValue<T>): BindingInWhenOnSyntax<T>;
        toFactory<T2, T3 extends unknown[] = unknown[], T4 extends unknown[] = unknown[]>(factory: FactoryCreator<T2, T3, T4>): BindingInWhenOnSyntax<T>;
        toService(service: ServiceIdentifier<T>): void;
    }
    interface ConstraintFunction {
        metaData?: Metadata;
        (request: Request | null): boolean;
    }
    interface MetadataReader {
        getConstructorMetadata(constructorFunc: NewableFunction): ConstructorMetadata;
        getPropertiesMetadata(constructorFunc: NewableFunction): MetadataMap;
    }
    interface MetadataMap {
        [propertyNameOrArgumentIndex: string | symbol]: Metadata[];
    }
    interface ConstructorMetadata {
        compilerGeneratedMetadata: NewableFunction[] | undefined;
        userGeneratedMetadata: MetadataMap;
    }
}
