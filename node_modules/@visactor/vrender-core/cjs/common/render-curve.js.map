{"version":3,"sources":["../src/common/render-curve.ts"],"names":[],"mappings":"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","file":"render-curve.js","sourcesContent":["import type { IPoint, IPointLike } from '@visactor/vutils';\nimport { min } from '@visactor/vutils';\nimport type {\n  IAreaSegment,\n  IClipRangeByDimensionType,\n  ICurve,\n  IDirection,\n  IPath2D,\n  ISegment,\n  ISegPath2D\n} from '../interface';\nimport { Direction } from './enums';\nimport { drawSegItem } from './render-utils';\n\n/**\n * 绘制连续的线段\n * 绘制长度为总长度percent的path，drawDirection为绘制的方向，也就是percent的方向\n * @param path\n * @param segPath\n * @param percent\n * @param drawDirection 绘制的方向，用于使用percent绘制\n * @param line 用于获取line相关属性\n */\nexport function drawSegments(\n  path: IPath2D,\n  segPath: ISegPath2D,\n  percent: number,\n  clipRangeByDimension: IClipRangeByDimensionType,\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n    offsetZ?: number;\n    drawConnect?: boolean; // 是否是绘制connect区域的效果\n    mode?: 'none' | 'connect' | 'zero';\n    zeroX?: number;\n    zeroY?: number;\n  }\n) {\n  const {\n    offsetX = 0,\n    offsetY = 0,\n    offsetZ = 0,\n    mode = 'none',\n    drawConnect = false,\n    zeroX = 0,\n    zeroY = 0\n  } = params || {};\n  // none的connect不需要draw\n  if (drawConnect && mode === 'none') {\n    return;\n  }\n  if (!segPath) {\n    return;\n  }\n  let needMoveTo: boolean = true;\n  const { curves } = segPath;\n  if (percent >= 1) {\n    if (drawConnect) {\n      // return;\n      let defined0 = true;\n      let lastCurve: ICurve<IPoint>;\n      curves.forEach((curve, i) => {\n        // step的逻辑\n        let p0 = curve.p0;\n        if (curve.originP1 === curve.originP2) {\n          lastCurve = curve;\n          return;\n        }\n        if (lastCurve && lastCurve.originP1 === lastCurve.originP2) {\n          p0 = lastCurve.p0;\n        }\n        if (curve.defined) {\n          // 非法变合法需要lineTo，合法变非法需要moveTo，初始非法需要moveTo\n          if (!defined0) {\n            path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ);\n            defined0 = !defined0;\n          }\n        } else {\n          // 找到合法的点\n          const { originP1, originP2 } = curve;\n          let validP: IPointLike;\n          if (originP1 && originP1.defined !== false) {\n            validP = p0;\n          } else if (originP1 && originP2.defined !== false) {\n            validP = curve.p3 ?? curve.p1;\n          }\n          // 合法/（初始）变非法，moveTo\n          if (defined0) {\n            defined0 = !defined0;\n            const x = validP ? validP.x : curve.p0.x;\n            const y = validP ? validP.y : curve.p0.y;\n            path.moveTo(x + offsetX, y + offsetY, offsetZ);\n          } else {\n            // 非法变非法/合法，看情况要不要lineTo\n            if (validP) {\n              // 非法变合法，需要lineTo\n              defined0 = !defined0;\n              path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ);\n            }\n          }\n        }\n\n        lastCurve = curve;\n      });\n    } else {\n      curves.forEach(curve => {\n        // 跳过这个点\n        if (!curve.defined) {\n          needMoveTo = true;\n          return;\n        }\n        if (needMoveTo) {\n          path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);\n        }\n        drawSegItem(path, curve, 1, params);\n        needMoveTo = false;\n      });\n    }\n\n    return;\n  }\n  if (percent <= 0) {\n    return;\n  }\n\n  let direction: IDirection | undefined;\n\n  if (clipRangeByDimension === 'x') {\n    direction = Direction.ROW;\n  } else if (clipRangeByDimension === 'y') {\n    direction = Direction.COLUMN;\n  } else if (clipRangeByDimension === 'auto') {\n    direction = segPath.direction;\n  }\n\n  // 整个线段的总长度\n  const totalLength = segPath.tryUpdateLength(direction);\n  // 总需要绘制的长度\n  const totalDrawLength = percent * totalLength;\n  // 直到上次绘制的长度\n  let drawedLengthUntilLast = 0;\n  let defined0 = true;\n  let lastCurve: ICurve<IPoint> = null;\n  for (let i = 0, n = curves.length; i < n; i++) {\n    const curve = curves[i];\n    const curCurveLength = curve.getLength(direction);\n    const _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;\n    drawedLengthUntilLast += curCurveLength;\n    if (_p < 0) {\n      break;\n    }\n\n    if (drawConnect) {\n      // step的逻辑\n      let p0 = curve.p0;\n      if (curve.originP1 === curve.originP2) {\n        lastCurve = curve;\n        continue;\n      }\n      if (lastCurve && lastCurve.originP1 === lastCurve.originP2) {\n        p0 = lastCurve.p0;\n      }\n      if (curve.defined) {\n        // 非法变合法需要lineTo，合法变非法需要moveTo，初始非法需要moveTo\n        if (!defined0) {\n          path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ);\n          defined0 = !defined0;\n        }\n      } else {\n        // 找到合法的点\n        const { originP1, originP2 } = curve;\n        let validP: IPointLike;\n        if (originP1 && originP1.defined !== false) {\n          validP = p0;\n        } else if (originP1 && originP2.defined !== false) {\n          validP = curve.p3 ?? curve.p1;\n        }\n        // 合法/（初始）变非法，moveTo\n        if (defined0) {\n          defined0 = !defined0;\n          const x = validP ? validP.x : curve.p0.x;\n          const y = validP ? validP.y : curve.p0.y;\n          path.moveTo(x + offsetX, y + offsetY, offsetZ);\n        } else {\n          // 非法变非法/合法，看情况要不要lineTo\n          if (validP) {\n            // 非法变合法，需要lineTo\n            defined0 = !defined0;\n            path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ);\n          }\n        }\n      }\n\n      lastCurve = curve;\n    } else {\n      // 跳过这个点\n      if (!curve.defined) {\n        needMoveTo = true;\n        continue;\n      }\n      if (needMoveTo) {\n        path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);\n      }\n      drawSegItem(path, curve, min(_p, 1), params);\n      needMoveTo = false;\n    }\n  }\n}\n\nexport function drawIncrementalSegments(\n  path: IPath2D,\n  lastSeg: ISegment,\n  segments: ISegment,\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n  }\n) {\n  const { offsetX = 0, offsetY = 0 } = params || {};\n  const startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];\n  path.moveTo(startP.x + offsetX, startP.y + offsetY);\n  segments.points.forEach(p => {\n    if (p.defined === false) {\n      path.moveTo(p.x + offsetX, p.y + offsetY);\n      return;\n    }\n    path.lineTo(p.x + offsetX, p.y + offsetY);\n  });\n}\n\nexport function drawIncrementalAreaSegments(\n  path: IPath2D,\n  lastSeg: IAreaSegment,\n  segments: IAreaSegment,\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n  }\n) {\n  const { offsetX = 0, offsetY = 0 } = params || {};\n  const { points } = segments;\n  // 分段\n  const definedPointsList: IPointLike[][] = [];\n  let lastIdx = 0;\n  for (let i = 0; i < points.length; i++) {\n    if (points[i].defined === false) {\n      if (lastIdx + 1 !== i) {\n        definedPointsList.slice(lastIdx, i);\n      }\n      lastIdx = i;\n    }\n  }\n  definedPointsList.length === 0;\n  definedPointsList.push(points);\n  definedPointsList.forEach((points, i) => {\n    const startP = lastSeg && i === 0 ? lastSeg.points[lastSeg.points.length - 1] : points[0];\n    path.moveTo(startP.x + offsetX, startP.y + offsetY);\n    // 绘制上层\n    points.forEach(p => {\n      if (p.defined === false) {\n        path.moveTo(p.x + offsetX, p.y + offsetY);\n        return;\n      }\n      path.lineTo(p.x + offsetX, p.y + offsetY);\n    });\n    // 绘制下层\n    for (let i = points.length - 1; i >= 0; i--) {\n      const p = points[i];\n      path.lineTo(p.x1 ?? p.x, p.y1 ?? p.y);\n    }\n    path.lineTo(startP.x1 ?? startP.x, startP.y1 ?? startP.y);\n    path.closePath();\n  });\n}\n"]}