"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.colorStringInterpolationToStr = exports.interpolatePureColorArray = exports.interpolateGradientConicalColor = exports.interpolateGradientRadialColor = exports.interpolateGradientLinearColor = exports.interpolateColor = void 0;

const store_1 = require("./store");

function colorArrayToString(color, alphaChannel = !1) {
    return Array.isArray(color) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}

function interpolateColor(from, to, ratio, alphaChannel, cb) {
    if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
    let fromArray, toArray, fromGradient = !1, toGradient = !1;
    if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = store_1.ColorStore.Get(from, store_1.ColorType.Color255) : fromGradient = !0, 
    Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = store_1.ColorStore.Get(to, store_1.ColorType.Color255) : toGradient = !0, 
    fromGradient !== toGradient) {
        const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {
            stops: gradient.stops.map((v => Object.assign(Object.assign({}, v), {
                color: colorArrayToString(pure)
            })))
        });
        return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
    }
    if (fromGradient) {
        if (from.gradient === to.gradient) {
            const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;
            if (fromStops.length !== toStops.length) return !1;
            if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
            if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
            if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
        }
        return !1;
    }
    cb && cb(fromArray, toArray);
    return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}

function interpolateGradientLinearColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "linear",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

function interpolateGradientRadialColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "radial",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
        r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

function interpolateGradientConicalColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "conical",
        startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
        endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
        x: fc.x + (tc.x - fc.x) * ratio,
        y: fc.y + (tc.y - fc.y) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

function interpolatePureColorArray(from, to, ratio) {
    return [ from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio ];
}

exports.interpolateColor = interpolateColor, exports.interpolateGradientLinearColor = interpolateGradientLinearColor, 
exports.interpolateGradientRadialColor = interpolateGradientRadialColor, exports.interpolateGradientConicalColor = interpolateGradientConicalColor, 
exports.interpolatePureColorArray = interpolatePureColorArray;

const _fromColorRGB = [ 0, 0, 0, 0 ], _toColorRGB = [ 0, 0, 0, 0 ];

function colorStringInterpolationToStr(fromColor, toColor, ratio) {
    return store_1.ColorStore.Get(fromColor, store_1.ColorType.Color255, _fromColorRGB), 
    store_1.ColorStore.Get(toColor, store_1.ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

exports.colorStringInterpolationToStr = colorStringInterpolationToStr;
//# sourceMappingURL=interpolate.js.map