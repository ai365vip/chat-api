{"version":3,"sources":["../src/graphic/wrap-text.ts"],"names":[],"mappings":"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","file":"wrap-text.js","sourcesContent":["import { isArray } from '@visactor/vutils';\nimport { CanvasTextLayout } from '../core/contributions/textMeasure/layout';\nimport type { IText, ITextGraphicAttribute, IWrapTextGraphicAttribute, LayoutItemType } from '../interface';\nimport { application } from '../application';\nimport { Text } from './text';\nimport { getTheme } from './theme';\nimport { calculateLineHeight } from '../common/utils';\n\nconst WRAP_TEXT_UPDATE_TAG_KEY = ['heightLimit', 'lineClamp'];\n\n/* WrapText功能\n * 1. 按照宽度限制自动折行或显示省略号(maxLineWidth)\n * 2. 高度限制控制显示内容及省略号(heightLimit)\n * 3. 按照行数限制显示内容及省略号(lineClamp)\n */\nexport class WrapText extends Text {\n  declare attribute: IWrapTextGraphicAttribute;\n\n  constructor(params: ITextGraphicAttribute) {\n    super({ ...params, wrap: true });\n  }\n\n  protected _isValid(): boolean {\n    const { text } = this.attribute;\n    if (isArray(text)) {\n      return !(text as any[]).every((t: any) => t == null || t === '');\n    }\n    return text != null && text !== '';\n  }\n\n  /**\n   * 计算多行文字的bounds，缓存每行文字的布局位置\n   * 自动折行params.text是数组，因此只重新updateMultilineAABBBounds\n   * @param text\n   */\n  updateMultilineAABBBounds(text: (number | string)[]) {\n    const textTheme = getTheme(this).text;\n    const {\n      fontFamily = textTheme.fontFamily,\n      textAlign = textTheme.textAlign,\n      textBaseline = textTheme.textBaseline,\n      fontSize = textTheme.fontSize,\n      ellipsis = textTheme.ellipsis,\n      maxLineWidth,\n      stroke = textTheme.stroke,\n      lineWidth = textTheme.lineWidth,\n      wordBreak = textTheme.wordBreak,\n      fontWeight = textTheme.fontWeight,\n      // widthLimit,\n      ignoreBuf = textTheme.ignoreBuf,\n      heightLimit = 0,\n      suffixPosition = textTheme.suffixPosition,\n      lineClamp\n    } = this.attribute;\n    const lineHeight =\n      calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize) ??\n      (this.attribute.fontSize || textTheme.fontSize);\n    const buf = ignoreBuf ? 0 : 2;\n    if (!this.shouldUpdateShape() && this.cache?.layoutData) {\n      const bbox = this.cache.layoutData.bbox;\n      this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);\n      if (stroke) {\n        this._AABBBounds.expand(lineWidth / 2);\n      }\n      return this._AABBBounds;\n    }\n\n    const textMeasure = application.graphicUtil.textMeasure;\n    const layoutObj = new CanvasTextLayout(fontFamily, { fontSize, fontWeight, fontFamily }, textMeasure as any) as any;\n\n    // layoutObj内逻辑\n    const lines = text.map(l => l.toString()) as string[];\n    const linesLayout: LayoutItemType[] = [];\n    const bboxWH: [number, number] = [0, 0];\n\n    let lineCountLimit = Infinity;\n    if (heightLimit > 0) {\n      lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1);\n    }\n    if (lineClamp) {\n      // 处理行数限制\n      lineCountLimit = Math.min(lineCountLimit, lineClamp);\n    }\n\n    if (typeof maxLineWidth === 'number' && maxLineWidth !== Infinity) {\n      // widthLimit > 0\n      if (maxLineWidth > 0) {\n        for (let i = 0; i < lines.length; i++) {\n          const str = lines[i] as string;\n          let needCut = true;\n          // // 测量当前行宽度\n          // width = Math.min(\n          //   layoutObj.textMeasure.measureTextWidth(str, layoutObj.textOptions),\n          //   maxLineWidth\n          // );\n\n          // 判断是否超过高度限制\n          if (i === lineCountLimit - 1) {\n            // 当前行为最后一行\n            const clip = layoutObj.textMeasure.clipTextWithSuffix(\n              str,\n              layoutObj.textOptions,\n              maxLineWidth,\n              ellipsis,\n              false,\n              suffixPosition\n            );\n            linesLayout.push({\n              str: clip.str,\n              width: clip.width\n            });\n            break; // 不处理后续行\n          }\n\n          // 测量截断位置\n          const clip = layoutObj.textMeasure.clipText(\n            str,\n            layoutObj.textOptions,\n            maxLineWidth,\n            wordBreak === 'break-word'\n          );\n          if (str !== '' && clip.str === '') {\n            if (ellipsis) {\n              const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(\n                str,\n                layoutObj.textOptions,\n                maxLineWidth,\n                ellipsis,\n                false,\n                suffixPosition\n              );\n              clip.str = clipEllipsis.str ?? '';\n              clip.width = clipEllipsis.width ?? 0;\n            } else {\n              // 宽度限制不足一个字符，不显示\n              clip.str = '';\n              clip.width = 0;\n            }\n            needCut = false;\n          }\n\n          linesLayout.push({\n            str: clip.str,\n            width: clip.width\n          });\n          if (clip.str.length === str.length) {\n            // 不需要截断\n          } else if (needCut) {\n            const newStr = str.substring(clip.str.length);\n            lines.splice(i + 1, 0, newStr);\n          }\n        }\n      }\n      // bboxWH[0] = maxLineWidth;\n      let maxWidth = 0;\n      linesLayout.forEach(layout => {\n        maxWidth = Math.max(maxWidth, layout.width);\n      });\n      bboxWH[0] = maxWidth;\n    } else {\n      // 使用所有行中最长的作为lineWidth\n      let lineWidth = 0;\n      let width: number;\n      let text: string;\n      for (let i = 0, len = lines.length; i < len; i++) {\n        // 判断是否超过高度限制\n        if (i === lineCountLimit - 1) {\n          // 当前行为最后一行\n          const clip = layoutObj.textMeasure.clipTextWithSuffix(\n            lines[i],\n            layoutObj.textOptions,\n            maxLineWidth,\n            ellipsis,\n            false,\n            suffixPosition\n          );\n          linesLayout.push({\n            str: clip.str,\n            width: clip.width\n          });\n          lineWidth = Math.max(lineWidth, clip.width);\n          break; // 不处理后续行\n        }\n\n        text = lines[i] as string;\n        width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions, wordBreak === 'break-word');\n        lineWidth = Math.max(lineWidth, width);\n        linesLayout.push({ str: text, width });\n      }\n      bboxWH[0] = lineWidth;\n    }\n    bboxWH[1] = linesLayout.length * (lineHeight + buf);\n\n    const bbox = {\n      xOffset: 0,\n      yOffset: 0,\n      width: bboxWH[0],\n      height: bboxWH[1]\n    };\n\n    layoutObj.LayoutBBox(bbox, textAlign, textBaseline as any);\n\n    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline as any, lineHeight);\n\n    // const layoutData = layoutObj.GetLayoutByLines(\n    //   text,\n    //   textAlign,\n    //   textBaseline as any,\n    //   lineHeight,\n    //   ellipsis === true ? (DefaultTextAttribute.ellipsis as string) : ellipsis || undefined,\n    //   maxLineWidth\n    // );\n    // const { bbox } = layoutData;\n    this.cache.layoutData = layoutData;\n    this.clearUpdateShapeTag();\n    this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);\n\n    if (stroke) {\n      this._AABBBounds.expand(lineWidth / 2);\n    }\n\n    return this._AABBBounds;\n  }\n\n  protected needUpdateTags(keys: string[]): boolean {\n    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {\n      const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];\n      if (keys.indexOf(attrKey) !== -1) {\n        return true;\n      }\n    }\n    return super.needUpdateTags(keys);\n  }\n\n  protected needUpdateTag(key: string): boolean {\n    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {\n      const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];\n      if (key === attrKey) {\n        return true;\n      }\n    }\n    return super.needUpdateTag(key);\n  }\n\n  getNoWorkAnimateAttr(): Record<string, number> {\n    return WrapText.NOWORK_ANIMATE_ATTR;\n  }\n}\n\nexport function createWrapText(attributes: ITextGraphicAttribute): IText {\n  return new WrapText(attributes);\n}\n"]}