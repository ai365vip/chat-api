"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createGlyph = exports.Glyph = void 0;

const graphic_1 = require("./graphic"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants");

class Glyph extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "glyph", this.numberType = constants_1.GLYPH_NUMBER_TYPE, 
        this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();
    }
    setSubGraphic(subGraphic) {
        this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g => {
            g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);
        })), this.valid = this.isValid(), this.addUpdateBoundTag();
    }
    detachSubGraphic() {
        this.subGraphic.forEach((g => {
            g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
        }));
    }
    getSubGraphic() {
        return this.subGraphic;
    }
    onInit(cb) {
        this._onInit = cb;
    }
    onUpdate(cb) {
        this._onUpdate = cb;
    }
    isValid() {
        return !0;
    }
    setAttribute(key, value, forceUpdateTag, context) {
        super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g => {
            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        }));
    }
    setAttributes(params, forceUpdateTag = !1, context) {
        super.setAttributes(params, forceUpdateTag, context), this.subGraphic.forEach((g => {
            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        }));
    }
    translate(x, y) {
        return super.translate(x, y), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    translateTo(x, y) {
        return super.translateTo(x, y), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    scale(scaleX, scaleY, scaleCenter) {
        return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    scaleTo(scaleX, scaleY) {
        return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    rotate(angle) {
        return super.rotate(angle), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    rotateTo(angle) {
        return super.rotate(angle), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    doUpdateAABBBounds() {
        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);
        const bounds = application_1.application.graphicService.updateGlyphAABBBounds(this.attribute, (0, 
        theme_1.getTheme)(this).glyph, this._AABBBounds, this);
        return this.clearUpdateBoundTag(), bounds;
    }
    tryUpdateOBBBounds() {
        throw new Error("暂不支持");
    }
    needUpdateTags(keys) {
        return !1;
    }
    needUpdateTag(key) {
        return !1;
    }
    useStates(states, hasAnimation) {
        var _a;
        if (!states.length) return void this.clearStates(hasAnimation);
        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(((stateName, index) => this.currentStates[index] !== stateName)))) return;
        const stateAttrs = {}, subAttrs = this.subGraphic.map((() => ({})));
        states.forEach((stateName => {
            var _a;
            const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
            attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a = attrs.subAttributes) || void 0 === _a ? void 0 : _a.length) && subAttrs.forEach(((subAttrs, index) => {
                Object.assign(subAttrs, attrs.subAttributes[index]);
            })));
        })), this.subGraphic.forEach(((graphic, index) => {
            graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
        })), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
    }
    clearStates(hasAnimation) {
        this.hasState() && this.normalAttrs && (this.subGraphic.forEach((graphic => {
            graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, !0), 
            graphic.normalAttrs = null;
        })), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0), 
        this.normalAttrs = null, this.currentStates = []);
    }
    clone() {
        const glyph = new Glyph(Object.assign({}, this.attribute));
        return glyph.setSubGraphic(this.subGraphic.map((g => g.clone()))), glyph;
    }
    getNoWorkAnimateAttr() {
        return Glyph.NOWORK_ANIMATE_ATTR;
    }
}

function createGlyph(attributes) {
    return new Glyph(attributes);
}

exports.Glyph = Glyph, Glyph.NOWORK_ANIMATE_ATTR = graphic_1.NOWORK_ANIMATE_ATTR, 
exports.createGlyph = createGlyph;
//# sourceMappingURL=glyph.js.map
