import type { EasingType, EasingTypeFunc, IAnimate, IAnimateStepType, IAnimateTarget, ICustomAnimate, IStep, IStepConfig, ISubAnimate, ITimeline } from '../interface';
import { AnimateMode, AnimateStatus } from '../common/enums';
export declare abstract class ACustomAnimate<T> implements ICustomAnimate {
    from: T;
    to: T;
    duration: number;
    easing: EasingType;
    params: any;
    target: IAnimateTarget;
    updateCount: number;
    subAnimate: ISubAnimate;
    step?: IStep;
    mode?: AnimateMode;
    _endProps?: any;
    _mergedEndProps?: any;
    constructor(from: T, to: T, duration: number, easing: EasingType, params?: any);
    bind(target: IAnimateTarget, subAni: ISubAnimate): void;
    onBind(): void;
    onFirstRun(): void;
    onStart(): void;
    onEnd(): void;
    getEndProps(): Record<string, any> | void;
    getFromProps(): Record<string, any> | void;
    getMergedEndProps(): Record<string, any> | void;
    abstract onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
    update(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class CbAnimate extends ACustomAnimate<null> {
    cb: () => void;
    constructor(cb: () => void);
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
    onStart(): void;
}
type InterpolateFunc = (key: string, ratio: number, from: any, to: any, target: IAnimateTarget, out: Record<string, any>) => boolean;
export declare class Animate implements IAnimate {
    static mode: AnimateMode;
    target: IAnimateTarget;
    timeline: ITimeline;
    nextAnimate?: IAnimate;
    prevAnimate?: IAnimate;
    status: AnimateStatus;
    readonly id: string | number;
    protected _startTime: number;
    protected _duringTime: number;
    subAnimates: SubAnimate[];
    tailAnimate: SubAnimate;
    rawPosition: number;
    timeScale: number;
    interpolateFunc: (key: string, ratio: number, from: any, to: any, nextAttributes: any) => boolean;
    _onStart?: (() => void)[];
    _onFrame?: ((step: IStep, ratio: number) => void)[];
    _onEnd?: (() => void)[];
    _onRemove?: (() => void)[];
    _preventAttrs?: Set<string>;
    static interpolateMap: Map<string, InterpolateFunc>;
    constructor(id?: string | number, timeline?: ITimeline);
    setTimeline(timeline: ITimeline): void;
    getStartTime(): number;
    getDuration(): number;
    after(animate: IAnimate): this;
    afterAll(list: IAnimate[]): this;
    parallel(animate: IAnimate): this;
    static AddInterpolate(name: string, cb: InterpolateFunc): void;
    play(customAnimate: ICustomAnimate): this;
    trySetAttribute(attr: Record<string, any> | void, mode?: AnimateMode): void;
    runCb(cb: (a: IAnimate, step: IStep) => void): this;
    customInterpolate(key: string, ratio: number, from: any, to: any, target: IAnimateTarget, ret: Record<string, any>): boolean;
    pause(): void;
    resume(): void;
    to(props: Record<string, any>, duration: number, easing: EasingType, params?: IStepConfig): this;
    from(props: Record<string, any>, duration: number, easing: EasingType, params?: IStepConfig): this;
    wait(duration: number): this;
    startAt(t: number): this;
    loop(l: number): this;
    reversed(r: boolean): this;
    bounce(b: boolean): this;
    subAnimate(): this;
    getStartProps(): Record<string, any>;
    getEndProps(): Record<string, any>;
    depreventAttr(key: string): void;
    preventAttr(key: string): void;
    preventAttrs(keys: string[]): void;
    validAttr(key: string): boolean;
    bind(target: IAnimateTarget): this;
    advance(delta: number): void;
    setPosition(rawPosition: number): boolean;
    onStart(cb: () => void): void;
    onEnd(cb: () => void): void;
    onRemove(cb: () => void): void;
    onFrame(cb: (step: IStep, ratio: number) => void): void;
    release(): void;
    stop(nextVal?: 'start' | 'end' | Record<string, any>): void;
}
export declare class SubAnimate implements ISubAnimate {
    target: IAnimateTarget;
    animate: IAnimate;
    protected stepHead: Step;
    protected stepTail: Step;
    bounce: boolean;
    reversed: boolean;
    loop: number;
    duration: number;
    position: number;
    rawPosition: number;
    dirty: boolean;
    _totalDuration: number;
    _startAt: number;
    _lastStep: IStep;
    _deltaPosition: number;
    get totalDuration(): number;
    constructor(animate: IAnimate, lastSubAnimate?: SubAnimate);
    protected calcAttr(): void;
    bind(target: IAnimateTarget): this;
    play(customAnimate: ICustomAnimate): this;
    to(props: Record<string, any>, duration: number, easing: EasingType, params?: IStepConfig): this;
    from(props: Record<string, any>, duration: number, easing: EasingType, params?: IStepConfig): void;
    startAt(t: number): this;
    getStartProps(): any;
    getEndProps(): any;
    getLastStep(): IStep;
    wait(duration: number): this;
    protected _addStep(duration: number, props: any, easingFunc?: EasingTypeFunc): Step;
    protected _appendProps(props: any, step: Step, tempProps?: boolean): void;
    protected _appendCustomAnimate(customAnimate: ICustomAnimate, step: Step): void;
    setPosition(rawPosition: number): boolean;
    protected updatePosition(end: boolean, rev: boolean): void;
    tryCallCustomAnimateLifeCycle(step: IStep, lastStep: IStep, rev: boolean): void;
    getLastPropByName(name: string, step: Step): any;
    protected updateTarget(step: Step, ratio: number, end: boolean): void;
}
declare class Step implements IStep {
    prev?: Step;
    duration: number;
    position: number;
    next?: Step;
    props: any;
    parsedProps?: any;
    propKeys?: string[];
    easing?: EasingTypeFunc;
    customAnimate?: ICustomAnimate;
    type: IAnimateStepType;
    constructor(position: number, duration: number, props?: any, easing?: EasingTypeFunc);
    append(step: Step): void;
    getLastProps(): any;
}
export {};
