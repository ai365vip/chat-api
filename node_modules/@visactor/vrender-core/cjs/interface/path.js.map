{"version":3,"sources":["../src/interface/path.ts"],"names":[],"mappings":";;;AAIa,QAAA,aAAa,GAAG;IAC3B,KAAK;IACL,OAAO;IACP,eAAe;IACf,WAAW;IACX,SAAS;IACT,QAAQ;IACR,QAAQ;IACR,kBAAkB;IAClB,MAAM;CACP,CAAC","file":"path.js","sourcesContent":["import type { IAABBBounds, IPoint, IPointLike } from '@visactor/vutils';\nimport type { Releaseable, IDirection } from './common';\nimport type { CurveTypeEnum } from '../common/enums';\n\nexport const strCommandMap = [\n  'arc',\n  'arcTo',\n  'bezierCurveTo',\n  'closePath',\n  'ellipse',\n  'lineTo',\n  'moveTo',\n  'quadraticCurveTo',\n  'rect'\n];\n\nexport type CommandType = [\n  number,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?\n];\n\nexport type CommandStrType = [\n  string,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?,\n  (number | boolean)?\n];\n\nexport interface ICurve<T> {\n  type: number;\n  defined: boolean;\n  originP1?: IPointLike;\n  originP2?: IPointLike;\n  readonly p0: T;\n  readonly p1?: T;\n  readonly p2?: T;\n  readonly p3?: T;\n  getPointAt: (t: number) => IPointLike;\n  getAngleAt: (t: number) => number;\n  getLength: (direction?: IDirection) => number;\n}\n\nexport interface ICubicBezierCurve extends ICurve<IPoint> {\n  type: CurveTypeEnum.CubicBezierCurve;\n  // p0: IPoint;\n  readonly p1: IPoint;\n  readonly p2: IPoint;\n  readonly p3: IPoint;\n}\n\nexport interface IQuadraticBezierCurve extends ICurve<IPoint> {\n  type: CurveTypeEnum.QuadraticBezierCurve;\n  // p0: IPoint;\n  readonly p1: IPoint;\n  readonly p2: IPoint;\n}\n\nexport interface IArcCurve extends ICurve<IPoint> {\n  type: CurveTypeEnum.ArcCurve;\n  // p0: IPoint;\n  readonly p1: IPoint;\n  radius: number;\n}\n\nexport interface ILineCurve extends ICurve<IPoint> {\n  type: CurveTypeEnum.LineCurve;\n  // p0: IPoint;\n  readonly p1: IPoint;\n}\n\nexport interface IEllipseCurve extends ICurve<IPoint> {\n  type: CurveTypeEnum.EllipseCurve;\n  // p0: IPoint;\n  radiusX: number;\n  radiusY: number;\n  rotation: number;\n  startAngle: number;\n  endAngle: number;\n  anticlockwise?: boolean;\n}\n\nexport interface IMoveCurve extends ICurve<IPoint> {\n  type: CurveTypeEnum.MoveCurve;\n  // p0: IPoint;\n  readonly p1: IPoint;\n}\n\nexport interface ICurvePath<T> {\n  curves: ICurve<T>[];\n  bounds?: IAABBBounds;\n  getPointAt: (t: number) => IPointLike;\n  getCurveLengths: () => number[];\n  getLength: (direction?: IDirection) => number;\n  getBounds?: () => IAABBBounds;\n}\n\nexport interface IPath2D {\n  moveTo: (x: number, y: number, z?: number) => void;\n  lineTo: (x: number, y: number, z?: number) => void;\n  quadraticCurveTo: (aCPx: number, aCPy: number, aX: number, aY: number, z?: number) => void;\n  bezierCurveTo: (\n    aCP1x: number,\n    aCP1y: number,\n    aCP2x: number,\n    aCP2y: number,\n    aX: number,\n    aY: number,\n    z?: number\n  ) => void;\n  arcTo: (aX1: number, aY1: number, aX2: number, aY2: number, aRadius: number, z?: number) => void;\n  ellipse: (\n    aX: number,\n    aY: number,\n    xRadius: number,\n    yRadius: number,\n    aRotation: number,\n    aStartAngle: number,\n    aEndAngle: number,\n    aClockwise: boolean\n  ) => void;\n  rect: (x: number, y: number, w: number, h: number, z?: number) => void;\n  arc: (\n    x: number,\n    y: number,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    counterclockwise?: boolean,\n    z?: number\n  ) => void;\n  closePath: () => void;\n}\n\n// 用户可以直接操作path2D\nexport interface ICustomPath2D extends ICurvePath<IPoint>, IPath2D, Releaseable {\n  commandList: CommandType[];\n\n  toString: () => string;\n  transform: (x: number, y: number, sx: number, sy: number) => void;\n  fromString: (pathStr: string, x?: number, y?: number, sX?: number, sY?: number) => ICustomPath2D;\n  fromCustomPath2D: (path: ICustomPath2D, x?: number, y?: number, sX?: number, sY?: number) => ICustomPath2D;\n  addCurve: (curve: ICurve<IPoint>) => void;\n  clear: () => void;\n}\n"]}