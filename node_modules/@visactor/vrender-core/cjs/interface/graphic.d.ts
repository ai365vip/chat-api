import type { IAABBBounds, IOBBBounds, IMatrix, IPointLike, IPoint } from '@visactor/vutils';
import type { IAnimate, IStep, EasingType, IAnimateTarget } from './animate';
import type { IColor } from './color';
import type { IGroup } from './graphic/group';
import type { IShadowRoot } from './graphic/shadow-root';
import type { ILayer } from './layer';
import type { INode } from './node-tree';
import type { ICustomPath2D } from './path';
import type { IStage } from './stage';
import type { IGlyphGraphicAttribute } from './graphic/glyph';
import type { IContainPointMode } from '../common/enums';
import type { IFace3d } from './graphic/face3d';
import type { IPickerService } from './picker';
type IStrokeSeg = {
    start: number;
    end: number;
    length: number;
};
export type GraphicType = 'area' | 'circle' | 'ellipse' | 'line' | 'rect' | 'rect3d' | 'path' | 'richtext' | 'text' | 'arc' | 'arc3d' | 'image' | 'symbol' | 'group' | 'shadowroot' | 'polygon' | 'pyramid3d' | 'glyph';
export type Cursor = 'auto' | 'default' | 'none' | 'context-menu' | 'help' | 'pointer' | 'progress' | 'wait' | 'cell' | 'crosshair' | 'text' | 'vertical-text' | 'alias' | 'copy' | 'move' | 'no-drop' | 'not-allowed' | 'grab' | 'grabbing' | 'all-scroll' | 'col-resize' | 'row-resize' | 'n-resize' | 'e-resize' | 's-resize' | 'w-resize' | 'ne-resize' | 'nw-resize' | 'se-resize' | 'sw-resize' | 'ew-resize' | 'ns-resize' | 'nesw-resize' | 'nwse-resize' | 'zoom-in' | 'zoom-out';
export type ITransform = {
    x: number;
    y: number;
    z: number;
    dx: number;
    dy: number;
    dz: number;
    scrollX: number;
    scrollY: number;
    scaleX: number;
    scaleY: number;
    scaleZ: number;
    angle: number;
    alpha: number;
    beta: number;
    scaleCenter: [number | string, number | string];
    anchor: [number | string, number | string];
    anchor3d: [number | string, number | string, number] | [number | string, number | string];
    postMatrix: IMatrix;
};
export type IFillType = boolean | string | IColor;
export type IFillStyle = {
    fillOpacity: number;
    shadowBlur: number;
    shadowColor: string;
    shadowOffsetX: number;
    shadowOffsetY: number;
    fill: IFillType;
};
export type ILayout = {
    alignSelf: 'auto' | 'flex-start' | 'flex-end' | 'center' | 'baseline' | 'stretch';
};
export type IBorderStyle = Omit<IStrokeStyle, 'outerBorder' | 'innerBorder'> & {
    distance: number | string;
    visible?: boolean;
};
export type IStrokeType = boolean | string | IColor | null;
export type IStrokeStyle = {
    outerBorder: Partial<IBorderStyle>;
    innerBorder: Partial<IBorderStyle>;
    strokeOpacity: number;
    lineDash: number[];
    lineDashOffset: number;
    lineWidth: number;
    lineCap: CanvasLineCap;
    lineJoin: CanvasLineJoin;
    miterLimit: number;
    strokeBoundsBuffer: number;
    stroke: IStrokeType[] | IStrokeType;
};
type TextureType = 'circle' | 'diamond' | 'rect' | 'vertical-line' | 'horizontal-line' | 'bias-lr' | 'bias-rl' | 'grid';
export type IConnectedStyle = {
    connectedType: 'connect' | 'zero' | 'none';
    connectedStyle: {
        stroke: IStrokeStyle['stroke'];
        strokeOpacity: IStrokeStyle['strokeOpacity'];
        lineDash: IStrokeStyle['lineDash'];
        lineDashOffset: IStrokeStyle['lineDashOffset'];
        lineCap: IStrokeStyle['lineCap'];
        lineJoin: IStrokeStyle['lineJoin'];
        lineWidth: IStrokeStyle['lineWidth'];
        fill: IFillStyle['fill'];
        fillOpacity: IFillStyle['fillOpacity'];
    };
    connectedX: number;
    connectedY: number;
};
export type IBackgroundConfig = {
    stroke?: string | boolean;
    fill?: string | boolean;
    lineWidth?: number;
    cornerRadius?: number;
    expandX?: number;
    expandY?: number;
};
type IBackgroundType = string | HTMLImageElement | HTMLCanvasElement | IBackgroundConfig;
export type IGraphicStyle = IFillStyle & IStrokeStyle & IPickStyle & {
    opacity: number;
    backgroundMode: 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';
    backgroundFit: boolean;
    background: IBackgroundType | {
        background: IBackgroundType;
        dx?: number;
        dy?: number;
        width?: number;
        height?: number;
        x?: number;
        y?: number;
    } | null;
    texture: TextureType | string;
    textureColor: string;
    textureSize: number;
    texturePadding: number;
    blur: number;
    cursor: Cursor | null;
    html: {
        dom: string | HTMLElement;
        container: string | HTMLElement | null;
        width: number;
        height: number;
        style: string | Record<string, any>;
        visible?: boolean;
        anchorType?: 'position' | 'boundsLeftTop';
    } | null;
};
export type IPickStyle = {
    pickStrokeBuffer: number;
};
export type IDebugType = {
    _debug_bounds: boolean | ((c: any, g: any) => void);
};
export type IGraphicAttribute = IDebugType & IGraphicStyle & ITransform & {
    strokeSeg: IStrokeSeg | null;
    boundsPadding: number | number[];
    pickMode: 'accurate' | 'imprecise' | 'custom';
    boundsMode: 'accurate' | 'imprecise';
    customPickShape: () => boolean | null;
    pickable: boolean;
    fillPickable: boolean;
    strokePickable: boolean;
    childrenPickable: boolean;
    visible: boolean;
    zIndex: number;
    layout: any;
    keepDirIn3d?: boolean;
    shadowRootIdx: number;
    globalZIndex: number;
    globalCompositeOperation: CanvasRenderingContext2D['globalCompositeOperation'] | '';
    overflow: 'scroll' | 'hidden' | 'scroll-x' | 'scroll-y';
};
export interface IGraphicJson<T extends Partial<IGraphicAttribute> = Partial<IGraphicAttribute>> {
    attribute: Partial<T>;
    _uid: number;
    type: string;
    name: string;
    children: IGraphicJson<T>[];
}
export type ISetAttributeContext = {
    type?: number;
    animationState?: {
        step?: IStep;
        isFirstFrameOfStep?: boolean;
        ratio?: number;
        end?: boolean;
    };
    skipUpdateCallback?: boolean;
};
export type IGraphicAnimateParams = {
    id?: number | string;
    onStart?: () => void;
    onFrame?: (step: IStep, ratio: number) => void;
    onEnd?: () => void;
    onRemove?: () => void;
    interpolate?: (key: string, ratio: number, from: any, to: any, nextAttributes: any) => boolean;
};
export interface IGraphic<T extends Partial<IGraphicAttribute> = Partial<IGraphicAttribute>> extends INode, IAnimateTarget {
    type?: GraphicType;
    numberType?: number;
    stage?: IStage;
    layer?: ILayer;
    shadowRoot?: IShadowRoot;
    glyphHost?: IGraphic<IGlyphGraphicAttribute>;
    backgroundImg?: boolean;
    bindDom?: Map<string | HTMLElement, {
        container: HTMLElement | string;
        dom: HTMLElement;
        wrapGroup: HTMLDivElement;
    }>;
    valid: boolean;
    parent: IGroup | null;
    isContainer?: boolean;
    in3dMode?: boolean;
    stamp?: number;
    animationBackUps?: {
        from: Record<string, any>;
        to: Record<string, any>;
    };
    attribute: Partial<T>;
    pathProxy?: ICustomPath2D | ((attrs: T) => ICustomPath2D);
    incremental?: number;
    incrementalAt?: number;
    states?: Record<string, Partial<T>>;
    normalAttrs?: Partial<T>;
    stateProxy?: (stateName: string, targetStates?: string[]) => Partial<T>;
    findFace?: () => IFace3d;
    toggleState: (stateName: string, hasAnimation?: boolean) => void;
    removeState: (stateName: string, hasAnimation?: boolean) => void;
    clearStates: (hasAnimation?: boolean) => void;
    useStates: (states: string[], hasAnimation?: boolean) => void;
    addState: (stateName: string, keepCurrentStates?: boolean, hasAnimation?: boolean) => void;
    hasState: (stateName?: string) => boolean;
    getState: (stateName: string) => Partial<T>;
    onBeforeAttributeUpdate?: (val: any, attributes: Partial<T>, key: null | string | string[], context?: ISetAttributeContext) => T | undefined;
    applyStateAttrs: (attrs: Partial<T>, stateNames: string[], hasAnimation?: boolean, isClear?: boolean) => void;
    updateNormalAttrs: (stateAttrs: Partial<T>) => void;
    readonly AABBBounds: IAABBBounds;
    readonly OBBBounds: IOBBBounds;
    readonly globalAABBBounds: IAABBBounds;
    readonly transMatrix: IMatrix;
    readonly globalTransMatrix: IMatrix;
    getOffsetXY: (attr?: ITransform) => IPoint;
    containsPoint: (x: number, y: number, mode?: IContainPointMode, picker?: IPickerService) => boolean;
    setMode: (mode: '3d' | '2d') => void;
    isValid: () => boolean;
    translate: (x: number, y: number) => this;
    translateTo: (x: number, y: number) => this;
    scale: (scaleX: number, scaleY: number, scaleCenter?: IPointLike) => this;
    scaleTo: (scaleX: number, scaleY: number) => this;
    rotate: (angle: number, rotateCenter?: IPointLike) => this;
    rotateTo: (angle: number) => this;
    skewTo: (b: number, c: number) => this;
    addUpdateBoundTag: () => void;
    addUpdateShapeAndBoundsTag: () => void;
    addUpdateLayoutTag: () => void;
    update: (d?: {
        bounds: boolean;
        trans: boolean;
    }) => void;
    animate: (params?: IGraphicAnimateParams) => IAnimate;
    name?: string;
    shouldUpdateShape: () => boolean;
    clearUpdateShapeTag: () => void;
    setAttributes: (params: Partial<T>, forceUpdateTag?: boolean, context?: ISetAttributeContext) => void;
    initAttributes: (params: Partial<T>) => void;
    setAttribute: (key: string, value: any, forceUpdateTag?: boolean, context?: ISetAttributeContext) => void;
    setStage: (stage?: IStage, layer?: ILayer) => void;
    onSetStage: (cb: (g: IGraphic, stage: IStage) => void) => void;
    shouldUpdateAABBBounds: () => boolean;
    shouldSelfChangeUpdateAABBBounds: () => boolean;
    shouldUpdateGlobalMatrix: () => boolean;
    addUpdatePositionTag: () => void;
    addUpdateGlobalPositionTag: () => void;
    attachShadow: () => IShadowRoot;
    detachShadow: () => void;
    toJson: () => IGraphicJson;
    createPathProxy: (path?: string) => void;
    toCustomPath?: () => ICustomPath2D;
    resources?: Map<string | HTMLImageElement | HTMLCanvasElement | IBackgroundConfig, {
        state: 'init' | 'loading' | 'success' | 'fail';
        data?: HTMLImageElement | HTMLCanvasElement;
    }>;
    imageLoadSuccess: (url: string, data: HTMLImageElement) => void;
    imageLoadFail: (url: string) => void;
    clone: () => IGraphic;
    stopAnimates: (stopChildren?: boolean) => void;
    getNoWorkAnimateAttr: () => Record<string, number>;
}
export interface IRoot extends IGraphic {
    pick: (x: number, y: number) => IGraphic;
}
export type IAnimateConfig = {
    duration?: number;
    easing?: EasingType;
};
export type GraphicReleaseStatus = 'released' | 'willRelease';
export {};
