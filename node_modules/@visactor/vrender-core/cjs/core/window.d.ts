import type { IBoundsLike } from '@visactor/vutils';
import type { ICanvas, IContext2d, IDomRectLike, IGlobal, IWindow, IWindowHandlerContribution, IWindowParams } from '../interface';
import { SyncHook } from '../tapable';
export declare const VWindow: unique symbol;
export declare const WindowHandlerContribution: unique symbol;
export declare class DefaultWindow implements IWindow {
    protected _width: number;
    protected _height: number;
    protected _handler: IWindowHandlerContribution;
    hooks: {
        onChange: SyncHook<[number, number, number, number], void, import("../interface").UnsetAdditionalOptions>;
    };
    parent: Window;
    get width(): number;
    get height(): number;
    _uid: number;
    resizable: boolean;
    minHeight: number;
    minWidth: number;
    maxHeight: number;
    maxWidth: number;
    title: string;
    mainCanvas: ICanvas;
    layerCanvas: ICanvas[];
    actived: boolean;
    global: IGlobal;
    get dpr(): number;
    constructor();
    protected postInit(): void;
    protected active(): void;
    get style(): CSSStyleDeclaration | Record<string, any>;
    set style(style: CSSStyleDeclaration | Record<string, any>);
    create(params: IWindowParams): void;
    setWindowHandler(handler: IWindowHandlerContribution): void;
    setDpr(dpr: number): void;
    resize(w: number, h: number): void;
    configure(): void;
    release(): void;
    getContext(): IContext2d;
    getNativeHandler(): ICanvas;
    getImageBuffer(type?: string): any;
    addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    dispatchEvent(event: any): boolean;
    getBoundingClientRect(): IDomRectLike;
    getContainer(): HTMLElement | any;
    clearViewBox(viewBox: IBoundsLike, color?: string): void;
    isVisible(bbox?: IBoundsLike): boolean;
    onVisibleChange(cb: (currentVisible: boolean) => void): void;
    getTopLeft(baseWindow?: boolean): {
        top: number;
        left: number;
    };
}
