"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Layer = void 0;

const application_1 = require("../application"), theme_1 = require("../graphic/theme"), group_1 = require("../graphic/group");

class Layer extends group_1.Group {
    get offscreen() {
        return this.layerHandler.offscreen;
    }
    get layerMode() {
        return this.layerHandler.type;
    }
    get width() {
        return this.stage ? this.stage.width : 0;
    }
    get height() {
        return this.stage ? this.stage.height : 0;
    }
    get viewWidth() {
        return this.stage ? this.stage.viewWidth : 0;
    }
    get viewHeight() {
        return this.stage ? this.stage.viewHeight : 0;
    }
    get dirtyBound() {
        throw new Error("暂不支持");
    }
    get dpr() {
        return this._dpr;
    }
    constructor(stage, global, window, params) {
        var _a;
        super({}), this.stage = stage, this.global = global, this.window = window, this.main = params.main, 
        this.layerHandler = params.layerHandler, this.layerHandler.init(this, window, {
            main: params.main,
            canvasId: params.canvasId,
            width: this.viewWidth,
            height: this.viewHeight,
            zIndex: null !== (_a = params.zIndex) && void 0 !== _a ? _a : 0
        }), this.layer = this, this.subLayers = new Map, this.theme = new theme_1.Theme, 
        this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
    }
    combineSubLayer(removeIncrementalKey = !0) {
        const subLayers = Array.from(this.subLayers.values()).sort(((a, b) => a.zIndex - b.zIndex));
        this.layerHandler.merge(subLayers.map((l => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), 
        l.layer.getNativeHandler())))), removeIncrementalKey && subLayers.forEach((l => {
            l.group && (l.group.incremental = 0);
        })), subLayers.forEach((l => {
            application_1.application.layerService.releaseLayer(this.stage, l.layer);
        })), this.subLayers.clear();
    }
    getNativeHandler() {
        return this.layerHandler;
    }
    setStage(stage, layer) {
        super.setStage(stage, this);
    }
    pick(x, y) {
        throw new Error("暂不支持");
    }
    tryRenderSecondaryLayer(params, userParams) {
        this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach((h => {
            h.layer.renderCount = this.renderCount, h.layer.render(params, userParams);
        }));
    }
    render(params, userParams) {
        var _a;
        const stage = this.stage;
        this.layerHandler.render([ this ], {
            renderService: params.renderService,
            x: stage.x,
            y: stage.y,
            width: this.viewWidth,
            height: this.viewHeight,
            stage: this.stage,
            layer: this,
            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
            updateBounds: params.updateBounds
        }, userParams), this.afterDrawCbs.forEach((c => c(this))), this.tryRenderSecondaryLayer(params, userParams);
    }
    resize(w, h) {
        this.layerHandler.resize(w, h);
    }
    resizeView(w, h) {
        this.layerHandler.resizeView(w, h);
    }
    setDpr(dpr) {
        this.layerHandler.setDpr(dpr);
    }
    afterDraw(cb) {
        this.afterDrawCbs.push(cb);
    }
    startAnimate(t) {
        throw new Error("暂不支持");
    }
    setToFrame(t) {
        throw new Error("暂不支持");
    }
    prepare(dirtyBounds, params) {}
    combineTo(target, params) {
        var _a, _b, _c;
        this.offscreen && (this.layerHandler.drawTo(target, [ this ], Object.assign({
            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
            renderService: params.renderService,
            x: null !== (_b = params.x) && void 0 !== _b ? _b : this.stage.x,
            y: null !== (_c = params.y) && void 0 !== _c ? _c : this.stage.y,
            width: this.viewWidth,
            height: this.viewHeight,
            stage: this.stage,
            layer: this
        }, params)), this.afterDrawCbs.forEach((c => c(this))));
    }
    release() {
        super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach((l => {
            application_1.application.layerService.releaseLayer(this.stage, l.layer);
        }));
    }
    drawTo(target, params) {
        var _a, _b, _c;
        this.layerHandler.drawTo(target, [ this ], Object.assign({
            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
            renderService: params.renderService,
            x: null !== (_b = params.x) && void 0 !== _b ? _b : this.stage.x,
            y: null !== (_c = params.y) && void 0 !== _c ? _c : this.stage.y,
            width: this.viewWidth,
            height: this.viewHeight,
            stage: this.stage,
            layer: this
        }, params)), this.afterDrawCbs.forEach((c => c(this)));
    }
}

exports.Layer = Layer;
//# sourceMappingURL=layer.js.map
