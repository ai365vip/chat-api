import type { IAABBBounds, IBounds, IBoundsLike, IMatrix } from '@visactor/vutils';
import { AABBBounds } from '@visactor/vutils';
import type { IExportType, IStage, IStageParams, ILayer, IColor, IOption3D, ICamera, vec3, IDirectionLight, ITicker, IRenderService, IPickerService, IPluginService, ISyncHook, IDrawContext, IWindow, ILayerService, ITimeline, IOptimizeType, LayerMode, PickResult } from '../interface';
import type { Layer } from './layer';
import { Group } from '../graphic';
type IStageState = 'rendering' | 'normal';
export declare class Stage extends Group implements IStage {
    parent: IStage | null;
    state: IStageState;
    protected _viewBox: AABBBounds;
    private _background;
    private _subView;
    protected nextFrameRenderLayerSet: Set<Layer>;
    protected willNextFrameRender: boolean;
    protected _cursor: string;
    renderCount: number;
    dirtyBounds: IBounds | null;
    option3d?: IOption3D;
    light?: IDirectionLight;
    camera?: ICamera;
    renderStyle?: string;
    hooks: {
        beforeRender: ISyncHook<[IStage]>;
        afterRender: ISyncHook<[IStage]>;
    };
    set viewBox(b: IBoundsLike);
    get viewBox(): AABBBounds;
    get x(): number;
    set x(x: number);
    get y(): number;
    set y(y: number);
    get width(): number;
    set width(w: number);
    get viewWidth(): number;
    set viewWidth(w: number);
    get viewHeight(): number;
    set viewHeight(h: number);
    get height(): number;
    set height(h: number);
    get dpr(): number;
    set dpr(r: number);
    get background(): string | IColor;
    set background(b: string | IColor);
    get defaultLayer(): ILayer;
    ticker: ITicker;
    autoRender: boolean;
    _enableLayout: boolean;
    htmlAttribute: boolean | string | any;
    increaseAutoRender: boolean;
    view3dTranform: boolean;
    readonly window: IWindow;
    private readonly global;
    readonly renderService: IRenderService;
    pickerService?: IPickerService;
    readonly pluginService: IPluginService;
    readonly layerService: ILayerService;
    private _eventSystem?;
    private get eventSystem();
    protected _beforeRender?: (stage: IStage) => void;
    protected _afterRender?: (stage: IStage) => void;
    protected _skipRender?: number;
    protected _afterNextRenderCbs?: ((stage: IStage) => void)[];
    protected lastRenderparams?: Partial<IDrawContext>;
    protected interactiveLayer?: ILayer;
    protected supportInteractiveLayer: boolean;
    protected timeline: ITimeline;
    params: Partial<IStageParams>;
    constructor(params?: Partial<IStageParams>);
    protected tryInitEventSystem(): void;
    preventRender(prevent: boolean): void;
    optmize(params: IOptimizeType): void;
    protected optmizeRender(skipRenderWithOutRange?: boolean): void;
    protected _onVisibleChange: (visible: boolean) => void;
    getTimeline(): ITimeline;
    get3dOptions(options: IOption3D): {
        center: {
            x?: number;
            y?: number;
            z?: number;
            dx?: number;
            dy?: number;
            dz?: number;
        };
        light: {
            dir?: vec3;
            color?: string;
            ambient?: number;
        };
        alpha: number;
        beta: number;
        camera: any;
        fieldRatio: number;
        fieldDepth: number;
        enableView3dTransform?: boolean;
        gama?: number;
    };
    set3dOptions(options: IOption3D): void;
    protected beforeRender: (stage: IStage) => void;
    protected afterRender: (stage: IStage) => void;
    setBeforeRender(cb: (stage: IStage) => void): void;
    setAfterRender(cb: (stage: IStage) => void): void;
    afterNextRender(cb: (stage: IStage) => void): void;
    enableView3dTransform(): void;
    disableView3dTranform(): void;
    enableAutoRender(): void;
    disableAutoRender(): void;
    enableIncrementalAutoRender(): void;
    disableIncrementalAutoRender(): void;
    enableDirtyBounds(): void;
    disableDirtyBounds(): void;
    enableLayout(): void;
    disableLayout(): void;
    enableHtmlAttribute(container?: any): void;
    disableHtmlAttribute(): void;
    protected tryUpdateAABBBounds(): AABBBounds;
    combineLayer(ILayer1: ILayer, ILayer2: ILayer): ILayer;
    createLayer(canvasId?: string, layerMode?: LayerMode): ILayer;
    sortLayer(cb: (ILayer1: ILayer, layer2: ILayer) => number): void;
    removeLayer(ILayerId: number): ILayer | false;
    tryInitInteractiveLayer(): void;
    clearViewBox(color?: string): void;
    render(layers?: ILayer[], params?: Partial<IDrawContext>): void;
    protected combineLayersToWindow(): void;
    renderNextFrame(layers?: ILayer[], force?: boolean): void;
    _doRenderInThisFrame(): void;
    protected renderLayerList(layerList: ILayer[], params?: Partial<IDrawContext>): void;
    resizeWindow(w: number, h: number, rerender?: boolean): void;
    resize(w: number, h: number, rerender?: boolean): void;
    resizeView(w: number, h: number, rerender?: boolean): void;
    setViewBox(viewBox: IBoundsLike, rerender: boolean): void;
    setViewBox(x: number, y: number, w: number, h: number, rerender: boolean): void;
    setDpr(dpr: number, rerender?: boolean): void;
    setOrigin(x: number, y: number): void;
    export(type: IExportType): HTMLCanvasElement | ImageData;
    pick(x: number, y: number): PickResult | false;
    startAnimate(t: number): void;
    setToFrame(t: number): void;
    release(): void;
    setStage(stage?: IStage): void;
    dirty(b: IBounds, matrix?: IMatrix): void;
    getLayer(name: string): undefined | ILayer;
    renderTo(window: IWindow, params: {
        x: number;
        y: number;
        width: number;
        height: number;
    }): void;
    renderToNewWindow(fullImage?: boolean, viewBox?: IAABBBounds): IWindow;
    toCanvas(fullImage?: boolean, viewBox?: IAABBBounds): HTMLCanvasElement | null;
    setCursor(mode?: string): void;
    getCursor(): string;
}
export {};
