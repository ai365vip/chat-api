"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.HashTable = exports.HashValue = void 0;

class HashValue {}

exports.HashValue = HashValue;

class HashTable {
    constructor() {
        this.items = {}, this.itemList = [];
    }
    get type() {
        return "xhHashTable";
    }
    set(key, value) {
        const vl = new HashValue;
        vl.key = key, vl.value = value;
        let index = this.itemList.length;
        return this.has(key) && (index = this.items[key].index), vl.index = index, this.itemList[index] = vl, 
        this.items[key] = vl, vl;
    }
    clear() {
        this.items = {}, this.itemList = [];
    }
    del(key) {
        if (this.has(key)) {
            const index = this.items[key].index;
            index > -1 && this.itemList.splice(index, 1), delete this.items[key], this.resetIndex();
        }
    }
    delFrom(index) {
        for (let i = index + 1; i < this.count(); i++) {
            const key = this.itemList[i].key;
            delete this.items[key];
        }
        this.itemList.splice(index + 1, this.count() - index), this.resetIndex();
    }
    resetIndex() {
        this.foreachHashv(((k, v) => {
            const index = this.itemList.indexOf(v);
            this.items[k].index = index;
        }));
    }
    has(key) {
        return key in this.items;
    }
    get(key) {
        return this.has(key) ? this.items[key].value : null;
    }
    count() {
        return this.itemList.length;
    }
    all() {
        return this.itemList.map((vl => vl.value));
    }
    first() {
        return this.itemList[0].value;
    }
    last() {
        return this.itemList[this.itemList.length - 1].value;
    }
    getByIndex(index) {
        return this.itemList[index].value;
    }
    getKeyByIndex(index) {
        return this.itemList[index].key;
    }
    foreach(callback) {
        for (const key in this.items) {
            if (!1 === callback(key, this.items[key].value)) return !1;
        }
        return !0;
    }
    foreachHashv(callback) {
        for (const key in this.items) {
            if (!1 === callback(key, this.items[key])) return !1;
        }
        return !0;
    }
    hasValue(value) {
        for (const key in this.items) if (this.items[key].value === value) return !0;
        return !1;
    }
    indexOf(key) {
        return this.has(key) ? this.items[key].index : -1;
    }
    insertAt(index, value, key) {
        const hashV = new HashValue;
        hashV.index = index, hashV.key = key, hashV.value = value, this.itemList.splice(index, 0, hashV), 
        this.items[key] = hashV, this.resetIndex();
    }
    sort(callback) {
        return this.itemList.sort(((a, b) => callback(a.value, b.value)));
    }
    toArray() {
        return this.itemList.slice(0, this.itemList.length).map((vl => vl.value));
    }
    push(lists) {
        lists.foreach(((key, value) => {
            this.set(key, value);
        }));
    }
    mapKey() {
        const returnArr = [];
        for (const key in this.items) returnArr.push(key);
        return returnArr;
    }
    toImmutableMap() {}
}

exports.HashTable = HashTable;