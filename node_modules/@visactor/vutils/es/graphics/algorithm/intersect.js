import { pi2, halfPi, crossProduct, fuzzyEqualVec } from "../../math";

function sub(out, v1, v2) {
    out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
}

let x11, x12, y11, y12, x21, x22, y21, y22;

export function isIntersect(left1, right1, left2, right2) {
    let _temp, min1 = left1[0], max1 = right1[0], min2 = left2[0], max2 = right2[0];
    return max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max2 < min2 && (_temp = max2, 
    max2 = min2, min2 = _temp), !(max1 < min2 || max2 < min1) && (min1 = left1[1], max1 = right1[1], 
    min2 = left2[1], max2 = right2[1], max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), 
    max2 < min2 && (_temp = max2, max2 = min2, min2 = _temp), !(max1 < min2 || max2 < min1));
}

export function getIntersectPoint(left1, right1, left2, right2) {
    if (!isIntersect(left1, right1, left2, right2)) return !1;
    const dir1 = [ 0, 0 ], dir2 = [ 0, 0 ], tempVec = [ 0, 0 ];
    if (sub(dir1, right1, left1), sub(dir2, right2, left2), fuzzyEqualVec(dir1, dir2)) return !0;
    sub(tempVec, left2, left1);
    const t = crossProduct(tempVec, dir2) / crossProduct(dir1, dir2);
    return t >= 0 && t <= 1 && [ left1[0] + dir1[0] * t, left1[1] + dir1[1] * t ];
}

export function getRectIntersect(bbox1, bbox2, format) {
    return null === bbox1 ? bbox2 : null === bbox2 ? bbox1 : (x11 = bbox1.x1, x12 = bbox1.x2, 
    y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, 
    y22 = bbox2.y2, format && (x11 > x12 && ([x11, x12] = [ x12, x11 ]), y11 > y12 && ([y11, y12] = [ y12, y11 ]), 
    x21 > x22 && ([x21, x22] = [ x22, x21 ]), y21 > y22 && ([y21, y22] = [ y22, y21 ])), 
    x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21 ? {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
    } : {
        x1: Math.max(x11, x21),
        y1: Math.max(y11, y21),
        x2: Math.min(x12, x22),
        y2: Math.min(y12, y22)
    });
}

export var InnerBBox;

!function(InnerBBox) {
    InnerBBox[InnerBBox.NONE = 0] = "NONE", InnerBBox[InnerBBox.BBOX1 = 1] = "BBOX1", 
    InnerBBox[InnerBBox.BBOX2 = 2] = "BBOX2";
}(InnerBBox || (InnerBBox = {}));

export function rectInsideAnotherRect(bbox1, bbox2, format) {
    return bbox1 && bbox2 ? (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, 
    x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, format && (x11 > x12 && ([x11, x12] = [ x12, x11 ]), 
    y11 > y12 && ([y11, y12] = [ y12, y11 ]), x21 > x22 && ([x21, x22] = [ x22, x21 ]), 
    y21 > y22 && ([y21, y22] = [ y22, y21 ])), x11 > x21 && x12 < x22 && y11 > y21 && y12 < y22 ? InnerBBox.BBOX1 : x21 > x11 && x22 < x12 && y21 > y11 && y22 < y12 ? InnerBBox.BBOX2 : InnerBBox.NONE) : InnerBBox.NONE;
}

export function isRectIntersect(bbox1, bbox2, format) {
    return !bbox1 || !bbox2 || (format ? (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, 
    y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, 
    x11 > x12 && ([x11, x12] = [ x12, x11 ]), y11 > y12 && ([y11, y12] = [ y12, y11 ]), 
    x21 > x22 && ([x21, x22] = [ x22, x21 ]), y21 > y22 && ([y21, y22] = [ y22, y21 ]), 
    !(x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21)) : !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1));
}

export function pointInRect(point, bbox, format) {
    return !bbox || (format ? (x11 = bbox.x1, x12 = bbox.x2, y11 = bbox.y1, y12 = bbox.y2, 
    x11 > x12 && ([x11, x12] = [ x12, x11 ]), y11 > y12 && ([y11, y12] = [ y12, y11 ]), 
    point.x >= x11 && point.x <= x12 && point.y >= y11 && point.y <= y12) : point.x >= bbox.x1 && point.x <= bbox.x2 && point.y >= bbox.y1 && point.y <= bbox.y2);
}

function getProjectionRadius(checkAxis, axis) {
    return Math.abs(axis[0] * checkAxis[0] + axis[1] * checkAxis[1]);
}

function rotate({x: x, y: y}, deg, origin = {
    x: 0,
    y: 0
}) {
    return {
        x: (x - origin.x) * Math.cos(deg) + (y - origin.y) * Math.sin(deg) + origin.x,
        y: (x - origin.x) * Math.sin(deg) + (origin.y - y) * Math.cos(deg) + origin.y
    };
}

function toDeg(angle) {
    return angle / 180 * Math.PI;
}

function getCenterPoint(box) {
    return {
        x: (box.x1 + box.x2) / 2,
        y: (box.y1 + box.y2) / 2
    };
}

function toRect(box, isDeg) {
    const deg = isDeg ? box.angle : toDeg(box.angle), cp = getCenterPoint(box);
    return [ rotate({
        x: box.x1,
        y: box.y1
    }, deg, cp), rotate({
        x: box.x2,
        y: box.y1
    }, deg, cp), rotate({
        x: box.x2,
        y: box.y2
    }, deg, cp), rotate({
        x: box.x1,
        y: box.y2
    }, deg, cp) ];
}

export function isRotateAABBIntersect(box1, box2, isDeg = !1, ctx) {
    const rect1 = toRect(box1, isDeg), rect2 = toRect(box2, isDeg), vector = (start, end) => [ end.x - start.x, end.y - start.y ];
    ctx && (ctx.save(), ctx.fillStyle = "red", ctx.globalAlpha = .6, rect1.forEach(((item, index) => {
        0 === index ? ctx.moveTo(item.x, item.y) : ctx.lineTo(item.x, item.y);
    })), ctx.fill(), ctx.restore(), ctx.save(), ctx.fillStyle = "green", ctx.globalAlpha = .6, 
    rect2.forEach(((item, index) => {
        0 === index ? ctx.moveTo(item.x, item.y) : ctx.lineTo(item.x, item.y);
    })), ctx.fill(), ctx.restore());
    const p1 = getCenterPoint(box1), p2 = getCenterPoint(box2);
    ctx && ctx.fillRect(p1.x, p1.y, 2, 2), ctx && ctx.fillRect(p2.x, p2.y, 2, 2);
    const vp1p2 = vector(p1, p2), AB = vector(rect1[0], rect1[1]), BC = vector(rect1[1], rect1[2]), A1B1 = vector(rect2[0], rect2[1]), B1C1 = vector(rect2[1], rect2[2]), deg11 = isDeg ? box1.angle : toDeg(box1.angle);
    let deg12 = isDeg ? box1.angle + halfPi : toDeg(90 - box1.angle);
    const deg21 = isDeg ? box2.angle : toDeg(box2.angle);
    let deg22 = isDeg ? box2.angle + halfPi : toDeg(90 - box2.angle);
    deg12 > pi2 && (deg12 -= pi2), deg22 > pi2 && (deg22 -= pi2);
    const isCover = (checkAxisRadius, deg, targetAxis1, targetAxis2) => {
        const checkAxis = [ Math.cos(deg), Math.sin(deg) ];
        return checkAxisRadius + (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2 > getProjectionRadius(checkAxis, vp1p2);
    };
    return isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) && isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) && isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) && isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC);
}
//# sourceMappingURL=intersect.js.map
