import { isArray } from "../common";

import { abs, epsilon } from "../math";

export function transformBoundsWithMatrix(out, bounds, matrix) {
    const {x1: x1, y1: y1, x2: x2, y2: y2} = bounds;
    return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), 
    out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), 
    out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), 
    out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), 
    out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), 
    bounds);
}

export function transformBounds(bounds, x, y, scaleX, scaleY, angle, rotateCenter) {
    if (!(abs(scaleX) <= epsilon || abs(scaleY) <= epsilon)) {
        if (1 !== scaleX && bounds.scaleX(scaleX), 1 !== scaleY && bounds.scaleY(scaleY), 
        isFinite(angle) && Math.abs(angle) > epsilon) {
            let rx = 0, ry = 0;
            void 0 !== rotateCenter && (rx = rotateCenter[0], ry = rotateCenter[1]), bounds.rotate(angle, rx, ry);
        }
        bounds.translate(x, y);
    }
}

export class Bounds {
    constructor(bounds) {
        bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
    }
    clone() {
        return new Bounds(this);
    }
    clear() {
        return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, 
        this.y2 = -Number.MAX_VALUE, this;
    }
    empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
    }
    equals(b) {
        return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
    }
    setValue(x1 = 0, y1 = 0, x2 = 0, y2 = 0) {
        return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
    }
    set(x1 = 0, y1 = 0, x2 = 0, y2 = 0) {
        return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, 
        this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
    }
    add(x = 0, y = 0) {
        return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), 
        y > this.y2 && (this.y2 = y), this;
    }
    expand(d = 0) {
        return isArray(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, 
        this.y1 -= d, this.x2 += d, this.y2 += d), this;
    }
    round() {
        return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), 
        this.y2 = Math.ceil(this.y2), this;
    }
    translate(dx = 0, dy = 0) {
        return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
    }
    rotate(angle = 0, x = 0, y = 0) {
        const p = this.rotatedPoints(angle, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
    }
    scale(sx = 0, sy = 0, x = 0, y = 0) {
        const p = this.scalePoints(sx, sy, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]);
    }
    union(b) {
        return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), 
        b.y2 > this.y2 && (this.y2 = b.y2), this;
    }
    intersect(b) {
        return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), 
        b.y2 < this.y2 && (this.y2 = b.y2), this;
    }
    encloses(b) {
        return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
    }
    alignsWith(b) {
        return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
    }
    intersects(b) {
        return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
    }
    contains(x = 0, y = 0) {
        return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
    }
    containsPoint(p) {
        return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
    }
    width() {
        return this.empty() ? 0 : this.x2 - this.x1;
    }
    height() {
        return this.empty() ? 0 : this.y2 - this.y1;
    }
    scaleX(s = 0) {
        return this.x1 *= s, this.x2 *= s, this;
    }
    scaleY(s = 0) {
        return this.y1 *= s, this.y2 *= s, this;
    }
    transformWithMatrix(matrix) {
        return transformBoundsWithMatrix(this, this, matrix), this;
    }
    copy(b) {
        return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
    }
    rotatedPoints(angle, x, y) {
        const {x1: x1, y1: y1, x2: x2, y2: y2} = this, cos = Math.cos(angle), sin = Math.sin(angle), cx = x - x * cos + y * sin, cy = y - x * sin - y * cos;
        return [ cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy ];
    }
    scalePoints(sx, sy, x, y) {
        const {x1: x1, y1: y1, x2: x2, y2: y2} = this;
        return [ sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y ];
    }
}

export class AABBBounds extends Bounds {}

export class OBBBounds extends Bounds {}
//# sourceMappingURL=bounds.js.map