{"version":3,"sources":["../src/circle-packing/siblings.ts"],"names":[],"mappings":"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","file":"siblings.js","sourcesContent":["import { array } from '@visactor/vutils';\nimport { randomLCG } from '../lcg';\nimport { packEncloseRandom } from './enclose';\nimport type { ICircle } from '../interface';\n\ninterface CircleNode {\n  _: ICircle;\n  next?: CircleNode;\n  prev?: CircleNode;\n}\n\nfunction place(b: ICircle, a: ICircle, c: ICircle) {\n  const dx = b.x - a.x;\n  let x;\n  let a2;\n  const dy = b.y - a.y;\n  let y;\n  let b2;\n  const d2 = dx * dx + dy * dy;\n  if (d2) {\n    a2 = a.radius + c.radius;\n    a2 *= a2;\n    b2 = b.radius + c.radius;\n    b2 *= b2;\n    if (a2 > b2) {\n      x = (d2 + b2 - a2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));\n      c.x = b.x - x * dx - y * dy;\n      c.y = b.y - x * dy + y * dx;\n    } else {\n      x = (d2 + a2 - b2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));\n      c.x = a.x + x * dx - y * dy;\n      c.y = a.y + x * dy + y * dx;\n    }\n  } else {\n    c.x = a.x + c.radius;\n    c.y = a.y;\n  }\n}\n\nfunction intersects(a: ICircle, b: ICircle) {\n  const dr = a.radius + b.radius - 1e-6;\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction score(node: CircleNode) {\n  const a = node._;\n  const b = node.next._;\n  const ab = a.radius + b.radius;\n  const dx = (a.x * b.radius + b.x * a.radius) / ab;\n  const dy = (a.y * b.radius + b.y * a.radius) / ab;\n  return dx * dx + dy * dy;\n}\n\nfunction getCicleNode(circle: ICircle): CircleNode {\n  return {\n    _: circle,\n    next: null as CircleNode,\n    prev: null as CircleNode\n  };\n}\n\nexport function packSiblingsRandom(circles: ICircle[], random: () => number) {\n  circles = array(circles);\n\n  const n = circles.length;\n  if (!n) {\n    return 0;\n  }\n\n  // Place the first circle.\n  let a = circles[0];\n  a.x = 0;\n  a.y = 0;\n  if (n === 1) {\n    return a.radius;\n  }\n\n  // Place the second circle.\n  const b = circles[1];\n  a.x = -b.radius;\n  b.x = a.radius;\n  b.y = 0;\n  if (n === 2) {\n    return a.radius + b.radius;\n  }\n\n  let c = circles[2];\n  // Place the third circle.\n  place(b, a, c);\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  let aNode = getCicleNode(a);\n  let bNode = getCicleNode(b);\n  let cNode = getCicleNode(c);\n  aNode.next = bNode;\n  cNode.prev = bNode;\n\n  bNode.next = cNode;\n  aNode.prev = cNode;\n\n  cNode.next = aNode;\n  bNode.prev = aNode;\n\n  let j: CircleNode;\n  let k: CircleNode;\n  let sj: number;\n  let sk: number;\n  let aa: number;\n  let ca: number;\n  let isContinue: boolean;\n\n  // Attempt to place each remaining circle…\n  for (let i = 3; i < n; ++i) {\n    isContinue = false;\n    c = circles[i];\n    place(aNode._, bNode._, c);\n    cNode = getCicleNode(c);\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    // “Closeness” is determined by linear distance along the front-chain.\n    // “Ahead” or “behind” is likewise determined by linear distance.\n    j = bNode.next;\n    k = aNode.prev;\n    sj = bNode._.radius;\n    sk = aNode._.radius;\n\n    do {\n      if (sj <= sk) {\n        if (intersects(j._, cNode._)) {\n          bNode = j;\n          aNode.next = bNode;\n          bNode.prev = aNode;\n          --i;\n          isContinue = true;\n          break;\n        }\n        sj += j._.radius;\n        j = j.next;\n      } else {\n        if (intersects(k._, cNode._)) {\n          aNode = k;\n          aNode.next = bNode;\n          bNode.prev = aNode;\n          --i;\n\n          isContinue = true;\n          break;\n        }\n        sk += k._.radius;\n        k = k.prev;\n      }\n    } while (j !== k.next);\n\n    if (isContinue) {\n      continue;\n    }\n\n    // Success! Insert the new circle c between a and b.\n    cNode.prev = aNode;\n    cNode.next = bNode;\n    aNode.next = bNode.prev = bNode = cNode;\n\n    // Compute the new closest circle pair to the centroid.\n    aa = score(aNode);\n    cNode = cNode.next;\n    while (cNode !== bNode) {\n      ca = score(cNode);\n      if (ca < aa) {\n        aNode = cNode;\n        aa = ca;\n      }\n      cNode = cNode.next;\n    }\n    bNode = aNode.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  const aCircles = [bNode._];\n  cNode = bNode.next;\n  while (cNode !== bNode) {\n    aCircles.push(cNode._);\n    cNode = cNode.next;\n  }\n  c = packEncloseRandom(aCircles, random);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (let i = 0; i < n; ++i) {\n    a = circles[i];\n    a.x -= c.x;\n    a.y -= c.y;\n  }\n\n  return c.radius;\n}\n\nexport default function (circles: ICircle[]) {\n  packSiblingsRandom(circles, randomLCG());\n  return circles;\n}\n"]}