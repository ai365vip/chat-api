"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.dimensionStatisticsOfSimpleData = exports.dimensionStatistics = void 0;

const vutils_1 = require("@visactor/vutils"), type_1 = require("../../util/type"), data_1 = require("../../util/data"), methods = {
    min: arr => arr.length ? (0, vutils_1.minInArray)(arr.map((n => 1 * n))) : 0,
    max: arr => arr.length ? (0, vutils_1.maxInArray)(arr.map((n => 1 * n))) : 0,
    "array-min": arr => arr.length ? (0, vutils_1.minInArray)(arr.map((n => 1 * n))) : 0,
    "array-max": arr => arr.length ? (0, vutils_1.maxInArray)(arr.map((n => 1 * n))) : 0,
    values: arr => {
        const map = {}, res = [];
        for (const entry of arr) map[entry] || (res.push(entry), map[entry] = 1);
        return res;
    }
}, dimensionStatistics = (data, op) => {
    var _a, _b;
    let fields = op.fields;
    if ((0, vutils_1.isFunction)(fields) && (fields = fields()), !(null == fields ? void 0 : fields.length) || !(null == data ? void 0 : data.length)) return {};
    fields = (0, data_1.mergeFields)([], fields);
    const dataKey = "parser" === op.target ? "parserData" : "latestData", latestData = data[0][dataKey] ? data[0][dataKey] : data || [], dataFields = null === (_b = (_a = data[0]).getFields) || void 0 === _b ? void 0 : _b.call(_a);
    return (0, exports.dimensionStatisticsOfSimpleData)(latestData, fields, dataFields);
};

exports.dimensionStatistics = dimensionStatistics;

const dimensionStatisticsOfSimpleData = (latestData, fields, dataFields) => {
    const result = {};
    let fValues = [], nextFValues = [];
    return fields.forEach((f => {
        const key = f.key;
        result[key] = {};
        const dataFieldInKey = null == dataFields ? void 0 : dataFields[key], operations = f.operations, isNumberField = operations.some((op => "min" === op || "max" === op || "allValid" === op));
        let allValid = !0;
        fValues.length = 0, latestData.forEach((d => {
            d && fValues.push(d[key]);
        }));
        const len = fValues.length;
        if (isNumberField) {
            nextFValues.length = 0, fValues.forEach(((item, i) => {
                (0, type_1.couldBeValidNumber)(item) && nextFValues.push(item);
            }));
            const t = fValues;
            fValues = nextFValues, nextFValues = t, allValid = fValues.length === len;
        } else fValues = operations.some((op => "array-min" === op || "array-max" === op)) ? fValues.reduce(((res, entry) => (entry && entry.forEach((d => {
            (0, type_1.couldBeValidNumber)(d) && res.push(d);
        })), res)), []) : fValues.filter((entry => void 0 !== entry));
        operations.forEach((op => {
            if (f.customize) result[key][op] = f.customize; else {
                if (dataFieldInKey && dataFieldInKey.lockStatisticsByDomain && !(0, vutils_1.isNil)(dataFieldInKey.domain)) {
                    if ("values" === op) return void (result[key][op] = dataFieldInKey.domain.slice());
                } else if ("allValid" === op) return;
                result[key][op] = methods[op](fValues), "array-max" === op && (result[key].max = result[key][op]), 
                "array-min" === op && (result[key].min = result[key][op]);
            }
        })), isNumberField && (result[key].allValid = allValid);
    })), result;
};

exports.dimensionStatisticsOfSimpleData = dimensionStatisticsOfSimpleData;
//# sourceMappingURL=dimension-statistics.js.map
