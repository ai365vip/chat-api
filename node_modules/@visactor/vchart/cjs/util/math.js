"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.distance = exports.vectorAngle = exports.radiusLabelOrientAttribute = exports.regression = exports.median = exports.standardDeviation = exports.variance = exports.average = exports.sum = exports.max = exports.min = exports.outOfBounds = exports.normalizeStartEndAngle = exports.computeQuadrant = exports.polarToCartesian = exports.angleLabelOrientAttribute = exports.normalizeAngle = exports.isLess = exports.isGreater = exports.isClose = void 0;

const type_1 = require("./type"), vgrammar_util_1 = require("@visactor/vgrammar-util"), vutils_1 = require("@visactor/vutils");

Object.defineProperty(exports, "isGreater", {
    enumerable: !0,
    get: function() {
        return vutils_1.isGreater;
    }
}), Object.defineProperty(exports, "isLess", {
    enumerable: !0,
    get: function() {
        return vutils_1.isLess;
    }
});

const vutils_extension_1 = require("@visactor/vutils-extension");

function polarToCartesian(point) {
    return point.radius ? {
        x: Math.cos(point.angle) * point.radius,
        y: Math.sin(point.angle) * point.radius
    } : {
        x: 0,
        y: 0
    };
}

function computeQuadrant(angle) {
    return (angle = (0, vutils_extension_1.normalizeAngle)(angle)) > 0 && angle <= Math.PI / 2 ? 2 : angle > Math.PI / 2 && angle <= Math.PI ? 3 : angle > Math.PI && angle <= 3 * Math.PI / 2 ? 4 : 1;
}

function normalizeStartEndAngle(start, end) {
    let startAngle = 0, endAngle = 2 * Math.PI;
    const isStartValid = (0, vutils_1.isValid)(start), isEndValid = (0, vutils_1.isValid)(end);
    for (isStartValid || isEndValid ? isEndValid ? isStartValid ? (startAngle = start, 
    endAngle = end) : (startAngle = end - 2 * Math.PI, endAngle = end) : (startAngle = start, 
    endAngle = start + 2 * Math.PI) : (startAngle = 0, endAngle = 2 * Math.PI); endAngle <= startAngle; ) endAngle += 2 * Math.PI;
    for (;startAngle > 2 * Math.PI; ) startAngle -= 2 * Math.PI, endAngle -= 2 * Math.PI;
    for (;endAngle < 0; ) startAngle += 2 * Math.PI, endAngle += 2 * Math.PI;
    return {
        startAngle: startAngle,
        endAngle: endAngle
    };
}

function outOfBounds(bounds, x, y) {
    return bounds.x1 > x || bounds.x2 < x || bounds.y1 > y || bounds.y2 < y;
}

function min(data, field) {
    const dataArray = [];
    return data.forEach((d => {
        const value = +d[field];
        (0, type_1.isValidNumber)(value) && dataArray.push(value);
    })), 0 === dataArray.length ? null : (0, vutils_1.minInArray)(dataArray);
}

function max(data, field) {
    const dataArray = [];
    return data.forEach((d => {
        const value = +d[field];
        (0, type_1.isValidNumber)(value) && dataArray.push(value);
    })), 0 === dataArray.length ? null : (0, vutils_1.maxInArray)(dataArray);
}

function sum(data, field) {
    return data.reduce(((pre, _cur) => {
        const cur = field ? +_cur[field] : +_cur;
        return (0, type_1.isValidNumber)(cur) && (pre += cur), pre;
    }), 0);
}

function average(data, field) {
    let sum = 0, count = 0;
    data.forEach((x => {
        const v = field ? +x[field] : +x;
        (0, type_1.isValidNumber)(v) && (sum += v, count++);
    }));
    return sum / count;
}

function variance(data, field) {
    const averageNumber = average(data, field);
    if (data.length <= 1) return 0;
    const total = data.reduce(((sum, cur) => sum + (field ? +cur[field] : +cur - averageNumber) ** 2), 0);
    return total / (data.length - 1);
}

function standardDeviation(data, field) {
    return Math.sqrt(variance(data, field));
}

function median(data, field) {
    return (0, vutils_1.median)(data.map((datum => datum[field])));
}

function regression(data, fieldX, fieldY) {
    const {predict: predict} = (0, vgrammar_util_1.regressionLinear)(data, (datum => datum[fieldX]), (datum => datum[fieldY])), x1 = min(data, fieldX), x2 = max(data, fieldX), predict1 = predict(x1), predict2 = predict(x2);
    return [ {
        [fieldX]: x1,
        [fieldY]: predict1
    }, {
        [fieldX]: x2,
        [fieldY]: predict2
    } ];
}

function radiusLabelOrientAttribute(angle) {
    let align = "center", baseline = "middle";
    return align = (angle = (0, vutils_extension_1.normalizeAngle)(angle)) >= Math.PI * (7 / 6) && angle <= Math.PI * (11 / 6) ? "right" : angle >= Math.PI * (1 / 6) && angle <= Math.PI * (5 / 6) ? "left" : "center", 
    baseline = angle >= Math.PI * (5 / 3) || angle <= Math.PI * (1 / 3) ? "bottom" : angle >= Math.PI * (2 / 3) && angle <= Math.PI * (4 / 3) ? "top" : "middle", 
    {
        align: align,
        baseline: baseline
    };
}

function vectorAngle(v1, v2) {
    const v1Length = distance(v1), v2Length = distance(v2), rho = Math.asin((v1.x * v2.y - v2.x * v1.y) / v1Length / v2Length), theta = Math.acos((v1.x * v2.x + v1.y * v2.y) / v1Length / v2Length);
    return rho < 0 ? -theta : theta;
}

function distance(p1, p2 = {
    x: 0,
    y: 0
}) {
    return vutils_1.PointService.distancePP(p1, p2);
}

Object.defineProperty(exports, "normalizeAngle", {
    enumerable: !0,
    get: function() {
        return vutils_extension_1.normalizeAngle;
    }
}), Object.defineProperty(exports, "angleLabelOrientAttribute", {
    enumerable: !0,
    get: function() {
        return vutils_extension_1.angleLabelOrientAttribute;
    }
}), exports.isClose = vutils_1.isNumberClose, exports.polarToCartesian = polarToCartesian, 
exports.computeQuadrant = computeQuadrant, exports.normalizeStartEndAngle = normalizeStartEndAngle, 
exports.outOfBounds = outOfBounds, exports.min = min, exports.max = max, exports.sum = sum, 
exports.average = average, exports.variance = variance, exports.standardDeviation = standardDeviation, 
exports.median = median, exports.regression = regression, exports.radiusLabelOrientAttribute = radiusLabelOrientAttribute, 
exports.vectorAngle = vectorAngle, exports.distance = distance;
//# sourceMappingURL=math.js.map
