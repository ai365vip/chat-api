"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getActualNumValue = exports.convertPoint = exports.normalizeLayoutPaddingSpec = exports.boundsInRect = exports.calcPadding = exports.calcLayoutNumber = exports.isPercentOffset = exports.isPercent = exports.isValidOrient = void 0;

const vutils_1 = require("@visactor/vutils"), type_1 = require("./type");

function isValidOrient(orient) {
    switch (orient) {
      case "left":
      case "right":
      case "top":
      case "bottom":
        return !0;

      default:
        return !1;
    }
}

function isPercent(v) {
    return !!(0, type_1.isString)(v) && (!!v.endsWith("%") && (0, type_1.couldBeValidNumber)(v.substring(0, v.length - 1)));
}

function isPercentOffset(v) {
    return !!(0, type_1.isObject)(v) && ("percent" in v || "offset" in v);
}

function calcLayoutNumber(v, size, callOp) {
    var _a, _b;
    return (0, type_1.isNumber)(v) ? v : isPercent(v) ? Number(v.substring(0, v.length - 1)) * size / 100 : (0, 
    type_1.isFunction)(v) ? v(callOp) : (0, type_1.isObject)(v) ? size * (null !== (_a = v.percent) && void 0 !== _a ? _a : 0) + (null !== (_b = v.offset) && void 0 !== _b ? _b : 0) : 0;
}

function calcPadding(paddingSpec, rect, callOp) {
    var _a, _b, _c, _d;
    const result = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
    };
    if (Object.values(paddingSpec).every((value => (0, type_1.isNumber)(value)))) return result.top = null !== (_a = paddingSpec.top) && void 0 !== _a ? _a : 0, 
    result.right = null !== (_b = paddingSpec.right) && void 0 !== _b ? _b : 0, result.bottom = null !== (_c = paddingSpec.bottom) && void 0 !== _c ? _c : 0, 
    result.left = null !== (_d = paddingSpec.left) && void 0 !== _d ? _d : 0, result;
    return [ {
        orients: [ "left", "right" ],
        size: rect.width
    }, {
        orients: [ "top", "bottom" ],
        size: rect.height
    } ].forEach((p => {
        p.orients.forEach((o => {
            result[o] = calcLayoutNumber(paddingSpec[o], p.size, callOp);
        }));
    })), result;
}

function boundsInRect(bounds, rect) {
    return bounds ? {
        width: Math.ceil(Math.min(bounds.x2 - bounds.x1, rect.width)),
        height: Math.ceil(Math.min(bounds.y2 - bounds.y1, rect.height))
    } : {
        width: 0,
        height: 0
    };
}

function normalizeLayoutPaddingSpec(spec) {
    let result = {};
    return (0, vutils_1.isArray)(spec) ? ((0, type_1.isNil)(spec[0]) || (result.top = result.left = result.bottom = result.right = spec[0]), 
    (0, type_1.isNil)(spec[1]) || (result.left = result.right = spec[1]), (0, type_1.isNil)(spec[2]) || (result.bottom = spec[2]), 
    (0, type_1.isNil)(spec[3]) || (result.left = spec[3]), result) : (0, type_1.isNumber)(spec) || isPercent(spec) || (0, 
    type_1.isFunction)(spec) || isPercentOffset(spec) ? (result.top = result.left = result.bottom = result.right = spec, 
    result) : (0, type_1.isObject)(spec) ? (result = Object.assign({}, spec), result) : result;
}

function convertPoint(point, relativePoint, convert) {
    return convert ? {
        x: point.x + relativePoint.x,
        y: point.y + relativePoint.y
    } : point;
}

exports.isValidOrient = isValidOrient, exports.isPercent = isPercent, exports.isPercentOffset = isPercentOffset, 
exports.calcLayoutNumber = calcLayoutNumber, exports.calcPadding = calcPadding, 
exports.boundsInRect = boundsInRect, exports.normalizeLayoutPaddingSpec = normalizeLayoutPaddingSpec, 
exports.convertPoint = convertPoint;

const getActualNumValue = (originValue, total) => {
    const originNumValue = Number(originValue), originStrValue = originValue.toString();
    return isNaN(originNumValue) && "%" === originStrValue[originStrValue.length - 1] ? total * (Number(originStrValue.slice(0, originStrValue.length - 1)) / 100) : originNumValue;
};

exports.getActualNumValue = getActualNumValue;
//# sourceMappingURL=space.js.map
