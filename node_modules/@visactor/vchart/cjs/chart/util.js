"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getTrimPaddingConfig = exports.mergeUpdateResult = exports.calculateChartSize = exports.setDefaultCrosshairForCartesianChart = void 0;

const vutils_1 = require("@visactor/vutils"), typings_1 = require("../typings"), util_1 = require("../util");

function setDefaultCrosshairForCartesianChart(spec) {
    spec.crosshair = (0, util_1.array)(spec.crosshair || {}).map((crosshairCfg => (0, 
    util_1.mergeSpec)({
        [spec.direction === typings_1.Direction.horizontal ? "yField" : "xField"]: {
            visible: !0,
            line: {
                visible: !0,
                type: "rect"
            }
        }
    }, crosshairCfg)));
}

function calculateChartSize(spec, option, defaultSize) {
    var _a;
    const {width: userWidth, height: userHeight} = spec;
    if ((0, util_1.isValid)(userWidth) && (0, util_1.isValid)(userHeight)) return {
        width: userWidth,
        height: userHeight
    };
    let width = defaultSize.width, height = defaultSize.height;
    const container = option.container, canvas = option.canvas;
    if (container) {
        const {width: containerWidth, height: containerHeight} = (0, vutils_1.getContainerSize)(container, defaultSize.width, defaultSize.height);
        width = containerWidth, height = containerHeight;
    } else if (canvas && (0, util_1.isTrueBrowser)(option.mode)) {
        let canvasNode;
        canvasNode = (0, vutils_1.isString)(canvas) ? null === document || void 0 === document ? void 0 : document.getElementById(canvas) : canvas;
        const {width: containerWidth, height: containerHeight} = (0, vutils_1.getContainerSize)(canvasNode, defaultSize.width, defaultSize.height);
        width = containerWidth, height = containerHeight;
    } else if ((0, util_1.isMiniAppLikeMode)(option.mode) && (null === (_a = option.modeParams) || void 0 === _a ? void 0 : _a.domref)) {
        const domRef = option.modeParams.domref;
        width = domRef.width, height = domRef.height;
    }
    return width = null != userWidth ? userWidth : width, height = null != userHeight ? userHeight : height, 
    {
        width: width,
        height: height
    };
}

function mergeUpdateResult(target, ...sources) {
    const merge = key => sources.reduce(((value, cur) => value || (null == cur ? void 0 : cur[key])), target[key]);
    return Object.assign(target, {
        change: merge("change"),
        reCompile: merge("reCompile"),
        reMake: merge("reMake"),
        reRender: merge("reRender"),
        reSize: merge("reSize")
    }), target;
}

function getTrimPaddingConfig(chartType, spec) {
    return "line" === chartType || "area" === chartType || "common" === chartType && spec.series.every((item => "area" === item.type || "line" === item.type)) ? {
        paddingInner: 1,
        paddingOuter: 0
    } : {
        paddingOuter: 0
    };
}

exports.setDefaultCrosshairForCartesianChart = setDefaultCrosshairForCartesianChart, 
exports.calculateChartSize = calculateChartSize, exports.mergeUpdateResult = mergeUpdateResult, 
exports.getTrimPaddingConfig = getTrimPaddingConfig;
//# sourceMappingURL=util.js.map