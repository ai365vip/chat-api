"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LinearProgressChartSpecTransformer = void 0;

const vutils_1 = require("@visactor/vutils"), cartesian_1 = require("../../cartesian"), util_1 = require("../../../component/axis/util");

class LinearProgressChartSpecTransformer extends cartesian_1.CartesianChartSpecTransformer {
    needAxes() {
        return !1;
    }
    _getDefaultSeriesSpec(spec) {
        var _a, _b;
        const series = super._getDefaultSeriesSpec(spec);
        return Object.assign(Object.assign({}, series), {
            direction: null !== (_a = spec.direction) && void 0 !== _a ? _a : "horizontal",
            cornerRadius: null !== (_b = spec.cornerRadius) && void 0 !== _b ? _b : 0,
            bandWidth: spec.bandWidth,
            progress: spec.progress,
            track: spec.track
        });
    }
    transformSpec(spec) {
        var _a, _b;
        if (super.transformSpec(spec), spec.axes || (spec.axes = []), "vertical" === spec.direction) {
            let leftAxis = null, bottomAxis = null;
            (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis => {
                const {orient: orient} = axis;
                "left" === orient && (leftAxis = axis), "bottom" === orient && (bottomAxis = axis);
            })), leftAxis || (leftAxis = {
                orient: "left",
                visible: !1
            }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
                orient: "bottom",
                visible: !1
            }, spec.axes.push(bottomAxis)), (0, vutils_1.isNil)(bottomAxis.type) && (bottomAxis.type = "band"), 
            (0, vutils_1.isNil)(leftAxis.type) && (leftAxis.type = "linear");
            const domain = (0, util_1.getLinearAxisSpecDomain)(leftAxis, {
                min: 0,
                max: 1
            });
            (0, vutils_1.isNil)(leftAxis.min) && (leftAxis.min = domain.min), (0, vutils_1.isNil)(leftAxis.max) && (leftAxis.max = domain.max);
        } else {
            let leftAxis = null, bottomAxis = null;
            (null !== (_b = spec.axes) && void 0 !== _b ? _b : []).forEach((axis => {
                const {orient: orient} = axis;
                "left" === orient && (leftAxis = axis), "bottom" === orient && (bottomAxis = axis);
            })), leftAxis || (leftAxis = {
                type: "band",
                orient: "left",
                visible: !1
            }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
                orient: "bottom",
                visible: !1
            }, spec.axes.push(bottomAxis)), (0, vutils_1.isNil)(bottomAxis.type) && (bottomAxis.type = "linear"), 
            (0, vutils_1.isNil)(leftAxis.type) && (leftAxis.type = "band");
            const domain = (0, util_1.getLinearAxisSpecDomain)(bottomAxis, {
                min: 0,
                max: 1
            });
            (0, vutils_1.isNil)(bottomAxis.min) && (bottomAxis.min = domain.min), (0, vutils_1.isNil)(bottomAxis.max) && (bottomAxis.max = domain.max);
        }
    }
}

exports.LinearProgressChartSpecTransformer = LinearProgressChartSpecTransformer;
//# sourceMappingURL=linear-progress-transformer.js.map
