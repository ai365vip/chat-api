"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.GaugeChartSpecTransformer = void 0;

const vutils_1 = require("@visactor/vutils"), interface_1 = require("../../series/interface"), polar_1 = require("../polar"), constant_1 = require("../../constant");

class GaugeChartSpecTransformer extends polar_1.ProgressLikeChartSpecTransformer {
    _getDefaultSeriesSpec(spec) {
        const series = super._getDefaultSeriesSpec(spec);
        return Object.assign(Object.assign({}, series), {
            radiusField: spec.radiusField,
            pin: spec.pin,
            pinBackground: spec.pinBackground,
            pointer: spec.pointer
        });
    }
    _getDefaultCircularProgressSeriesSpec(spec) {
        return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
            type: interface_1.SeriesTypeEnum.circularProgress
        });
    }
    transformSpec(spec) {
        var _a, _b, _c, _d, _e;
        super.transformSpec(spec);
        let backgroundSeries = null === (_a = spec.series) || void 0 === _a ? void 0 : _a.find((series => series.type === interface_1.SeriesTypeEnum.gauge || series.type === interface_1.SeriesTypeEnum.circularProgress));
        (0, vutils_1.isNil)(backgroundSeries) && (backgroundSeries = null !== (_b = spec.gauge) && void 0 !== _b ? _b : this._getDefaultCircularProgressSeriesSpec(spec), 
        "circularProgress" === backgroundSeries.type && ((0, vutils_1.isNil)(backgroundSeries.radiusField) && (0, 
        vutils_1.isNil)(backgroundSeries.categoryField) && (backgroundSeries.radiusField = null !== (_d = null !== (_c = spec.radiusField) && void 0 !== _c ? _c : spec.categoryField) && void 0 !== _d ? _d : spec.seriesField), 
        (0, vutils_1.isNil)(backgroundSeries.valueField) && (0, vutils_1.isNil)(backgroundSeries.angleField) && (backgroundSeries.valueField = null !== (_e = spec.valueField) && void 0 !== _e ? _e : spec.angleField)), 
        1 === spec.series.length ? spec.series.push(backgroundSeries) : spec.series.forEach((s => {
            s.type === backgroundSeries.type && Object.keys(backgroundSeries).forEach((k => {
                k in s || (s[k] = backgroundSeries[k]);
            }));
        }))), backgroundSeries.type === interface_1.SeriesTypeEnum.circularProgress ? this._transformProgressAxisSpec(spec, {
            orient: "angle",
            visible: !0,
            domainLine: {
                visible: !1
            },
            grid: {
                visible: !1
            }
        }, {
            orient: "radius",
            visible: !1
        }, {
            zIndex: constant_1.LayoutZIndex.Region + 50
        }) : this._transformGaugeAxisSpec(spec);
    }
    _transformGaugeAxisSpec(spec) {
        var _a;
        spec.axes || (spec.axes = []);
        const axesPtr = {
            radius: null,
            angle: null
        };
        (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis => {
            const {orient: orient} = axis;
            "radius" === orient && (axesPtr.radius = axis), "angle" === orient && (axesPtr.angle = axis);
        })), axesPtr.angle || (axesPtr.angle = {
            orient: "angle",
            visible: !0
        }, spec.axes.push(axesPtr.angle)), axesPtr.radius || (axesPtr.radius = {
            orient: "radius",
            visible: !1
        }, spec.axes.push(axesPtr.radius)), (0, vutils_1.isNil)(axesPtr.angle.type) && (axesPtr.angle.type = "linear"), 
        (0, vutils_1.isNil)(axesPtr.radius.type) && (axesPtr.radius.type = "linear"), (0, 
        vutils_1.isNil)(axesPtr.angle.zIndex) && (axesPtr.angle.zIndex = constant_1.LayoutZIndex.Region + 50);
    }
}

exports.GaugeChartSpecTransformer = GaugeChartSpecTransformer;
//# sourceMappingURL=gauge-transformer.js.map
