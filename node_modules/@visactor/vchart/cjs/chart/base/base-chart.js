"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseChart = void 0;

const data_1 = require("../chart-meta/data"), global_scale_1 = require("../../scale/global-scale"), interface_1 = require("../../component/interface"), interface_2 = require("../../mark/interface"), factory_1 = require("../../core/factory"), event_1 = require("../../event/event"), util_1 = require("../../util"), stack_1 = require("../stack"), base_model_1 = require("../../model/base-model"), base_mark_1 = require("../../mark/base/base-mark"), base_1 = require("../../constant/base"), vutils_1 = require("@visactor/vutils"), util_2 = require("../../theme/color-scheme/util"), compilable_base_1 = require("../../compile/compilable-base"), interface_3 = require("../../compile/mark/interface"), constant_1 = require("../../constant"), dimension_1 = require("../../event/events/dimension"), util_3 = require("../util"), vscale_1 = require("@visactor/vscale"), initialize_1 = require("../../data/initialize");

class BaseChart extends compilable_base_1.CompilableBase {
    getSpec() {
        return this._spec;
    }
    setSpec(s) {
        this._spec = s;
    }
    getOption() {
        return this._option;
    }
    getLayoutRect() {
        return this._layoutRect;
    }
    getViewRect() {
        return this._viewRect;
    }
    getLayoutTag() {
        return this._layoutTag;
    }
    setLayoutTag(tag, morphConfig, reLayout = !0) {
        var _a;
        return this._layoutTag = tag, (null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView()) && (this.getCompiler().getVGrammarView().updateLayoutTag(), 
        tag && reLayout && this.getCompiler().renderAsync(morphConfig)), this._layoutTag;
    }
    getEvent() {
        return this._event;
    }
    get chartData() {
        return this._chartData;
    }
    constructor(spec, option) {
        var _a, _b, _c, _d;
        super(option), this.type = "chart", this.id = (0, util_1.createID)(), this._regions = [], 
        this._series = [], this._components = [], this._layoutRect = {
            x: 0,
            y: 0,
            width: base_1.DEFAULT_CHART_WIDTH,
            height: base_1.DEFAULT_CHART_HEIGHT
        }, this._viewRect = {
            width: base_1.DEFAULT_CHART_WIDTH,
            height: base_1.DEFAULT_CHART_HEIGHT
        }, this._viewBox = {
            x1: 0,
            y1: 0,
            x2: base_1.DEFAULT_CHART_WIDTH,
            y2: base_1.DEFAULT_CHART_HEIGHT
        }, this._layoutTag = !0, this._idMap = new Map, this.state = {
            layoutUpdateRank: 1
        }, this.padding = {
            top: 0,
            left: 0,
            right: 0,
            bottom: 0
        }, this.getAllSeries = () => {
            var _a;
            return null !== (_a = this._series) && void 0 !== _a ? _a : [];
        }, this.getRegionsInIndex = index => index && 0 !== index.length ? this._regions.filter(((_r, i) => index.includes(i))) : [ this._regions[0] ], 
        this.getAllRegions = () => this._regions, this.getRegionsInIds = ids => ids ? this._regions.filter((r => ids.includes(r.id))) : [], 
        this.getRegionsInQuerier = region => region ? this._regions.filter(((r, index) => (0, 
        util_1.array)(region).some((regionFilter => (0, util_1.isValid)(regionFilter.regionId) && regionFilter.regionId === r.userId || regionFilter.regionIndex === index)))) : this._regions, 
        this.getRegionsInUserId = userId => {
            if (userId) return this._regions.find((r => r.userId === userId));
        }, this.getRegionsInUserIdOrIndex = (user_ids, index) => this.getAllRegions().filter((r => (null == user_ids ? void 0 : user_ids.length) ? r.userId && user_ids.includes(r.userId) : !(null == index ? void 0 : index.length) || index.includes(r.getSpecIndex()))), 
        this.getComponents = () => this._components, this.getSeriesInIndex = index => index && 0 !== index.length ? this._series.filter(((_r, i) => index.includes(i))) : [ this._series[0] ], 
        this.getSeriesInIds = ids => ids ? this._series.filter((r => ids.includes(r.id))) : [], 
        this.getSeriesInUserId = userId => {
            if (userId) return this._series.find((r => r.userId === userId));
        }, this.getSeriesInUserIdOrIndex = (user_ids, index) => this.getAllSeries().filter((s => (null == user_ids ? void 0 : user_ids.length) ? s.userId && user_ids.includes(s.userId) : !(null == index ? void 0 : index.length) || index.includes(s.getSpecIndex()))), 
        this.getComponentByIndex = (key, index) => {
            const components = this._components.filter((c => (c.specKey || c.type) === key));
            if (components && 0 !== components.length) return components[index];
        }, this.getComponentsByKey = key => this._components.filter((c => (c.specKey || c.type) === key)), 
        this.getComponentByUserId = userId => {
            const component = this._components.find((s => s.userId === userId));
            if (component) return component;
        }, this._paddingSpec = (0, util_1.normalizeLayoutPaddingSpec)(null !== (_a = spec.padding) && void 0 !== _a ? _a : option.getTheme().padding), 
        this._event = new event_1.Event(option.eventDispatcher, option.mode), this._dataSet = option.dataSet, 
        this._chartData = new data_1.ChartData(this._dataSet, null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError), 
        this._modelOption = Object.assign(Object.assign({}, option), {
            mode: this._option.mode,
            map: this._idMap,
            getChartLayoutRect: () => this._layoutRect,
            getChartViewRect: () => this._viewRect,
            getChart: () => this,
            globalScale: this._globalScale,
            onError: null === (_c = this._option) || void 0 === _c ? void 0 : _c.onError,
            disableTriggerEvent: !0 === (null === (_d = this._option) || void 0 === _d ? void 0 : _d.disableTriggerEvent),
            getSeriesData: this._chartData.getSeriesData.bind(this._chartData)
        }), this._spec = spec;
    }
    created() {
        this._transformer = new this.transformerConstructor({
            type: this.type,
            seriesType: this.seriesType,
            getTheme: this._option.getTheme,
            animation: this._option.animation
        }), this._chartData.parseData(this._spec.data), this._createGlobalScale(), this._spec.background && "object" == typeof this._spec.background && this._createBackground(), 
        this._createLayout(), this._transformer.forEachRegionInSpec(this._spec, this._createRegion.bind(this)), 
        this._transformer.forEachSeriesInSpec(this._spec, this._createSeries.bind(this)), 
        this._transformer.forEachComponentInSpec(this._spec, this._createComponent.bind(this), this._option.getSpecInfo());
    }
    init() {
        this._regions.forEach((r => r.init({}))), this._series.forEach((s => s.init({}))), 
        this._components.forEach((c => c.init({
            dataSet: this._dataSet
        }))), this._initEvent(), this._canStack && (this._stack = new stack_1.Stack(this), 
        this._stack.init()), this.reDataFlow();
    }
    reDataFlow() {
        this._series.forEach((s => {
            var _a;
            return null === (_a = s.getRawData()) || void 0 === _a ? void 0 : _a.markRunning();
        })), this._series.forEach((s => s.fillData())), this.updateGlobalScaleDomain();
    }
    onResize(width, height, reRender = !0) {
        const canvasRect = {
            width: width,
            height: height
        };
        this._canvasRect = canvasRect, this._updateLayoutRect(this._option.viewBox), this.setLayoutTag(!0, null, reRender);
    }
    updateViewBox(viewBox, reLayout) {
        this._option.viewBox = viewBox, this._updateLayoutRect(viewBox), this.setLayoutTag(!0, null, reLayout);
    }
    _createBackground() {
        const backgroundStyle = (0, util_1.convertBackgroundSpec)(this._spec.background);
        backgroundStyle && (this._backgroundMark = factory_1.Factory.createMark(interface_2.MarkTypeEnum.group, "chart-background", {
            model: this,
            map: this._option.map,
            getCompiler: this.getCompiler,
            globalScale: this._globalScale
        }), this._backgroundMark.created(), this._backgroundMark.setStyle(Object.assign(Object.assign({}, backgroundStyle), {
            x: () => this._viewBox.x1,
            y: () => this._viewBox.y1,
            width: () => this._viewBox.x2 - this._viewBox.x1,
            height: () => this._viewBox.y2 - this._viewBox.y1
        })));
    }
    _createRegion(constructor, specInfo) {
        if (!constructor) return;
        const {spec: spec} = specInfo, others = __rest(specInfo, [ "spec" ]), region = new constructor(spec, Object.assign(Object.assign({}, this._modelOption), others));
        region && (region.created(), this._regions.push(region));
    }
    _createSeries(constructor, specInfo) {
        if (!constructor) return;
        const {spec: spec} = specInfo, others = __rest(specInfo, [ "spec" ]);
        let region;
        if ((0, util_1.isValid)(spec.regionId) ? region = this.getRegionsInUserId(spec.regionId) : (0, 
        util_1.isValid)(spec.regionIndex) && (region = this.getRegionsInIndex([ spec.regionIndex ])[0]), 
        !region && !(region = this._regions[0])) return;
        const series = new constructor(spec, Object.assign(Object.assign(Object.assign({}, this._modelOption), others), {
            type: spec.type,
            region: region,
            globalScale: this._globalScale,
            sourceDataList: this._chartData.dataList
        }));
        series && (series.created(), this._series.push(series), region.addSeries(series));
    }
    getSeriesById(id) {
        return this._series.find((x => x.id === id));
    }
    _createComponent(constructor, specInfo) {
        const component = constructor.createComponent(specInfo, Object.assign(Object.assign({}, this._modelOption), {
            type: constructor.type,
            getAllRegions: this.getAllRegions,
            getRegionsInIndex: this.getRegionsInIndex,
            getRegionsInIds: this.getRegionsInIds,
            getRegionsInUserIdOrIndex: this.getRegionsInUserIdOrIndex,
            getAllSeries: this.getAllSeries,
            getSeriesInIndex: this.getSeriesInIndex,
            getSeriesInIds: this.getSeriesInIds,
            getSeriesInUserIdOrIndex: this.getSeriesInUserIdOrIndex,
            getAllComponents: this.getComponents,
            getComponentByIndex: this.getComponentByIndex,
            getComponentByUserId: this.getComponentByUserId,
            getComponentsByKey: this.getComponentsByKey
        }));
        component && (component.created(), this._components.push(component));
    }
    getAllComponents() {
        return this._components;
    }
    getAllModels() {
        return [].concat(this.getAllSeries(), this.getAllComponents(), this.getAllRegions());
    }
    getModelInFilter(filter) {
        if ((0, vutils_1.isString)(filter)) return this.getAllModels().find((m => m.userId === filter));
        if ((0, vutils_1.isFunction)(filter)) return this.getAllModels().find((m => filter(m)));
        let index = 0;
        return this.getAllModels().find((m => {
            var _a;
            if ((null !== (_a = m.specKey) && void 0 !== _a ? _a : m.type) === filter.type) {
                if (index === filter.index) return !0;
                index++;
            }
            return !1;
        }));
    }
    _createLayout() {
        this._updateLayoutRect(this._option.viewBox), this._initLayoutFunc();
    }
    setLayout(layout) {
        this._option.layout = layout, this._initLayoutFunc();
    }
    _initLayoutFunc() {
        var _a, _b, _c;
        if (this._layoutFunc = this._option.layout, !this._layoutFunc) {
            let use3dLayout = !1;
            (this._spec.zField || this._spec.series && this._spec.series.some((s => s.zField))) && (use3dLayout = !0);
            const constructor = factory_1.Factory.getLayoutInKey(null !== (_b = null === (_a = this._spec.layout) || void 0 === _a ? void 0 : _a.type) && void 0 !== _b ? _b : use3dLayout ? "layout3d" : "base");
            if (constructor) {
                const layout = new constructor(this._spec.layout, {
                    onError: null === (_c = this._option) || void 0 === _c ? void 0 : _c.onError
                });
                this._layoutFunc = layout.layoutItems.bind(layout);
            }
        }
    }
    layout(params) {
        var _a, _b, _c, _d;
        if (null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeLayoutWithSceneGraph) || void 0 === _b || _b.call(_a), 
        this.getLayoutTag()) {
            this._event.emit(constant_1.ChartEvent.layoutStart, {
                chart: this
            }), this.onLayoutStart(params);
            const elements = this.getLayoutElements();
            this._layoutFunc(this, elements, this._layoutRect, this._viewBox), this._event.emit(constant_1.ChartEvent.afterLayout, {
                elements: elements
            }), this.setLayoutTag(!1), this.onLayoutEnd(params), this._event.emit(constant_1.ChartEvent.layoutEnd, {
                chart: this
            });
        }
        null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterLayoutWithSceneGraph) || void 0 === _d || _d.call(_c);
    }
    onLayoutStart(option) {
        this.getAllModels().forEach((element => element.onLayoutStart(this._layoutRect, this._viewRect, option)));
    }
    onLayoutEnd(option) {
        this.getAllModels().forEach((element => element.onLayoutEnd(option)));
    }
    onEvaluateEnd(option) {
        [ ...this._components, ...this._regions, ...this._series ].forEach((element => element.onEvaluateEnd(option)));
    }
    getLayoutElements() {
        return this.getAllModels().map((i => i.layout)).filter((i => !!i));
    }
    getModelById(id) {
        const model = this._idMap.get(id);
        if (model && model instanceof base_model_1.BaseModel) return model;
    }
    getModelByUserId(userId) {
        const series = this._series.find((s => s.userId === userId));
        if (series) return series;
        const region = this._regions.find((s => s.userId === userId));
        if (region) return region;
        const component = this._components.find((s => s.userId === userId));
        return component || void 0;
    }
    getAllMarks() {
        return Array.from(this._idMap.values()).filter((item => item && item instanceof base_mark_1.BaseMark));
    }
    getMarkById(id) {
        const mark = this._idMap.get(id);
        if (mark && mark instanceof base_mark_1.BaseMark) return mark;
    }
    updateData(id, data, updateGlobalScale = !0, options) {
        const dv = this._dataSet.getDataView(id);
        dv && (dv.markRunning(), dv.parseNewData(data, options)), updateGlobalScale && this.updateGlobalScaleDomain(), 
        this.getAllModels().forEach((model => model.onDataUpdate()));
    }
    updateFullData(data, updateGlobalScale = !0) {
        (0, util_1.array)(data).forEach((d => {
            const dv = this._dataSet.getDataView(d.id);
            dv && dv.markRunning();
        })), (0, util_1.array)(data).forEach((d => {
            const dv = this._dataSet.getDataView(d.id);
            dv && (0, initialize_1.updateDataViewInData)(dv, d, !0);
        })), updateGlobalScale && this.updateGlobalScaleDomain(), this.getAllModels().forEach((model => model.onDataUpdate()));
    }
    onRender(option) {}
    setCanvasRect(width, height) {
        this._canvasRect = {
            width: width,
            height: height
        };
    }
    getCanvasRect() {
        return this._canvasRect || (this._canvasRect = (0, util_3.calculateChartSize)(this._spec, this._option, {
            width: base_1.DEFAULT_CHART_WIDTH,
            height: base_1.DEFAULT_CHART_HEIGHT
        })), this._canvasRect;
    }
    getSeriesData(id, index) {
        return this._chartData.getSeriesData(id, index);
    }
    _transformSpecScale() {
        var _a, _b;
        const scales = null !== (_a = this._spec.scales) && void 0 !== _a ? _a : [];
        let colorScaleSpec = scales.find((s => "color" === s.id));
        const colorScheme = this.getColorScheme();
        if (!colorScaleSpec && (colorScaleSpec = {
            type: "ordinal",
            id: "color",
            domain: null,
            range: null
        }, scales.push(colorScaleSpec), this._spec.color)) {
            const colorSpec = this._spec.color;
            if ((0, util_1.isArray)(colorSpec)) colorScaleSpec.range = colorSpec; else {
                const tempSpec = colorSpec;
                Object.prototype.hasOwnProperty.call(tempSpec, "type") && (colorScaleSpec.type = tempSpec.type), 
                Object.prototype.hasOwnProperty.call(tempSpec, "domain") && (colorScaleSpec.domain = tempSpec.domain), 
                Object.prototype.hasOwnProperty.call(tempSpec, "range") && (colorScaleSpec.range = tempSpec.range), 
                Object.prototype.hasOwnProperty.call(tempSpec, "specified") && (colorScaleSpec.specified = tempSpec.specified);
            }
        }
        return (null === (_b = colorScaleSpec.range) || void 0 === _b ? void 0 : _b.length) || (colorScaleSpec.range = (0, 
        util_2.getDataScheme)(colorScheme), colorScaleSpec.rangeTheme = !0), scales;
    }
    _createGlobalScale() {
        this._globalScale = new global_scale_1.GlobalScale(this._transformSpecScale(), this), 
        this._modelOption.globalScale = this._globalScale;
    }
    updateGlobalScaleDomain() {
        const domainSet = new Set;
        this._series.forEach((s => {
            const keys = s.getSeriesKeys();
            keys && keys.forEach((k => domainSet.add(k)));
        }));
        const domain = Array.from(domainSet);
        this._globalScale.updateScaleDomain(domain);
    }
    updateGlobalScale(result) {
        (0, util_3.mergeUpdateResult)(result, this._globalScale.updateSpec(this._transformSpecScale()));
    }
    updateGlobalScaleTheme() {
        const colorSpec = this._globalScale.getScaleSpec("color"), colorScheme = this.getColorScheme();
        colorSpec.rangeTheme && (colorSpec.range = (0, util_2.getDataScheme)(colorScheme), 
        this._globalScale.getScale("color").range(colorSpec.range));
    }
    updateSpec(spec) {
        const result = {
            change: !1,
            reMake: !1,
            reRender: !1,
            reSize: !1,
            reCompile: !1
        };
        if (this.setLayoutTag(!0, null, !1), spec.type !== this.type) return result.reMake = !0, 
        result;
        const currentKeys = Object.keys(this._spec).sort(), nextKeys = Object.keys(spec).sort();
        if (JSON.stringify(currentKeys) !== JSON.stringify(nextKeys)) return result.reMake = !0, 
        result;
        const oldSpec = this._spec;
        return this._spec = spec, this.updateChartConfig(result, oldSpec), result.reMake ? result : (this.updateGlobalScale(result), 
        result.reMake ? result : (this.updateRegionSpec(result), result.reMake ? result : (this.updateComponentSpec(result), 
        result.reMake ? result : (this.updateSeriesSpec(result), result.reMake ? result : (this.updateDataSpec(result), 
        result.reMake || this.updateGlobalScaleDomain(), result)))));
    }
    updateChartConfig(result, oldSpec) {
        var _a, _b;
        this._paddingSpec = (0, util_1.normalizeLayoutPaddingSpec)(null !== (_a = this._spec.padding) && void 0 !== _a ? _a : null === (_b = this._option) || void 0 === _b ? void 0 : _b.getTheme().padding), 
        this._updateLayoutRect(this._viewBox), (0, vutils_1.isEqual)(this._spec.background, oldSpec.background) || (result.reMake = !0);
    }
    updateDataSpec(result) {
        this._spec.data && this._chartData.updateData(this._spec.data, !1, !0);
    }
    updateRegionSpec(result) {
        var _a;
        (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.region) && (this._spec.region.length === this._regions.length ? this._regions.forEach((r => {
            (0, util_3.mergeUpdateResult)(result, r.updateSpec(this._spec.region[r.getSpecIndex()]));
        })) : result.reMake = !0);
    }
    updateComponentSpec(result) {
        const componentCache = {};
        this._components.forEach((c => {
            var _a, _b;
            const compSpecKey = c.specKey || c.type, cmpSpec = null !== (_a = this._spec[compSpecKey]) && void 0 !== _a ? _a : {};
            (0, util_1.isArray)(cmpSpec) ? (componentCache[compSpecKey] = componentCache[compSpecKey] || {
                specCount: cmpSpec.length,
                componentCount: 0
            }, componentCache[compSpecKey].componentCount++, (0, util_3.mergeUpdateResult)(result, c.updateSpec(null !== (_b = cmpSpec[c.getSpecIndex()]) && void 0 !== _b ? _b : {}, cmpSpec))) : (0, 
            util_3.mergeUpdateResult)(result, c.updateSpec(cmpSpec));
        }));
        for (const key in componentCache) if (Object.prototype.hasOwnProperty.call(componentCache, key)) {
            const element = componentCache[key];
            element.componentCount !== element.specCount && (result.reMake = !0);
        }
    }
    updateSeriesSpec(result) {
        this._spec.series.length === this._series.length ? this._series.forEach((s => {
            const spec = this._spec.series[s.getSpecIndex()];
            (0, util_3.mergeUpdateResult)(result, s.updateSpec(spec));
        })) : result.reMake = !0;
    }
    getCanvas() {
        var _a, _b;
        return null !== (_b = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getCanvas()) && void 0 !== _b ? _b : null;
    }
    _updateLayoutRect(viewBox) {
        let viewRect = this.getCanvasRect();
        if (viewBox) {
            this._viewBox = viewBox;
            const {x1: x1 = 0, y1: y1 = 0, x2: x2, y2: y2} = viewBox;
            viewRect = {
                width: x2 - x1,
                height: y2 - y1
            };
        } else this._viewBox = {
            x1: 0,
            y1: 0,
            x2: viewRect.width,
            y2: viewRect.height
        };
        this._viewRect = viewRect, this.padding = (0, util_1.calcPadding)(this._paddingSpec, viewRect, viewRect), 
        this._layoutRect.width = viewRect.width - this.padding.left - this.padding.right, 
        this._layoutRect.height = viewRect.height - this.padding.top - this.padding.bottom, 
        this._layoutRect.x = this.padding.left, this._layoutRect.y = this.padding.top, this._event.emit(constant_1.ChartEvent.layoutRectUpdate, {});
    }
    setCurrentTheme() {
        this.updateChartConfig({
            change: !0,
            reMake: !1
        }, this._spec), this.setLayoutTag(!0, null, !1), this.updateGlobalScaleTheme(), 
        this._regions.forEach((r => r.reInit(r.getSpecInfo().spec))), this._series.forEach((s => s.reInit(s.getSpecInfo().spec))), 
        this._components.forEach((c => c.reInit(c.getSpecInfo().spec)));
    }
    clear() {
        this.getAllModels().forEach((i => {
            var _a;
            return null === (_a = i.clear) || void 0 === _a ? void 0 : _a.call(i);
        }));
    }
    compile() {
        this.compileBackground(), this.compileLayout(), this.compileRegions(), this.compileSeries(), 
        this.compileComponents();
    }
    afterCompile() {
        this.getAllRegions().forEach((r => {
            var _a;
            null === (_a = r.afterCompile) || void 0 === _a || _a.call(r);
        })), this.getAllSeries().forEach((s => {
            var _a;
            null === (_a = s.afterCompile) || void 0 === _a || _a.call(s);
        })), this.getAllComponents().forEach((c => {
            var _a;
            null === (_a = c.afterCompile) || void 0 === _a || _a.call(c);
        }));
    }
    compileLayout() {
        const {width: width, height: height} = this.getCanvasRect();
        this.getCompiler().setSize(width, height);
    }
    compileBackground() {
        var _a;
        this._backgroundMark && (this._backgroundMark.compile(), null === (_a = this._backgroundMark.getProduct()) || void 0 === _a || _a.configure({
            context: {
                model: this
            }
        }).layout((() => {})));
    }
    compileRegions() {
        var _a, _b, _c, _d;
        null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeRegionCompile) || void 0 === _b || _b.call(_a), 
        this.getAllRegions().forEach((r => {
            r.compile();
        })), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterRegionCompile) || void 0 === _d || _d.call(_c);
    }
    compileSeries() {
        var _a, _b, _c, _d;
        null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeSeriesCompile) || void 0 === _b || _b.call(_a), 
        this.getAllSeries().forEach((s => {
            s.compile();
        })), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterSeriesCompile) || void 0 === _d || _d.call(_c);
    }
    compileComponents() {
        var _a, _b, _c, _d;
        null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeComponentCompile) || void 0 === _b || _b.call(_a), 
        this.getAllComponents().forEach((c => {
            c.compile();
        })), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterComponentCompile) || void 0 === _d || _d.call(_c);
    }
    release() {
        [ ...this._components, ...this._regions, ...this._series ].forEach((m => {
            m.beforeRelease();
        })), super.release(), this.clear(), [ ...this._components, ...this._regions, ...this._series ].forEach((m => {
            m.release();
        })), this._components = this._regions = this._series = [], this._spec = {}, this._dataSet = this._globalScale = this._layoutFunc = null, 
        this._layoutTag = !1, this._idMap.clear();
    }
    onLayout(srView) {
        const root = srView.rootMark;
        this.layout({
            group: root,
            srView: srView
        });
    }
    updateState(state, filter) {
        const seriesArr = this.getAllSeries();
        for (const key in state) {
            if ((0, vutils_1.isEmpty)(state[key])) continue;
            const stateSpec = state[key];
            let stateInfo = {
                stateValue: key
            };
            stateInfo = (0, vutils_1.isFunction)(stateSpec.filter) ? Object.assign({
                filter: stateSpec.filter
            }, stateInfo) : Object.assign(Object.assign({}, stateSpec.filter), stateInfo), stateSpec.level && (stateInfo.level = stateSpec.level), 
            seriesArr.forEach((series => {
                series.getMarks().forEach((m => {
                    m.stateStyle[key] && (filter && !filter(series, m, key) || (m.state.changeStateInfo(stateInfo), 
                    m.updateMarkState(key)));
                }));
            }));
        }
    }
    setSelected(datum, filter, region) {
        this._setStateInDatum(interface_3.STATE_VALUE_ENUM.STATE_SELECTED, !0, datum, filter, region);
    }
    setHovered(datum, filter, region) {
        this._setStateInDatum(interface_3.STATE_VALUE_ENUM.STATE_HOVER, !0, datum, filter, region);
    }
    _initEvent() {
        [ constant_1.ChartEvent.dataZoomChange, constant_1.ChartEvent.scrollBarChange ].forEach((event => {
            this._event.on(event, (({value: value}) => {
                if (!value.filterData) return;
                this._disableMarkAnimation([ "exit", "update" ]);
                const enableMarkAnimate = () => {
                    this._enableMarkAnimation([ "exit", "update" ]), this._event.off(constant_1.VGRAMMAR_HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
                };
                this._event.on(constant_1.VGRAMMAR_HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
            }));
        }));
    }
    _enableMarkAnimation(states) {
        this.getAllMarks().forEach((mark => {
            const product = mark.getProduct();
            product && product.animate && product.animate.enableAnimationState(states);
        }));
    }
    _disableMarkAnimation(states) {
        this.getAllMarks().forEach((mark => {
            const product = mark.getProduct();
            product && product.animate && product.animate.disableAnimationState(states);
        }));
    }
    _setStateInDatum(stateKey, checkReverse, datum, filter, region) {
        const keys = (datum = datum ? (0, util_1.array)(datum) : null) ? Object.keys(datum[0]) : null;
        this.getRegionsInQuerier(region).forEach((r => {
            datum ? (r.getSeries().forEach((s => {
                s.getMarks().forEach((m => {
                    if (m.getProduct() && (!filter || (0, vutils_1.isFunction)(filter) && filter(s, m))) {
                        const isCollect = m.getProduct().isCollectionMark(), elements = m.getProduct().elements;
                        let pickElements = elements;
                        if (isCollect) pickElements = elements.filter((e => {
                            const elDatum = e.getDatum();
                            datum.every(((d, index) => keys.every((k => d[k] == elDatum[index][k]))));
                        })); else if (datum.length > 1) {
                            const datumTemp = datum.slice();
                            pickElements = elements.filter((e => {
                                if (0 === datumTemp.length) return !1;
                                const elDatum = e.getDatum(), index = datumTemp.findIndex((d => keys.every((k => d[k] == elDatum[k]))));
                                return index >= 0 && (datumTemp.splice(index, 1), !0);
                            }));
                        } else {
                            const el = elements.find((e => keys.every((k => datum[0][k] == e.getDatum()[k]))));
                            el && (pickElements = [ el ]);
                        }
                        pickElements.forEach((element => {
                            r.interaction.addEventElement(stateKey, element);
                        }));
                    }
                }));
            })), checkReverse && r.interaction.reverseEventElement(stateKey)) : r.interaction.clearEventElement(stateKey, !0);
        }));
    }
    setDimensionIndex(value, opt) {
        var _a, _b, _c, _d;
        let dimensionInfo = null;
        Array.from(this._event.getComposedEventMap().values()).forEach((e => {
            const {eventType: eventType, event: event} = e;
            if (eventType === dimension_1.DimensionEventEnum.dimensionHover || eventType === dimension_1.DimensionEventEnum.dimensionClick) {
                const info = event.dispatch(value, opt);
                (null == info ? void 0 : info.length) && (dimensionInfo = info);
            }
        }));
        const isUnableValue = (0, vutils_1.isNil)(value) || !dimensionInfo || dimensionInfo.every((d => (0, 
        vscale_1.isDiscrete)(d.axis.getScale().type) && (0, vutils_1.isNil)(d.index)));
        if (!1 !== opt.tooltip) {
            const tooltip = this._components.find((c => c.type === interface_1.ComponentTypeEnum.tooltip));
            if (null == tooltip ? void 0 : tooltip.getVisible()) if (isUnableValue) null === (_b = (_a = tooltip).hideTooltip) || void 0 === _b || _b.call(_a); else {
                const dataFilter = {};
                dimensionInfo.forEach((d => {
                    const {axis: axis, value: value, data: data} = d, isY = "left" === axis.getOrient() || "right" === axis.getOrient();
                    data.forEach((d => {
                        isY ? dataFilter[d.series.fieldY[0]] = value : dataFilter[d.series.fieldX[0]] = value;
                    }));
                })), tooltip.showTooltip(dataFilter, opt.showTooltipOption);
            }
        }
        if (!1 !== opt.crosshair) {
            const crosshair = this._components.find((c => c.type === interface_1.ComponentTypeEnum.cartesianCrosshair));
            crosshair && crosshair.clearAxisValue && crosshair.setAxisValue && (isUnableValue ? (null === (_c = crosshair.clearAxisValue) || void 0 === _c || _c.call(crosshair), 
            null === (_d = crosshair.hide) || void 0 === _d || _d.call(crosshair)) : dimensionInfo.forEach((d => {
                const {axis: axis, value: value} = d;
                crosshair.clearAxisValue(), crosshair.setAxisValue(value, axis), crosshair.layoutByValue();
            })));
        }
    }
    getColorScheme() {
        var _a, _b;
        return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a).colorScheme;
    }
}

exports.BaseChart = BaseChart;
//# sourceMappingURL=base-chart.js.map
