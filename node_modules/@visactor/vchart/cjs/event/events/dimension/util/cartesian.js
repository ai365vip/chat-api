"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getDimensionInfoByValue = exports.getDimensionInfoByPosition = exports.getCartesianDimensionInfo = void 0;

const vscale_1 = require("@visactor/vscale"), common_1 = require("./common"), vutils_1 = require("@visactor/vutils"), common_2 = require("../../../../component/axis/cartesian/util/common"), space_1 = require("../../../../typings/space"), model_1 = require("../../../../util/model"), discreteXAxisGetDimensionField = series => series.fieldX[0], discreteYAxisGetDimensionField = series => series.fieldY[0], continuousXAxisGetDimensionField = series => [ series.fieldX[0], series.fieldX2 ], continuousYAxisGetDimensionField = series => [ series.fieldY[0], series.fieldY2 ], getCartesianDimensionInfo = (chart, pos) => {
    var _a, _b;
    if (!chart) return null;
    if (!(0, model_1.getFirstSeries)(chart.getRegionsInIndex(), "cartesian")) return null;
    const {x: x, y: y} = pos, xAxisList = null !== (_a = (0, common_1.getAxis)(chart, (cmp => (0, 
    common_2.isXAxis)(cmp.getOrient())), pos)) && void 0 !== _a ? _a : [], yAxisList = null !== (_b = (0, 
    common_1.getAxis)(chart, (cmp => (0, common_2.isYAxis)(cmp.getOrient())), pos)) && void 0 !== _b ? _b : [], bandAxisSet = new Set, linearAxisSet = new Set;
    [ xAxisList, yAxisList ].forEach((axisList => axisList.forEach((axis => {
        (0, vscale_1.isDiscrete)(axis.getScale().type) ? bandAxisSet.add(axis) : linearAxisSet.add(axis);
    }))));
    const targetAxisInfo = [], addAxisDimensionInfo = (orient, isDiscrete) => {
        ("x" === orient ? xAxisList : yAxisList).forEach((axis => {
            if ((isDiscrete ? bandAxisSet : linearAxisSet).has(axis)) {
                const info = (0, exports.getDimensionInfoByPosition)(axis, "x" === orient ? x : y, orient, "x" === orient ? isDiscrete ? discreteXAxisGetDimensionField : continuousXAxisGetDimensionField : isDiscrete ? discreteYAxisGetDimensionField : continuousYAxisGetDimensionField);
                info && targetAxisInfo.push(info);
            }
        }));
    };
    return chart.getSpec().direction === space_1.Direction.horizontal ? (addAxisDimensionInfo("y", bandAxisSet.size > 0), 
    0 === targetAxisInfo.length && addAxisDimensionInfo("x", bandAxisSet.size > 0)) : (addAxisDimensionInfo("x", bandAxisSet.size > 0), 
    0 === targetAxisInfo.length && addAxisDimensionInfo("y", bandAxisSet.size > 0)), 
    targetAxisInfo.length ? targetAxisInfo : null;
};

exports.getCartesianDimensionInfo = getCartesianDimensionInfo;

const getDimensionInfoByPosition = (axis, posValue, posKey, getDimensionField) => {
    const scale = axis.getScale(), scalePos = posValue - axis.getLayoutStartPoint()[posKey];
    if ((scalePos - scale.range()[0]) * (scalePos - scale.range()[1]) > 0) return null;
    const value = scale.invert(scalePos);
    return (0, exports.getDimensionInfoByValue)(axis, value, getDimensionField);
};

exports.getDimensionInfoByPosition = getDimensionInfoByPosition;

const getDimensionInfoByValue = (axis, value, getDimensionField) => {
    const scale = axis.getScale();
    if ((0, vutils_1.isNil)(value)) return null;
    let index = scale.domain().findIndex((v => (null == v ? void 0 : v.toString()) === value.toString()));
    index < 0 && (index = void 0);
    const data = (0, common_1.getDimensionData)(value, axis, "cartesian", null != getDimensionField ? getDimensionField : (0, 
    common_2.isXAxis)(axis.getOrient()) ? discreteXAxisGetDimensionField : discreteYAxisGetDimensionField);
    return {
        index: index,
        value: value,
        axis: axis,
        data: data
    };
};

exports.getDimensionInfoByValue = getDimensionInfoByValue;
//# sourceMappingURL=cartesian.js.map
