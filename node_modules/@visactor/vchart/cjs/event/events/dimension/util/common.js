"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getAxis = exports.getDimensionData = exports.isSameDimensionInfo = exports.isInRegionBound = void 0;

const vutils_1 = require("@visactor/vutils"), vscale_1 = require("@visactor/vscale"), isInBound = (pos, min, max) => pos.x >= min.x && pos.x <= max.x && pos.y >= min.y && pos.y <= max.y, isInRegionBound = (chart, axis, pos) => {
    const regionList = chart.getRegionsInIds((0, vutils_1.array)(axis.layout.layoutBindRegionID));
    return null == regionList ? void 0 : regionList.some((region => {
        const rect = region.getLayoutRect(), startPoint = region.getLayoutStartPoint();
        return isInBound(pos, {
            x: startPoint.x,
            y: startPoint.y
        }, {
            x: rect.width + startPoint.x,
            y: rect.height + startPoint.y
        });
    }));
};

exports.isInRegionBound = isInRegionBound;

const isSameDimensionInfo = (a, b) => {
    var _a, _b;
    return a === b || !(0, vutils_1.isNil)(a) && !(0, vutils_1.isNil)(b) && (a.value === b.value && (null === (_a = a.axis) || void 0 === _a ? void 0 : _a.id) === (null === (_b = b.axis) || void 0 === _b ? void 0 : _b.id));
};

exports.isSameDimensionInfo = isSameDimensionInfo;

const getDimensionData = (value, axis, coordinate, getDimensionField) => {
    var _a;
    const scale = axis.getScale(), isDiscreteAxis = (0, vscale_1.isDiscrete)(scale.type), data = [], regions = axis.getRegions();
    for (const region of regions) {
        const seriesList = region.getSeries();
        for (const series of seriesList) if (series.coordinate === coordinate) {
            const dimensionField = (0, vutils_1.array)(getDimensionField(series)), viewData = null === (_a = series.getViewData()) || void 0 === _a ? void 0 : _a.latestData;
            if (dimensionField && viewData) if (isDiscreteAxis) data.push({
                series: series,
                datum: viewData.filter((datum => {
                    var _a;
                    return (null === (_a = datum[dimensionField[0]]) || void 0 === _a ? void 0 : _a.toString()) === (null == value ? void 0 : value.toString());
                }))
            }); else if ((0, vutils_1.isValid)(dimensionField[1])) data.push({
                series: series,
                datum: viewData.filter((datum => {
                    var _a;
                    return (null === (_a = datum[dimensionField[0]]) || void 0 === _a ? void 0 : _a.toString()) === (null == value ? void 0 : value.toString()) || (0, 
                    vutils_1.isValid)(datum[dimensionField[0]]) && (0, vutils_1.isValid)(datum[dimensionField[1]]) && value >= datum[dimensionField[0]] && value < datum[dimensionField[1]];
                }))
            }); else {
                const range = axis.getSpec().tooltipFilterRange, rangeArr = (0, vutils_1.isValidNumber)(range) ? [ -range, range ] : range;
                let datums = [];
                if (rangeArr) viewData.forEach((datum => {
                    if ((0, vutils_1.isValid)(datum[dimensionField[0]])) {
                        const delta = datum[dimensionField[0]] - value;
                        delta >= rangeArr[0] && delta <= rangeArr[1] && datums.push(datum);
                    }
                })); else {
                    let minDelta = 1 / 0, deltaSign = 0;
                    viewData.forEach((datum => {
                        if ((0, vutils_1.isValid)(datum[dimensionField[0]])) {
                            const delta = Math.abs(datum[dimensionField[0]] - value), sign = Math.sign(datum[dimensionField[0]] - value);
                            delta < minDelta ? (minDelta = delta, datums = [ datum ], deltaSign = sign) : delta === minDelta && sign === deltaSign && datums.push(datum);
                        }
                    }));
                }
                data.push({
                    series: series,
                    datum: datums
                });
            }
        }
    }
    return data;
};

exports.getDimensionData = getDimensionData;

const getAxis = (chart, filter, pos) => {
    const axesComponents = chart.getAllComponents().filter((c => "axes" === c.specKey && filter(c) && (0, 
    exports.isInRegionBound)(chart, c, pos)));
    return axesComponents.length ? axesComponents : null;
};

exports.getAxis = getAxis;
//# sourceMappingURL=common.js.map
