"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerTotalLabel = exports.totalLabelPosition = exports.TotalLabel = void 0;

const label_1 = require("../../mark/label"), type_1 = require("../interface/type"), constant_1 = require("../../constant"), interface_1 = require("../../mark/interface"), merge_spec_1 = require("../../util/spec/merge-spec"), vgrammar_core_1 = require("@visactor/vgrammar-core"), util_1 = require("./util"), base_label_1 = require("./base-label"), factory_1 = require("../../core/factory"), component_1 = require("../../mark/component");

class TotalLabel extends base_label_1.BaseLabelComponent {
    constructor() {
        super(...arguments), this.type = type_1.ComponentTypeEnum.totalLabel, this.name = type_1.ComponentTypeEnum.totalLabel, 
        this.specKey = "totalLabel", this.layoutZIndex = constant_1.LayoutZIndex.Label;
    }
    static getSpecInfo(chartSpec, chartSpecInfo) {
        var _a;
        const specInfo = [];
        return null === (_a = null == chartSpecInfo ? void 0 : chartSpecInfo.region) || void 0 === _a || _a.forEach(((regionInfo, i) => {
            var _a;
            null === (_a = regionInfo.seriesIndexes) || void 0 === _a || _a.forEach((seriesIndex => {
                const {spec: spec} = chartSpecInfo.series[seriesIndex], labelSpec = spec[this.specKey];
                (null == labelSpec ? void 0 : labelSpec.visible) && specInfo.push({
                    spec: labelSpec,
                    type: type_1.ComponentTypeEnum.totalLabel,
                    specPath: [ "series", seriesIndex, this.specKey ],
                    specIndex: i
                });
            }));
        })), specInfo;
    }
    init(option) {
        super.init(option), this._initTextMark(), this._initLabelComponent();
    }
    _initTextMark() {
        var _a;
        const series = this._getSeries();
        if (null === (_a = series.getSpec().totalLabel) || void 0 === _a ? void 0 : _a.visible) {
            const mark = series.getMarksInType([ interface_1.MarkTypeEnum.rect, interface_1.MarkTypeEnum.symbol ])[0], textMark = this._createMark({
                type: interface_1.MarkTypeEnum.label,
                name: `${mark.name}-total-label`
            });
            this._baseMark = mark, this._textMark = textMark, this._initTextMarkStyle();
        }
    }
    _initTextMarkStyle() {
        super.initMarkStyleWithSpec(this._textMark, this._spec), this.setMarkStyle(this._textMark, {
            text: datum => datum[constant_1.STACK_FIELD_TOTAL]
        }, "normal", constant_1.AttributeLevel.Default);
    }
    _initLabelComponent() {
        const series = this._getSeries(), component = this._createMark({
            type: interface_1.MarkTypeEnum.component,
            name: `${series.name}-total-label-component`
        }, {
            componentType: "label",
            noSeparateStyle: !0,
            support3d: this._spec.support3d
        });
        component && this._marks.addMark(component);
    }
    updateLayoutAttribute() {
        super.updateLayoutAttribute();
        const series = this._getSeries();
        this._marks.forEach(((componentMark, index) => {
            componentMark.getProduct().target(this._baseMark.getProduct()).configure({
                interactive: !1
            }).labelStyle((() => {
                if (this._baseMark) {
                    const {offset: offset, animation: animation, overlap: overlap} = this._spec, interactive = this._interactiveConfig(this._spec);
                    return (0, merge_spec_1.mergeSpec)({
                        textStyle: {
                            pickable: !0 === this._spec.interactive
                        },
                        position: totalLabelPosition(series, this._baseMark.type),
                        x: 0,
                        y: 0
                    }, Object.assign({
                        offset: offset,
                        animation: animation,
                        overlap: overlap,
                        dataFilter: data => data.filter((d => d.data[constant_1.STACK_FIELD_TOTAL_TOP]))
                    }, interactive));
                }
            })).encode((datum => (0, util_1.textAttribute)({
                baseMark: this._baseMark,
                labelMark: this._textMark,
                series: series,
                labelSpec: series.getSpec().totalLabel
            }, datum, this._spec.formatMethod))).size((() => this._regions[0].getLayoutRect()));
        }));
    }
    compileMarks() {
        this.getMarks().forEach((m => {
            var _a;
            const group = this._regions[0].getGroupMark().getProduct();
            m.compile({
                group: group
            }), null === (_a = m.getProduct()) || void 0 === _a || _a.configure({
                context: {
                    model: this
                }
            });
        }));
    }
    getVRenderComponents() {
        const labels = [];
        return this.getMarks().forEach((m => {
            const graphicItem = m.getProduct().getGroupGraphicItem();
            graphicItem && labels.push(graphicItem);
        })), labels;
    }
    _getSeries() {
        return this._option.getSeriesInIndex([ this.getSpecPath()[1] ])[0];
    }
}

function totalLabelPosition(series, type) {
    let position;
    if ("rect" === type) position = "horizontal" === series.direction ? "right" : "top"; else position = "top";
    return position;
}

exports.TotalLabel = TotalLabel, TotalLabel.type = type_1.ComponentTypeEnum.totalLabel, 
TotalLabel.specKey = "totalLabel", exports.totalLabelPosition = totalLabelPosition;

const registerTotalLabel = () => {
    (0, vgrammar_core_1.registerLabel)(), (0, label_1.registerLabelMark)(), (0, component_1.registerComponentMark)(), 
    factory_1.Factory.registerComponent(TotalLabel.type, TotalLabel, !0);
};

exports.registerTotalLabel = registerTotalLabel;
//# sourceMappingURL=total-label.js.map
