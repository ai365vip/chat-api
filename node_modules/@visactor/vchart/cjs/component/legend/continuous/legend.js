"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerContinuousLegend = exports.ContinuousLegend = void 0;

const vutils_1 = require("@visactor/vutils"), vdataset_1 = require("@visactor/vdataset"), type_1 = require("../../interface/type"), register_1 = require("../../../data/register"), model_1 = require("../../../util/model"), data_1 = require("../../../util/data"), type_2 = require("../../../util/type"), continuous_1 = require("../../../data/transforms/legend-data/continuous/continuous"), util_1 = require("./util"), base_legend_1 = require("../base-legend"), constant_1 = require("../../../constant"), factory_1 = require("../../../core/factory"), initialize_1 = require("../../../data/initialize"), SINGLE_SEQUENCE = [ "#C4E7FF", "#98CAFF", "#75ACFF", "#518FF9", "#2775DC", "#005CBE", "#00429F", "#00287E" ], SIZE = [ 2, 10 ];

class ContinuousLegend extends base_legend_1.BaseLegend {
    static getSpecInfo(chartSpec) {
        const legendSpec = chartSpec[this.specKey];
        if (!legendSpec) return;
        if (!(0, vutils_1.isArray)(legendSpec)) return (0, util_1.isContinuousLegend)(legendSpec.type) ? [ {
            spec: legendSpec,
            specIndex: 0,
            specPath: [ this.specKey ],
            type: "color" === legendSpec.type ? type_1.ComponentTypeEnum.colorLegend : type_1.ComponentTypeEnum.sizeLegend
        } ] : void 0;
        const specInfos = [];
        return legendSpec.forEach(((s, i) => {
            (0, util_1.isContinuousLegend)(s.type) && specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: "color" === s.type ? type_1.ComponentTypeEnum.colorLegend : type_1.ComponentTypeEnum.sizeLegend
            });
        })), specInfos;
    }
    constructor(spec, options) {
        super(spec, options), this.type = type_1.ComponentTypeEnum.colorLegend, this.name = type_1.ComponentTypeEnum.colorLegend;
        const legendName = "color" === this._spec.type ? type_1.ComponentTypeEnum.colorLegend : type_1.ComponentTypeEnum.sizeLegend;
        this.type = legendName, this.name = legendName;
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._field = this._spec.field, this._legendType = this._spec.type;
    }
    init(option) {
        super.init(option), (0, model_1.eachSeries)(this._regions, (s => {
            s.addViewDataFilter({
                type: "continuousLegendFilter",
                options: {
                    selected: () => this._selectedData,
                    field: () => this._field,
                    data: () => this._legendData.getLatestData()
                },
                level: initialize_1.TransformLevel.legendFilter
            });
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        });
    }
    _getScaleInGlobal() {
        const globalScale = this._option.globalScale;
        let scaleKey = this._spec.scale;
        return scaleKey || (scaleKey = this._legendType), globalScale.getScale(scaleKey);
    }
    _initLegendData() {
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "continuousLegendFilter", continuous_1.continuousLegendFilter), 
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "continuousLegendDataMake", continuous_1.continuousLegendDataMake);
        const legendData = new vdataset_1.DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        return legendData.transform({
            type: "continuousLegendDataMake",
            options: {
                series: () => this._regions.reduce(((pre, r) => (pre.push(...r.getSeries()), pre)), []),
                field: () => this._field,
                scale: this._getScaleInGlobal.bind(this)
            }
        }), legendData;
    }
    _initSelectedData() {
        this._spec.defaultSelected ? this._selectedData = this._spec.defaultSelected.slice() : this._selectedData = this._legendData.getLatestData();
    }
    _addDefaultTitleText(attrs) {
        var _a, _b, _c, _d;
        if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && (0, 
        vutils_1.isNil)(attrs.title.text) && (0, vutils_1.isNil)(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
            const field = this._field;
            if (field) {
                const series = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
                if (!series) return;
                return void (attrs.title.text = (0, data_1.getFieldAlias)(series.getRawData(), field));
            }
            let scaleKey = this._spec.scale;
            scaleKey || (scaleKey = this._legendType);
            const scaleSpec = this._option.globalScale.getScaleSpec(scaleKey);
            if (!(0, type_2.isDataDomainSpec)(null == scaleSpec ? void 0 : scaleSpec.domain)) return;
            const dataInfo = scaleSpec.domain[0];
            if (0 === dataInfo.fields.length) return;
            attrs.title.text = (0, data_1.getFieldAlias)(this._option.dataSet.getDataView(dataInfo.dataId), dataInfo.fields[0]);
        } else ;
    }
    _getLegendAttributes(rect) {
        var _a, _b;
        const layout = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", align = "horizontal" === layout ? "bottom" : this.layoutOrient;
        let visualMappingRange = [];
        const scale = this._getScaleInGlobal();
        scale && "linear" === scale.type && (visualMappingRange = scale.range()), (0, vutils_1.isEmpty)(visualMappingRange) && (visualMappingRange = "color" === this._legendType ? SINGLE_SEQUENCE : SIZE);
        let min = null !== (_a = this._legendData.getLatestData()[0]) && void 0 !== _a ? _a : 0, max = null !== (_b = this._legendData.getLatestData()[1]) && void 0 !== _b ? _b : 1;
        this._legendData.getLatestData()[0] === this._legendData.getLatestData()[1] && (min = Math.min(0, this._legendData.getLatestData()[0]), 
        max = 0 === this._legendData.getLatestData()[0] ? 1 : Math.max(0, this._legendData.getLatestData()[0]));
        const attrs = Object.assign({
            layout: layout,
            align: align,
            zIndex: this.layoutZIndex,
            min: min,
            max: max,
            value: this._spec.defaultSelected,
            ["color" === this._legendType ? "colors" : "sizeRange"]: visualMappingRange
        }, (0, util_1.getContinuousLegendAttributes)(this._spec));
        return this._addDefaultTitleText(attrs), attrs;
    }
    _getLegendConstructor() {
        return util_1.ContinuousLegendMap[this._legendType];
    }
    _initEvent() {
        if (this._legendComponent) {
            const doFilter = !1 !== this._spec.filter;
            this._legendComponent.addEventListener("change", (0, vutils_1.debounce)((e => {
                const selectedData = (0, vutils_1.get)(e, "detail.value");
                doFilter && this.setSelectedData(selectedData), this.event.emit(constant_1.ChartEvent.legendFilter, {
                    model: this,
                    value: selectedData,
                    event: e
                });
            }), 30));
        }
    }
}

exports.ContinuousLegend = ContinuousLegend, ContinuousLegend.specKey = "legends", 
ContinuousLegend.type = type_1.ComponentTypeEnum.continuousLegend;

const registerContinuousLegend = () => {
    factory_1.Factory.registerComponent(ContinuousLegend.type, ContinuousLegend);
};

exports.registerContinuousLegend = registerContinuousLegend;
//# sourceMappingURL=legend.js.map
