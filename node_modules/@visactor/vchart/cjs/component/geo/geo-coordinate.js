"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerGeoCoordinate = exports.GeoCoordinate = exports.projectionName = void 0;

const index_1 = require("./../../constant/index"), projection_1 = require("./projection"), type_1 = require("../interface/type"), base_component_1 = require("../base/base-component"), model_1 = require("../../util/model"), merge_spec_1 = require("../../util/spec/merge-spec"), index_2 = require("../../constant/index"), type_2 = require("../../series/interface/type"), zoomable_1 = require("../../interaction/zoom/zoomable"), vutils_1 = require("@visactor/vutils"), map_1 = require("../../data/transforms/map"), factory_1 = require("../../core/factory");

function projectionName(key, id) {
    return `${index_2.PREFIX}_${id}_${key}`;
}

exports.projectionName = projectionName;

class GeoCoordinate extends base_component_1.BaseComponent {
    constructor() {
        super(...arguments), this.type = type_1.ComponentTypeEnum.geoCoordinate, this.name = type_1.ComponentTypeEnum.geoCoordinate, 
        this.layoutType = "none", this.layoutZIndex = index_1.LayoutZIndex.Mark, this._projectionSpec = {
            name: projectionName(this.type, this.id),
            type: "mercator"
        }, this._actualScale = 1, this._initialScale = 1, this.effect = {
            scaleUpdate: () => {
                this.coordinateHelper();
            }
        }, this._handleChartZoom = (params, event) => {
            var _a, _b, _c, _d, _e, _f;
            let scale = params.zoomDelta;
            const _lastActualScale = this._actualScale;
            return this._actualScale *= scale, this._actualScale < (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.min) ? (this._actualScale = null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min, 
            scale = (null === (_c = this._spec.zoomLimit) || void 0 === _c ? void 0 : _c.min) / _lastActualScale) : this._actualScale > (null === (_d = this._spec.zoomLimit) || void 0 === _d ? void 0 : _d.max) && (this._actualScale = null === (_e = this._spec.zoomLimit) || void 0 === _e ? void 0 : _e.max, 
            scale = (null === (_f = this._spec.zoomLimit) || void 0 === _f ? void 0 : _f.max) / _lastActualScale), 
            event && (event.zoomDelta = scale), this.zoom(scale, [ params.zoomX, params.zoomY ]), 
            scale;
        }, this.pan = (delta = [ 0, 0 ]) => {
            var _a, _b, _c;
            const t = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.translate()) && void 0 !== _b ? _b : [ 0, 0 ];
            let t_x = t[0], t_y = t[1];
            t_x += delta[0], t_y += delta[1], null === (_c = this._projection) || void 0 === _c || _c.translate([ t_x, t_y ]);
        };
    }
    get longitudeField() {
        return this._longitudeField;
    }
    get latitudeField() {
        return this._latitudeField;
    }
    get projectionSpec() {
        return this._projectionSpec;
    }
    setProjection(projectionSpec) {
        this._projectionSpec = Object.assign(Object.assign({}, projectionSpec), {
            name: this._projectionSpec.name
        });
    }
    getZoom() {
        return this._actualScale;
    }
    static getSpecInfo(chartSpec) {
        if ((0, vutils_1.isNil)(chartSpec)) return null;
        const specInfos = [];
        return chartSpec.region.forEach(((r, i) => {
            if ("geo" === r.coordinate) {
                const spec = Object.assign(Object.assign({}, r), {
                    padding: 0
                });
                specInfos.push({
                    spec: spec,
                    regionIndex: i,
                    type: type_1.ComponentTypeEnum.geoCoordinate,
                    specInfoPath: [ "region", i, "geoCoordinate" ]
                });
            }
        })), specInfos;
    }
    setAttrFromSpec() {
        var _a, _b, _c;
        super.setAttrFromSpec(), this._spec.roam && this.initZoomable(this.event, this._option.mode), 
        this._projectionSpec = (0, merge_spec_1.mergeSpec)(this._projectionSpec, this._spec.projection), 
        this._projectionSpec.zoom > (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.max) && (this._projectionSpec.zoom = this._spec.zoomLimit.max), 
        this._projectionSpec.zoom < (null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min) && (this._projectionSpec.zoom = this._spec.zoomLimit.min), 
        this._actualScale = null !== (_c = this._projectionSpec.zoom) && void 0 !== _c ? _c : 1, 
        this._initialScale = this._actualScale, this._longitudeField = this._spec.longitudeField, 
        this._latitudeField = this._spec.latitudeField;
    }
    created() {
        super.created(), this._regions = this._option.getRegionsInIndex([ this._option.regionIndex ]), 
        this.initProjection(), this.coordinateHelper(), this.initEvent(), this._initCenterCache();
    }
    dispatchZoom(zoomDelta, center) {
        const scaleCenter = center || {
            x: this.getLayoutStartPoint().x + this.getLayoutRect().width / 2,
            y: this.getLayoutStartPoint().y + this.getLayoutRect().height / 2
        }, scale = this._handleChartZoom({
            zoomDelta: zoomDelta,
            zoomX: scaleCenter.x,
            zoomY: scaleCenter.y
        });
        1 !== scale && this.event.emit("zoom", {
            scale: scale,
            scaleCenter: scaleCenter,
            model: this
        });
    }
    initEvent() {
        this.event.on(index_2.ChartEvent.scaleUpdate, {
            filter: ({model: model}) => (null == model ? void 0 : model.id) === this.id
        }, this.effect.scaleUpdate.bind(this)), this._spec.roam && (this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom), 
        this.initDragEventOfRegions(this._regions, (() => !0), this.pan), this._regions.forEach((r => {
            r.getSeries().forEach((s => {
                s.event.on("zoom", (e => (s.handleZoom(e), !0))), s.event.on("panmove", (e => (s.handlePan(e), 
                !0)));
            }));
        })));
    }
    initProjection() {
        var _a;
        this._projection = new projection_1.Projection(this._projectionSpec), null !== this._projection.projection || null === (_a = this._option) || void 0 === _a || _a.onError("unsupported projection type!");
    }
    coordinateHelper() {
        const helper = {
            longitudeField: this._longitudeField,
            latitudeField: this._latitudeField,
            dataToPosition: this.dataToPosition.bind(this),
            dataToLongitude: this.dataToLongitude.bind(this),
            dataToLatitude: this.dataToLatitude.bind(this),
            shape: this.shape.bind(this),
            getCoordinateId: () => this.id
        };
        this._regions.forEach((r => {
            r.getSeries().forEach((s => {
                s.type === type_2.SeriesTypeEnum.map ? s.setCoordinateHelper(helper) : (s.setXAxisHelper(Object.assign(Object.assign({}, helper), {
                    isContinuous: !0,
                    dataToPosition: (values, option) => {
                        var _a;
                        let value = values[0];
                        if ((0, vutils_1.isNil)(value) && (null == option ? void 0 : option.datum)) {
                            const nameFieldValue = option.datum[s.getDimensionField()[0]];
                            value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
                        }
                        return this.dataToLongitude(value);
                    },
                    valueToPosition: (value, option) => {
                        var _a;
                        if ((0, vutils_1.isNil)(value) && (null == option ? void 0 : option.datum)) {
                            const nameFieldValue = option.datum[s.getDimensionField()[0]];
                            value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
                        }
                        return this.dataToLongitude(value);
                    },
                    getFields: () => [ this._longitudeField ],
                    getAxisType: () => this.type,
                    getAxisId: () => this.id,
                    isInverse: () => !1
                })), s.setYAxisHelper(Object.assign(Object.assign({}, helper), {
                    isContinuous: !0,
                    dataToPosition: (values, option) => {
                        var _a;
                        let value = values[0];
                        if ((0, vutils_1.isNil)(value) && (null == option ? void 0 : option.datum)) {
                            const nameFieldValue = option.datum[s.getDimensionField()[0]];
                            value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
                        }
                        return this.dataToLatitude(value);
                    },
                    valueToPosition: (value, option) => {
                        var _a;
                        if ((0, vutils_1.isNil)(value) && (null == option ? void 0 : option.datum)) {
                            const nameFieldValue = option.datum[s.getDimensionField()[0]];
                            value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
                        }
                        return this.dataToLatitude(value);
                    },
                    getFields: () => [ this._latitudeField ],
                    getAxisType: () => this.type,
                    getAxisId: () => this.id,
                    isInverse: () => !1
                })));
            }));
        }));
    }
    onLayoutEnd(ctx) {
        this.setLayoutRect(this._regions[0].getLayoutRect()), this.setLayoutStartPosition(this._regions[0].getLayoutStartPoint());
        const {width: width, height: height} = this.getLayoutRect(), {translate: translate, scale: scale, center: center} = this.evaluateProjection([ 0, 0 ], [ width, height ]);
        translate && this._projection.translate(translate), scale && this._projection.scale(scale), 
        center && this._projection.center(center), (0, model_1.eachSeries)(this._regions, (s => {
            var _a;
            if (s.type === type_2.SeriesTypeEnum.map) {
                s.areaPath.clear();
                const pathGroup = null === (_a = s.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
                pathGroup && pathGroup.attribute.postMatrix && pathGroup.setAttributes({
                    postMatrix: new vutils_1.Matrix
                });
            }
        })), this._actualScale = this._initialScale, super.onLayoutEnd(ctx);
    }
    onRender(ctx) {}
    changeRegions(regions) {}
    _getNeedClearVRenderComponents() {
        return [];
    }
    collectFeatures() {
        const features = [];
        return this._regions.forEach((r => {
            r.getSeries().forEach((s => {
                var _a, _b;
                s.type === type_2.SeriesTypeEnum.map && features.push(...null !== (_b = null === (_a = s.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []);
            }));
        })), features;
    }
    dataToPosition(values = []) {
        var _a;
        const point = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([ values[0], values[1] ]);
        return {
            x: null == point ? void 0 : point[0],
            y: null == point ? void 0 : point[1]
        };
    }
    dataToLatitude(lat) {
        var _a;
        const point = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([ 0, lat ]);
        return null == point ? void 0 : point[1];
    }
    dataToLongitude(lon) {
        var _a;
        const point = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([ lon, 0 ]);
        return null == point ? void 0 : point[0];
    }
    zoom(p, anchor = [ 0, 0 ]) {
        var _a, _b, _c, _d, _e, _f;
        let s = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.scale()) && void 0 !== _b ? _b : 0;
        const t = null !== (_d = null === (_c = this._projection) || void 0 === _c ? void 0 : _c.translate()) && void 0 !== _d ? _d : [ 0, 0 ];
        let t_x = t[0], t_y = t[1];
        s *= p, t_x -= (anchor[0] - t_x) * (p - 1), t_y -= (anchor[1] - t_y) * (p - 1), 
        null === (_e = this._projection) || void 0 === _e || _e.scale(s), null === (_f = this._projection) || void 0 === _f || _f.translate([ t_x, t_y ]);
    }
    shape(datum) {
        return this._projection.shape(datum);
    }
    invert(point) {
        return this._projection.invert(point);
    }
    evaluateProjection(start, size) {
        var _a;
        const evaluated = this._projection.evaluate(start, size, this.collectFeatures());
        let translate = evaluated.translate();
        const scale = evaluated.scale() * this._initialScale, center = null !== (_a = this._projectionSpec.center) && void 0 !== _a ? _a : evaluated.invert([ size[0] / 2, size[1] / 2 ]);
        return center && (translate = [ size[0] / 2, size[1] / 2 ]), {
            translate: translate,
            scale: scale,
            center: center
        };
    }
    _initCenterCache() {
        this._centerCache || (this._centerCache = new Map), this._regions.forEach((r => {
            r.getSeries().forEach((s => {
                var _a, _b;
                if ("map" === s.type) {
                    (null !== (_b = null === (_a = s.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []).forEach(((feature = {}) => {
                        const key = feature[s.getDimensionField()[0]] || feature[map_1.DEFAULT_MAP_LOOK_UP_KEY], center = s.getDatumCenter(feature);
                        key && (0, vutils_1.isValid)(center) && this._centerCache.set(key, {
                            x: center[0],
                            y: center[1]
                        });
                    }));
                }
            }));
        }));
    }
    release() {
        super.release(), this._centerCache && this._centerCache.clear(), this._centerCache = null;
    }
}

exports.GeoCoordinate = GeoCoordinate, GeoCoordinate.type = type_1.ComponentTypeEnum.geoCoordinate, 
(0, vutils_1.mixin)(GeoCoordinate, zoomable_1.Zoomable);

const registerGeoCoordinate = () => {
    factory_1.Factory.registerComponent(GeoCoordinate.type, GeoCoordinate);
};

exports.registerGeoCoordinate = registerGeoCoordinate;
//# sourceMappingURL=geo-coordinate.js.map
