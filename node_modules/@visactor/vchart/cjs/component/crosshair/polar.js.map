{"version":3,"sources":["../src/component/crosshair/polar.ts"],"names":[],"mappings":"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","file":"polar.js","sourcesContent":["/* eslint-disable no-duplicate-imports */\nimport type { IPolarSeries } from '../../series/interface/series';\nimport { mergeSpec } from '../../util/spec/merge-spec';\nimport type { IComponentOption } from '../interface';\nimport { ComponentTypeEnum } from '../interface/type';\nimport type { IPolarCrosshairSpec } from './interface';\nimport type { BandScale } from '@visactor/vscale';\nimport { isDiscrete, isContinuous } from '@visactor/vscale';\nimport { Tag } from '@visactor/vrender-components';\nimport { LineCrosshair, SectorCrosshair, CircleCrosshair, PolygonCrosshair } from '@visactor/vrender-components';\nimport type { IPolarAxis } from '../axis/polar/interface';\nimport type { IPoint, StringOrNumber } from '../../typings';\nimport type { IAxisInfo, IHair } from './base';\nimport { BaseCrossHair } from './base';\nimport type { Maybe } from '@visactor/vutils';\nimport {\n  polarToCartesian,\n  getIntersectPoint,\n  PointService,\n  getAngleByPoint,\n  isArray,\n  isValid,\n  isValidNumber,\n  isNil,\n  clamp\n} from '@visactor/vutils';\nimport type { IGraphic, IGroup, INode } from '@visactor/vrender-core';\nimport { angleLabelOrientAttribute, radiusLabelOrientAttribute } from '../../util/math';\nimport { limitTagInBounds } from './util';\nimport { getAxisLabelOffset } from '../axis/util';\nimport { Factory } from '../../core/factory';\nimport { LayoutType } from './config';\nimport type { IModelSpecInfo } from '../../model/interface';\n\ninterface ICrosshairInfo {\n  x: number;\n  y: number;\n  center: IPoint;\n  radius: number;\n  distance: number;\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  visible: boolean;\n  sides: number;\n  angle: number;\n  point: IPoint;\n  _isCache?: boolean;\n  label?: { visible: boolean; text: StringOrNumber; offset: number };\n  axis?: IPolarAxis;\n}\n\nexport class PolarCrossHair<T extends IPolarCrosshairSpec = IPolarCrosshairSpec> extends BaseCrossHair<T> {\n  static specKey = 'crosshair';\n\n  static type = ComponentTypeEnum.polarCrosshair;\n  type = ComponentTypeEnum.polarCrosshair;\n  name: string = ComponentTypeEnum.polarCrosshair;\n  private _currValueAngle: Map<number, { v: StringOrNumber; axis: IPolarAxis; [key: string]: any }>;\n  private _currValueRadius: Map<number, { v: StringOrNumber; axis: IPolarAxis; [key: string]: any }>;\n\n  private _angleHair: IHair | undefined;\n  private _radiusHair: (IHair & { smooth: boolean }) | undefined;\n\n  private _cacheAngleCrossHairInfo: ICrosshairInfo | undefined;\n  private _cacheRadiusCrossHairInfo: ICrosshairInfo | undefined;\n\n  private _radiusCrosshair: IGroup;\n  private _radiusLabelCrosshair: Tag;\n  private _angleCrosshair: IGroup;\n  private _angleLabelCrosshair: Tag;\n\n  static getSpecInfo(chartSpec: any): Maybe<IModelSpecInfo[]> {\n    const crosshairSpec = chartSpec[this.specKey];\n    if (isNil(crosshairSpec)) {\n      return undefined;\n    }\n    if (!isArray(crosshairSpec)) {\n      if (crosshairSpec.categoryField || crosshairSpec.valueField) {\n        return [\n          {\n            spec: crosshairSpec,\n            specPath: [this.specKey],\n            type: ComponentTypeEnum.polarCrosshair\n          }\n        ];\n      }\n      return undefined;\n    }\n    const specInfos: IModelSpecInfo[] = [];\n    crosshairSpec.forEach((s: IPolarCrosshairSpec, i: number) => {\n      if (s.categoryField || s.valueField) {\n        specInfos.push({\n          spec: s,\n          specIndex: i,\n          specPath: [this.specKey, i],\n          type: ComponentTypeEnum.polarCrosshair\n        });\n      }\n    });\n    return specInfos;\n  }\n\n  constructor(spec: T, options: IComponentOption) {\n    super(spec, options);\n    this._currValueAngle = new Map();\n    this._currValueRadius = new Map();\n  }\n\n  protected _showDefaultCrosshairBySpec() {\n    const { categoryField, valueField } = this._spec as IPolarCrosshairSpec;\n    if (categoryField?.visible && categoryField.defaultSelect) {\n      const { axisIndex, datum } = categoryField.defaultSelect;\n      this._defaultCrosshair(axisIndex, datum, LayoutType.VERTICAL);\n    }\n    if (valueField?.visible && valueField.defaultSelect) {\n      const { axisIndex, datum } = valueField.defaultSelect;\n      this._defaultCrosshair(axisIndex, datum, LayoutType.HORIZONTAL);\n    }\n  }\n\n  private _defaultCrosshair(axisIndex: number, datum: StringOrNumber, tag: number) {\n    const axis = this._option.getComponentsByKey('axes').find(c => c.getSpecIndex() === axisIndex) as IPolarAxis;\n    if (!axis) {\n      return;\n    }\n    // 横轴\n    if (tag === LayoutType.VERTICAL) {\n      this._currValueAngle.clear();\n      // 根据数值拿到对应的坐标点\n      const polarCoord = {\n        angle: axis.valueToPosition(datum),\n        radius: axis.getOuterRadius()\n      };\n      const canvasPosition = axis.coordToPoint(polarCoord);\n      this._currValueAngle.set(axisIndex, this._getValueByAxis(axis, canvasPosition));\n    } else {\n      this._currValueRadius.clear();\n      // 根据数值拿到对应的坐标点\n      const polarCoord = {\n        angle: axis.startAngle,\n        radius: axis.valueToPosition(datum)\n      };\n      const canvasPosition = axis.coordToPoint(polarCoord);\n      this._currValueRadius.set(axisIndex, this._getValueByAxis(axis, canvasPosition));\n    }\n    this.layoutByValue(LayoutType.ALL);\n  }\n\n  hide() {\n    this._radiusCrosshair && this._radiusCrosshair.hideAll();\n    this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll();\n    this._angleCrosshair && this._angleCrosshair.hideAll();\n    this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();\n  }\n\n  /**\n   * 查找所有落在x和y区域的轴\n   * @param relativeX\n   * @param relativeY\n   */\n  private _findAllAxisContains(relativeX: number, relativeY: number) {\n    const angleAxisMap = this._getAxisInfoByField<IPolarAxis>('category');\n    const radiusAxisMap = this._getAxisInfoByField<IPolarAxis>('value');\n    return {\n      angleAxisMap: this._filterAxisByPoint<IPolarAxis>(angleAxisMap, relativeX, relativeY),\n      radiusAxisMap: this._filterAxisByPoint<IPolarAxis>(radiusAxisMap, relativeX, relativeY)\n    };\n  }\n\n  /**\n   * 根据位置获取所有轴上的value\n   * @param axisMap\n   * @param p\n   * @returns\n   */\n  private _getAllAxisValues(\n    axisMap: IAxisInfo<IPolarAxis>,\n    point: IPoint,\n    currValue: Map<number, { v: StringOrNumber; axis: IPolarAxis; [key: string]: any }>\n  ): boolean {\n    // 首先不能存在两个离散轴\n    let discrete = false;\n    axisMap.forEach(item => {\n      if (isDiscrete(item.axis.getScale().type)) {\n        if (!discrete) {\n          discrete = true;\n        } else {\n          this.enable = false;\n        }\n      }\n    });\n    if (!this.enable) {\n      return false;\n    }\n    // 获取所有的value\n    axisMap.forEach((item, id) => {\n      const axis = item.axis;\n      currValue.set(id, this._getValueByAxis(axis, point));\n    });\n    return true;\n  }\n\n  private _getValueByAxis(axis: IPolarAxis, point: IPoint) {\n    const { x: axisStartX, y: axisStartY } = axis.getLayoutStartPoint();\n    const { x, y } = this.getLayoutStartPoint();\n    let value = axis.positionToData({\n      x: point.x - (axisStartX - x),\n      y: point.y - (axisStartY - y)\n    });\n    if (isContinuous(axis.getScale().type) && isValidNumber(+value)) {\n      value = (+value as number).toFixed(2);\n    }\n    const center = {\n      x: axis.getCenter().x + this.getLayoutStartPoint().x,\n      y: axis.getCenter().y + this.getLayoutStartPoint().y\n    };\n\n    return {\n      v: value,\n      axis,\n      center,\n      innerRadius: axis.getInnerRadius(),\n      radius: axis.getOuterRadius(),\n      startAngle: axis.startAngle,\n      endAngle: axis.endAngle,\n      distance: PointService.distancePP(point, axis.getCenter()),\n      coord: axis.pointToCoord(point),\n      point\n    };\n  }\n\n  protected _layoutCrosshair(relativeX: number, relativeY: number) {\n    // 找到所有的包含这个点的轴\n    const { angleAxisMap, radiusAxisMap } = this._findAllAxisContains(relativeX, relativeY);\n    if (angleAxisMap.size === 0 && radiusAxisMap.size === 0) {\n      if (this.enableRemain) {\n        return;\n      }\n      // 隐藏\n      this.hide();\n      return;\n    }\n    // 删除之前的currValue\n    this._currValueAngle.clear();\n    this._currValueRadius.clear();\n    // 将数据保存到这个对象中，如果不存在，就直接不执行后续逻辑\n    angleAxisMap && this._getAllAxisValues(angleAxisMap, { x: relativeX, y: relativeY }, this._currValueAngle);\n    radiusAxisMap && this._getAllAxisValues(radiusAxisMap, { x: relativeX, y: relativeY }, this._currValueRadius);\n\n    this.layoutByValue(LayoutType.ALL);\n  }\n\n  layoutByValue(tag: number = LayoutType.ALL) {\n    if (!this.enable) {\n      return;\n    }\n    // 获取axisHelper\n    const series = this._firstSeries<IPolarSeries>();\n    if (!series) {\n      return;\n    }\n    let angleCrossHairInfo = {\n      x: 0,\n      y: 0,\n      center: { x: 0, y: 0 },\n      radius: 0,\n      distance: 0,\n      startAngle: 0,\n      endAngle: 0,\n      innerRadius: 0,\n      visible: false,\n      label: { visible: false, text: '', offset: 0 }\n    } as ICrosshairInfo;\n    let radiusCrossHairInfo = {\n      x: 0,\n      y: 0,\n      center: { x: 0, y: 0 },\n      radius: 0,\n      distance: 0,\n      startAngle: 0,\n      endAngle: 0,\n      innerRadius: 0,\n      visible: false,\n      sides: (series.angleAxisHelper.getScale(0) as BandScale).ticks().length,\n      label: { visible: false, text: '', offset: 0 }\n    } as ICrosshairInfo;\n\n    // 计算x轴和y轴的数据，只允许最多一对x和一对y\n    if (this._angleHair) {\n      angleCrossHairInfo.visible = !!this._currValueAngle.size;\n      const bandWidth = series.angleAxisHelper.getBandwidth(0);\n      this._currValueAngle.forEach(({ axis, v, coord, ...rest }) => {\n        v = v ?? '';\n        mergeSpec(angleCrossHairInfo, rest);\n        const angle = series.angleAxisHelper.dataToPosition([v]);\n        angleCrossHairInfo.angle = angle;\n        if (this._angleHair.label?.visible) {\n          angleCrossHairInfo.label.visible = true;\n          angleCrossHairInfo.label.text = v;\n          angleCrossHairInfo.label.offset = getAxisLabelOffset(axis.getSpec());\n        }\n\n        angleCrossHairInfo.startAngle = angle - bandWidth / 2;\n        angleCrossHairInfo.endAngle = angle + bandWidth / 2;\n      });\n    }\n\n    if (this._radiusHair) {\n      radiusCrossHairInfo.visible = !!this._currValueRadius.size;\n      this._currValueRadius.forEach(({ axis, v, coord, ...rest }) => {\n        v = v ?? '';\n        if (this._radiusHair.label?.visible) {\n          radiusCrossHairInfo.label.visible = true;\n          radiusCrossHairInfo.label.text = v;\n          radiusCrossHairInfo.label.offset = getAxisLabelOffset(axis.getSpec());\n        }\n        radiusCrossHairInfo.angle = coord.angle;\n        radiusCrossHairInfo.axis = axis;\n        mergeSpec(radiusCrossHairInfo, rest);\n      });\n    }\n\n    if (this.enableRemain && !angleCrossHairInfo.visible && isValid(this._cacheAngleCrossHairInfo)) {\n      angleCrossHairInfo = this._cacheAngleCrossHairInfo;\n    } else {\n      if (this._angleHair?.label?.formatMethod && angleCrossHairInfo.label.visible) {\n        const { label } = angleCrossHairInfo;\n        label.text = this._angleHair.label.formatMethod(label.text, 'angle') as string;\n      }\n    }\n\n    if (this.enableRemain && !radiusCrossHairInfo.visible && isValid(this._cacheRadiusCrossHairInfo)) {\n      radiusCrossHairInfo = this._cacheRadiusCrossHairInfo;\n    } else {\n      if (this._radiusHair?.label?.formatMethod && radiusCrossHairInfo.label.visible) {\n        const { label } = radiusCrossHairInfo;\n        label.text = this._radiusHair.label.formatMethod(label.text, 'radius') as string;\n      }\n    }\n\n    if (tag) {\n      LayoutType.HORIZONTAL && this._layoutHorizontal(radiusCrossHairInfo);\n      LayoutType.VERTICAL && this._layoutVertical(angleCrossHairInfo);\n    }\n\n    if (this.enableRemain) {\n      this._cacheAngleCrossHairInfo = { ...angleCrossHairInfo, _isCache: true };\n      this._cacheRadiusCrossHairInfo = { ...radiusCrossHairInfo, _isCache: true };\n    }\n  }\n\n  private _layoutVertical(crosshairInfo: ICrosshairInfo) {\n    if (crosshairInfo._isCache && this.enableRemain) {\n      return;\n    }\n\n    const container = this.getContainer();\n    const { angle, innerRadius, radius, label, startAngle, endAngle, center, visible } = crosshairInfo;\n    if (visible) {\n      const crosshairType = this._angleHair.type === 'rect' ? 'sector' : 'line';\n      let positionAttrs;\n      if (crosshairType === 'sector') {\n        positionAttrs = {\n          center,\n          innerRadius,\n          radius,\n          startAngle: startAngle,\n          endAngle: endAngle\n        };\n      } else {\n        positionAttrs = {\n          start: polarToCartesian(center, innerRadius, angle),\n          end: polarToCartesian(center, radius, angle)\n        };\n      }\n\n      if (this._angleCrosshair) {\n        this._angleCrosshair.setAttributes(positionAttrs as unknown as any);\n      } else {\n        let crosshair;\n        // 创建\n        if (crosshairType === 'line') {\n          crosshair = new LineCrosshair({\n            ...(positionAttrs as { start: IPoint; end: IPoint }),\n            lineStyle: this._angleHair.style,\n            zIndex: this.gridZIndex\n          });\n        } else if (crosshairType === 'sector') {\n          crosshair = new SectorCrosshair({\n            ...(positionAttrs as {\n              center: IPoint;\n              innerRadius: number;\n              radius: number;\n              startAngle: number;\n              endAngle: number;\n            }),\n            sectorStyle: this._angleHair.style,\n            zIndex: this.gridZIndex\n          });\n        }\n        this._angleCrosshair = crosshair as unknown as IGroup;\n        // 添加至场景树\n        container.add(crosshair as unknown as INode);\n      }\n\n      // 文本\n      if (label.visible) {\n        const orient = angleLabelOrientAttribute(angle);\n        const labelAttrs = {\n          ...polarToCartesian(center, radius + label.offset, angle),\n          ...this._angleHair.label,\n          ...label,\n          textStyle: {\n            ...this._angleHair.label?.textStyle,\n            textAlign: orient.align,\n            textBaseline: orient.baseline\n          },\n          zIndex: this.labelZIndex\n        };\n        this._updateCrosshairLabel(this._angleLabelCrosshair, labelAttrs, label => {\n          label.name = 'crosshair-angle-label';\n          this._angleLabelCrosshair = label;\n        });\n      } else {\n        this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();\n      }\n    }\n  }\n\n  private _layoutHorizontal(crosshairInfo: ICrosshairInfo) {\n    if (crosshairInfo._isCache && this.enableRemain) {\n      return;\n    }\n\n    const { center, startAngle, endAngle, distance, sides, axis, label, point, radius, innerRadius, visible } =\n      crosshairInfo;\n    const container = this.getContainer();\n    if (visible) {\n      const crosshairType = this._radiusHair.smooth ? 'circle' : 'polygon';\n\n      let polygonRadius = distance;\n      if (crosshairType === 'polygon') {\n        const axisCenter = axis.getCenter();\n        // 需要计算半径\n        // 获取当前点的角度\n        const curAngle = getAngleByPoint(axisCenter, point);\n        const stepAngle = (endAngle - startAngle) / sides;\n        const index = Math.floor((curAngle - startAngle) / stepAngle);\n        const preAngle = index * stepAngle + startAngle;\n        const nextAngle = Math.min((index + 1) * stepAngle + startAngle, endAngle);\n\n        const prePoint = polarToCartesian(axisCenter, distance, preAngle);\n        const nextPoint = polarToCartesian(axisCenter, distance, nextAngle);\n        // 求交点\n        const insertPoint = getIntersectPoint(\n          [nextPoint.x, nextPoint.y],\n          [prePoint.x, prePoint.y],\n          [axisCenter.x, axisCenter.y],\n          [point.x, point.y]\n        );\n        if (insertPoint) {\n          polygonRadius = clamp(\n            PointService.distancePN(point, insertPoint[0], insertPoint[1]) + distance,\n            innerRadius,\n            radius\n          );\n        }\n      }\n      const positionAttrs = {\n        center,\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radius: polygonRadius,\n        sides\n      };\n\n      if (this._radiusCrosshair) {\n        this._radiusCrosshair.setAttributes(positionAttrs as unknown as any);\n      } else {\n        let crosshair;\n        if (crosshairType === 'polygon') {\n          crosshair = new PolygonCrosshair({\n            ...positionAttrs,\n            lineStyle: this._radiusHair.style,\n            zIndex: this.gridZIndex + 1 // 样式优化：线盖在面上\n          });\n        } else {\n          crosshair = new CircleCrosshair({\n            ...positionAttrs,\n            lineStyle: this._radiusHair.style,\n            zIndex: this.gridZIndex\n          });\n        }\n        this._radiusCrosshair = crosshair as unknown as IGroup;\n        // 添加至场景树\n        container.add(crosshair as unknown as INode);\n      }\n\n      // 文本\n      if (label.visible) {\n        const orient = radiusLabelOrientAttribute(startAngle);\n        const labelAttrs = {\n          ...polarToCartesian(center, polygonRadius, startAngle),\n          ...this._radiusHair.label,\n          ...label,\n          textStyle: {\n            ...this._radiusHair.label?.textStyle,\n            textAlign: orient.align,\n            textBaseline: orient.baseline\n          },\n          zIndex: this.labelZIndex\n        };\n        this._updateCrosshairLabel(this._radiusLabelCrosshair, labelAttrs, label => {\n          label.name = 'crosshair-radius-label';\n          this._radiusLabelCrosshair = label;\n        });\n      } else {\n        this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll();\n      }\n    }\n  }\n\n  protected _parseFieldInfo() {\n    const { categoryField, valueField } = this._spec as IPolarCrosshairSpec;\n    if (categoryField && categoryField.visible) {\n      this._angleHair = this._parseField(categoryField, 'categoryField');\n    }\n    if (valueField && valueField.visible) {\n      this._radiusHair = this._parseField(valueField, 'valueField');\n      this._radiusHair.smooth = valueField?.line?.smooth;\n    }\n  }\n\n  private _updateCrosshairLabel(label: Tag, labelAttrs: any, callback: (label: Tag) => void) {\n    // 文本\n    const container = this.getContainer();\n    if (label) {\n      label.setAttributes(labelAttrs);\n    } else {\n      label = new Tag(labelAttrs);\n      container?.add(label as unknown as INode);\n      callback(label);\n    }\n    limitTagInBounds(label, this._getLimitBounds());\n  }\n\n  protected _getNeedClearVRenderComponents(): IGraphic[] {\n    return [\n      this._radiusCrosshair,\n      this._radiusLabelCrosshair,\n      this._angleCrosshair,\n      this._angleLabelCrosshair\n    ] as unknown as IGroup[];\n  }\n}\n\nexport const registerPolarCrossHair = () => {\n  Factory.registerComponent(PolarCrossHair.type, PolarCrossHair);\n};\n"]}