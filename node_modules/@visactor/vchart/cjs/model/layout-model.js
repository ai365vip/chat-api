"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LayoutModel = void 0;

const vutils_1 = require("@visactor/vutils"), base_model_1 = require("./base-model"), layout_item_1 = require("../layout/layout-item");

class LayoutModel extends base_model_1.BaseModel {
    constructor() {
        super(...arguments), this.layoutType = "normal", this.layoutLevel = 0, this.layoutZIndex = 0, 
        this._forceLayoutTag = !1, this._layout = null, this._orient = null, this._layoutRect = {
            width: 0,
            height: 0
        }, this._layoutStartPos = {
            x: 0,
            y: 0
        }, this._isLayout = !0, this.getGraphicBounds = () => this._layout ? {
            x1: this._layout.getLayoutStartPoint().x,
            y1: this._layout.getLayoutStartPoint().y,
            x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
            y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
        } : {
            x1: 0,
            x2: 0,
            y1: 0,
            y2: 0
        }, this._transformLayoutRect = null, this._transformLayoutPosition = null;
    }
    get layoutOrient() {
        return this._orient;
    }
    set layoutOrient(v) {
        this._orient = v, this._layout && (this._layout.layoutOrient = v);
    }
    initLayout() {
        "none" !== this.layoutType && (this._layout = new layout_item_1.LayoutItem(this, {
            layoutType: this.layoutType,
            layoutLevel: this.layoutLevel,
            layoutOrient: this._orient,
            transformLayoutRect: this._transformLayoutRect,
            transformLayoutPosition: this._transformLayoutPosition
        }), this._orient && "radius" !== this._orient && "angle" !== this._orient && this.layout && (this._layout.layoutOrient = this._orient));
    }
    onLayoutStart(layoutRect, viewRect, ctx) {
        this._isLayout = !0, super.onLayoutStart(layoutRect, viewRect, ctx);
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this.updateLayoutAttribute();
        const layoutRect = this.getLayoutRect();
        !this._forceLayoutTag && (0, vutils_1.isEqual)(this._lastLayoutRect, layoutRect) || (this._lastLayoutRect = Object.assign({}, layoutRect)), 
        this._forceLayoutTag = !1, this._isLayout = !1;
    }
    afterSetLayoutStartPoint(_pos) {}
    _forceLayout() {
        var _a;
        this._isLayout || (this._forceLayoutTag = !0, null === (_a = this._option.globalInstance.getChart()) || void 0 === _a || _a.setLayoutTag(!0));
    }
    getLayoutStartPoint() {
        return this._layout ? this._layout.getLayoutStartPoint() : this._layoutStartPos;
    }
    setLayoutStartPosition(pos) {
        return this._layout ? this._layout.setLayoutStartPosition(pos) : this._layoutStartPos = (0, 
        vutils_1.merge)(this._layoutStartPos, pos);
    }
    getLayoutRect() {
        return this._layout ? this._layout.getLayoutRect() : this._layoutRect;
    }
    setLayoutRect(rect, levelMap) {
        return this._layout ? this._layout.setLayoutRect(rect) : this._lastLayoutRect = (0, 
        vutils_1.merge)(this._layoutRect, rect);
    }
    getLastComputeOutBounds() {
        var _a;
        return null === (_a = this._layout) || void 0 === _a ? void 0 : _a.getLastComputeOutBounds();
    }
    setAttrFromSpec() {
        var _a, _b, _c;
        super.setAttrFromSpec(), this.layoutClip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this.layoutClip, 
        this.layoutZIndex = null !== (_b = this._spec.zIndex) && void 0 !== _b ? _b : this.layoutZIndex, 
        this.layoutType = null !== (_c = this._spec.layoutType) && void 0 !== _c ? _c : this.layoutType;
    }
}

exports.LayoutModel = LayoutModel;
//# sourceMappingURL=layout-model.js.map
