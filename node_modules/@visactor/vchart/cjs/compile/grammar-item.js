"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.GrammarItem = void 0;

const vutils_1 = require("@visactor/vutils"), id_1 = require("../util/id"), compilable_base_1 = require("./compilable-base");

class GrammarItem extends compilable_base_1.CompilableBase {
    constructor() {
        super(...arguments), this.id = (0, id_1.createID)(), this._compiledProductId = null, 
        this._depend = [];
    }
    getProduct() {
        if ((0, vutils_1.isValid)(this._product)) return this._product;
        const view = this.getVGrammarView(), id = this.getProductId();
        return (0, vutils_1.isValid)(id) && (0, vutils_1.isValid)(view) && (this._product = this._lookupGrammar(id)), 
        this._product;
    }
    getProductId() {
        var _a;
        return null !== (_a = this._compiledProductId) && void 0 !== _a ? _a : this.generateProductId();
    }
    getDepend() {
        return this._depend;
    }
    setDepend(...depend) {
        this._depend = depend;
    }
    compile(option) {
        this._compileProduct(option), this._afterCompile(option);
    }
    _afterCompile(option) {
        var _a;
        (0, vutils_1.isValid)(this._product) && (null === (_a = this.getCompiler()) || void 0 === _a || _a.addGrammarItem(this));
    }
    updateDepend() {
        if ((0, vutils_1.isValid)(this._product)) {
            const depend = this.getDepend().map((item => item.getProduct())).filter(vutils_1.isValid);
            return this._product.depend(depend), depend.length === this.getDepend().length;
        }
        return !1;
    }
    release() {
        this.removeProduct(), super.release(), this._depend = [];
    }
    removeProduct(reserveVGrammarModel) {
        this.getCompiler().removeGrammarItem(this, reserveVGrammarModel), this._product = null, 
        this._compiledProductId = null;
    }
}

exports.GrammarItem = GrammarItem;