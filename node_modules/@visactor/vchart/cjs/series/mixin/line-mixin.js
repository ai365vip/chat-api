"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LineLikeSeriesMixin = void 0;

const base_1 = require("../../constant/base"), vdataset_1 = require("@visactor/vdataset"), event_1 = require("../../constant/event"), constant_1 = require("../../constant"), type_1 = require("../../mark/interface/type"), interpolate_1 = require("../../typings/interpolate"), space_1 = require("../../typings/space"), line_stroke_1 = require("../../typings/line-stroke"), utils_1 = require("../../animation/utils"), dimension_1 = require("../../event/events/dimension"), interface_1 = require("../../compile/mark/interface"), constant_2 = require("./constant"), spec_1 = require("../../util/spec");

class LineLikeSeriesMixin {
    addSamplingCompile() {
        if (this._spec.sampling) {
            const {width: width, height: height} = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
            samplingTrans.push({
                type: "sampling",
                size: this._direction === space_1.Direction.vertical ? width : height,
                factor: this._spec.samplingFactor,
                yfield: this._direction === space_1.Direction.vertical ? fieldsY[0] : fieldsX[0],
                groupBy: this._seriesField,
                mode: this._spec.sampling
            }), this._data.getProduct().transform(samplingTrans);
        }
    }
    addOverlapCompile() {
        var _a;
        if (this._spec.markOverlap) {
            const overlapTrans = [];
            overlapTrans.push({
                type: "markoverlap",
                direction: this._direction === space_1.Direction.horizontal && "cartesian" === this.coordinate ? 2 : 1,
                delta: this._spec.pointDis,
                deltaMul: this._spec.pointDisMul,
                groupBy: this._seriesField
            }), null === (_a = this._symbolMark) || void 0 === _a || _a.getProduct().transform(overlapTrans);
        }
    }
    reCompileSampling() {
        this._spec.sampling && this.compile();
    }
    initLineMark(progressive, isSeriesMark) {
        var _a;
        return this._lineMark = this._createMark(constant_2.lineLikeSeriesMark.line, {
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            isSeriesMark: null == isSeriesMark || isSeriesMark,
            progressive: progressive,
            customShape: null === (_a = this._spec.line) || void 0 === _a ? void 0 : _a.customShape
        }), this._lineMark;
    }
    initLineMarkStyle(direction, areaCurveType) {
        var _a, _b;
        const lineMark = this._lineMark;
        if (lineMark) {
            if (this.setMarkStyle(lineMark, {
                stroke: this.getColorAttribute()
            }, "normal", constant_1.AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(lineMark, {
                defined: this._getInvalidDefined,
                connectedType: this._getInvalidConnectType()
            }, "normal", constant_1.AttributeLevel.Series), this.event.on(event_1.ChartEvent.viewDataStatisticsUpdate, {
                filter: param => param.model === this
            }, (() => {
                this.encodeDefined(lineMark, "defined");
            })), "polar" === this.coordinate) this.setMarkStyle(lineMark, {
                lineJoin: line_stroke_1.DEFAULT_CLOSE_STROKE_JOIN,
                curveType: interpolate_1.DEFAULT_LINEAR_INTERPOLATE,
                closePath: !0
            }, "normal", constant_1.AttributeLevel.Series); else {
                const userCurveType = null != areaCurveType ? areaCurveType : null === (_b = null === (_a = this.getSpec().line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType, curveType = userCurveType === interpolate_1.DEFAULT_SMOOTH_INTERPOLATE ? direction === space_1.Direction.vertical ? "monotoneX" : "monotoneY" : userCurveType;
                this.setMarkStyle(lineMark, {
                    curveType: curveType
                }, "normal", constant_1.AttributeLevel.Built_In);
            }
            this.setMarkStyle(lineMark, {
                x: this.dataToPositionX.bind(this),
                y: this.dataToPositionY.bind(this),
                z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
            }, "normal", constant_1.AttributeLevel.Series), this._trigger.registerMark(lineMark);
        }
        return lineMark;
    }
    _getEventElement(params, reverse = !1) {
        let data = [];
        return params.dimensionInfo.some((df => (df.data.some((dd => dd.series === this && (data = dd.datum, 
        !0))), !data.length))), data;
    }
    _dimensionTrigger(params) {
        const elements = this._getEventElement(params);
        switch (params.action) {
          case "enter":
            this._symbolActiveMark.getDataView().parse(elements), this._symbolActiveMark.getData().updateData(!1);
            break;

          case "leave":
            this._symbolActiveMark.getDataView().parse([]), this._symbolActiveMark.getData().updateData(!1);
        }
    }
    initSymbolMark(progressive, isSeriesMark) {
        var _a, _b, _c;
        if (!1 !== (null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.visible) && (this._symbolMark = this._createMark(constant_2.lineLikeSeriesMark.point, {
            morph: (0, utils_1.shouldMarkDoMorph)(this._spec, constant_2.lineLikeSeriesMark.point.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            progressive: progressive,
            isSeriesMark: !!isSeriesMark,
            customShape: null === (_b = this._spec.point) || void 0 === _b ? void 0 : _b.customShape
        })), !0 === this._spec.activePoint) {
            const activeData = new vdataset_1.DataView(this._option.dataSet, {
                name: `${base_1.PREFIX}_series_${this.id}_active_point`
            });
            activeData.parse([]), this._symbolActiveMark = this._createMark({
                name: "active_point",
                type: type_1.MarkTypeEnum.symbol
            }, {
                morph: !1,
                groupKey: this._seriesField,
                isSeriesMark: !1,
                dataView: activeData,
                parent: this._region.getInteractionMark(),
                customShape: null === (_c = this._spec.point) || void 0 === _c ? void 0 : _c.customShape
            }), this._symbolActiveMark.setVisible(!1);
        }
        return this._symbolMark;
    }
    initSymbolMarkStyle() {
        const symbolMark = this._symbolMark;
        if (!symbolMark) return this._initSymbolActiveMarkAlone(), symbolMark;
        if (this._initSymbolMark(symbolMark), this._trigger.registerMark(symbolMark), this._symbolActiveMark && this._symbolMark.stateStyle.dimension_hover) {
            this._symbolActiveMark.setVisible(!0), this.event.on(dimension_1.DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this));
            for (const state in this._symbolMark.stateStyle) {
                this._symbolActiveMark.stateStyle[state] = {};
                for (const key in this._symbolMark.stateStyle[state]) this._symbolActiveMark.stateStyle[state][key] = {
                    style: null,
                    level: constant_1.AttributeLevel.Series,
                    referer: symbolMark
                };
            }
            this._symbolActiveMark.state.changeStateInfo({
                stateValue: interface_1.STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
                filter: () => !0
            });
        }
        return symbolMark;
    }
    _initSymbolMark(symbolMark) {
        symbolMark && (this.setMarkStyle(symbolMark, {
            fill: this.getColorAttribute()
        }, "normal", constant_1.AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
            visible: this._getInvalidDefined
        }, "normal", constant_1.AttributeLevel.Series), this.event.on(event_1.ChartEvent.viewDataStatisticsUpdate, {
            filter: param => param.model === this
        }, (() => {
            this.encodeDefined(symbolMark, "visible");
        })), this.setMarkStyle(symbolMark, {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }, "normal", constant_1.AttributeLevel.Series));
    }
    _initSymbolActiveMarkAlone() {
        var _a, _b;
        const symbolMark = this._symbolActiveMark;
        symbolMark && (this._initSymbolMark(symbolMark), symbolMark && (null === (_b = null === (_a = this._spec[constant_2.lineLikeSeriesMark.point.name]) || void 0 === _a ? void 0 : _a.state) || void 0 === _b ? void 0 : _b.dimension_hover) && (symbolMark.setVisible(!0), 
        this.event.on(dimension_1.DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this)), 
        this.initMarkStyleWithSpec(symbolMark, (0, spec_1.mergeSpec)({}, this._spec[constant_2.lineLikeSeriesMark.point.name], {
            visible: !0
        })), this._symbolActiveMark.state.changeStateInfo({
            stateValue: interface_1.STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
            filter: () => !0
        })));
    }
    initLabelMarkStyle(labelMark) {
        var _a;
        labelMark && ("symbol" !== (null === (_a = labelMark.getTarget()) || void 0 === _a ? void 0 : _a.type) && labelMark.setRule("line-data"), 
        this.setMarkStyle(labelMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getStackValueField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
            visible: this._getInvalidDefined
        }, "normal", constant_1.AttributeLevel.Series), this.event.on(event_1.ChartEvent.viewDataStatisticsUpdate, {
            filter: param => param.model === this
        }, (() => {
            this.encodeDefined(labelMark, "visible");
        })));
    }
    initLineLabelMarkStyle(labelMark) {
        labelMark && this.setMarkStyle(labelMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getSeriesField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        });
    }
    encodeDefined(mark, attr) {
        var _a, _b, _c, _d, _e, _f;
        if (!mark) return;
        const statistics = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[this.getStackValueField()];
        if ("zero" === this._invalidType || statistics && (null == statistics ? void 0 : statistics.allValid)) {
            if (!0 === (null === (_d = null === (_c = mark.stateStyle.normal) || void 0 === _c ? void 0 : _c[attr]) || void 0 === _d ? void 0 : _d.style)) return;
            this.setMarkStyle(mark, {
                [attr]: !0
            }, "normal", constant_1.AttributeLevel.Series);
        } else {
            if (!0 !== (null === (_f = null === (_e = mark.stateStyle.normal) || void 0 === _e ? void 0 : _e[attr]) || void 0 === _f ? void 0 : _f.style)) return;
            this.setMarkStyle(mark, {
                [attr]: this._getInvalidDefined
            }, "normal", constant_1.AttributeLevel.Series);
        }
        mark.getProduct() && mark.compileEncode();
    }
}

exports.LineLikeSeriesMixin = LineLikeSeriesMixin;
//# sourceMappingURL=line-mixin.js.map
