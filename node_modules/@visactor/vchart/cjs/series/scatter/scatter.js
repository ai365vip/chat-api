"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerScatterSeries = exports.ScatterSeries = void 0;

const base_1 = require("../../constant/base"), cartesian_1 = require("../cartesian/cartesian"), vutils_1 = require("@visactor/vutils"), constant_1 = require("../../constant"), type_1 = require("../interface/type"), interface_1 = require("../../compile/mark/interface"), scatter_1 = require("../../constant/scatter"), utils_1 = require("../../animation/utils"), animation_1 = require("./animation"), symbol_1 = require("../../mark/symbol"), constant_2 = require("./constant"), factory_1 = require("../../core/factory"), scatter_transformer_1 = require("./scatter-transformer"), utils_2 = require("../util/utils");

class ScatterSeries extends cartesian_1.CartesianSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.scatter, this.transformerConstructor = scatter_transformer_1.ScatterSeriesSpecTransformer, 
        this._invalidType = "zero";
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._size = this._spec.size, this._sizeField = this._spec.sizeField, 
        this._shape = this._spec.shape, this._shapeField = this._spec.shapeField;
    }
    _getSeriesAttribute(field, spec, {defaultScaleType: defaultScaleType, defaultRange: defaultRange}, key) {
        var _a, _b, _c, _d;
        if ((0, vutils_1.isFunction)(spec)) return spec;
        if ((0, vutils_1.isArray)(spec)) {
            if ((0, vutils_1.isNil)(field)) return null === (_a = this._option) || void 0 === _a || _a.onError(`${key}Field is required.`), 
            spec;
            if ("ordinal" !== defaultScaleType && spec.length > 2) return null === (_b = this._option) || void 0 === _b || _b.onError(`${key} length is invalid, specify up to 2 ${key}s.`), 
            spec;
            const scaleName = `${base_1.PREFIX}_series_scatter_${this.id}_scale_${key}`;
            return this._option.globalScale.registerModelScale({
                id: scaleName,
                type: defaultScaleType,
                domain: [ {
                    dataId: this._rawData.name,
                    fields: [ field ]
                } ],
                range: spec
            }), {
                scale: scaleName,
                field: field
            };
        }
        if ((0, vutils_1.isObject)(spec)) {
            if ((0, vutils_1.isNil)(field)) return null === (_c = this._option) || void 0 === _c || _c.onError(`${key}Field is required.`), 
            spec;
            const scaleName = `${base_1.PREFIX}_series_scatter_${this.id}_scale_${key}`, visualSpec = Object.assign({
                id: scaleName,
                type: defaultScaleType,
                domain: [ {
                    dataId: this._rawData.name,
                    fields: [ field ]
                } ],
                range: defaultRange
            }, spec);
            return this._option.globalScale.registerModelScale(visualSpec), {
                scale: visualSpec.id,
                field: field
            };
        }
        return null === (_d = this._option) || void 0 === _d || _d.onError(`${key} attribute is invalid.`), 
        spec;
    }
    getSizeAttribute(field, sizeSpec) {
        return (0, vutils_1.isNil)(sizeSpec) ? scatter_1.SCATTER_DEFAULT_SIZE : (0, vutils_1.isNumber)(sizeSpec) ? sizeSpec : (0, 
        vutils_1.isString)(sizeSpec) && (0, vutils_1.isNumeric)(sizeSpec) ? parseFloat(sizeSpec) : this._getSeriesAttribute(field, sizeSpec, {
            defaultScaleType: scatter_1.SCATTER_DEFAULT_SIZE_SCALE_TYPE,
            defaultRange: scatter_1.SCATTER_DEFAULT_RANGE_SIZE
        }, "size");
    }
    getShapeAttribute(field, shapeSpec) {
        return (0, vutils_1.isNil)(shapeSpec) ? scatter_1.SCATTER_DEFAULT_SHAPE : (0, vutils_1.isString)(shapeSpec) ? shapeSpec : this._getSeriesAttribute(field, shapeSpec, {
            defaultScaleType: scatter_1.SCATTER_DEFAULT_SHAPE_SCALE_TYPE,
            defaultRange: scatter_1.SCATTER_DEFAULT_RANGE_SHAPE
        }, "shape");
    }
    initMark() {
        var _a;
        const progressive = {
            progressiveStep: this._spec.progressiveStep,
            progressiveThreshold: this._spec.progressiveThreshold,
            large: this._spec.large,
            largeThreshold: this._spec.largeThreshold
        };
        this._symbolMark = this._createMark(ScatterSeries.mark.point, {
            morph: (0, utils_1.shouldMarkDoMorph)(this._spec, ScatterSeries.mark.point.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            progressive: progressive,
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.customShape
        });
    }
    initMarkStyle() {
        this.initSymbolMarkStyle();
    }
    initAnimation() {
        var _a, _b, _c;
        const animationParams = (0, utils_2.getGroupAnimationParams)(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._symbolMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("scatter")) || void 0 === _c ? void 0 : _c({}, appearPreset), (0, 
        utils_1.userAnimationConfig)(type_1.SeriesMarkNameEnum.point, this._spec, this._markAttributeContext), animationParams));
    }
    initSymbolMarkStyle() {
        const symbolMark = this._symbolMark;
        symbolMark && ("zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
            visible: this._getInvalidDefined
        }), this.setMarkStyle(symbolMark, {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
            fill: this.getColorAttribute(),
            size: (0, vutils_1.isNumber)(this._size) || (0, vutils_1.isFunction)(this._size) ? this._size : scatter_1.SCATTER_DEFAULT_SIZE,
            symbolType: (0, vutils_1.isString)(this._shape) || (0, vutils_1.isFunction)(this._shape) ? this._shape : scatter_1.SCATTER_DEFAULT_SHAPE
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.Series), 
        ((0, vutils_1.isValid)(this._sizeField) || (0, vutils_1.isValid)(this._size)) && this.setMarkStyle(symbolMark, {
            size: this.getSizeAttribute(this._sizeField, this._size)
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.User_Mark), 
        ((0, vutils_1.isValid)(this._shapeField) || (0, vutils_1.isValid)(this._shape)) && this.setMarkStyle(symbolMark, {
            symbolType: this.getShapeAttribute(this._shapeField, this._shape)
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.User_Mark), 
        this._trigger.registerMark(symbolMark));
    }
    initTooltip() {
        super.initTooltip(), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
    }
    viewDataStatisticsUpdate(d) {
        super.viewDataStatisticsUpdate(d);
        const allValid = [ this.getDimensionField()[0], this.getStackValueField() ].every((field => {
            var _a, _b, _c;
            return field && (null === (_c = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[field]) || void 0 === _c ? void 0 : _c.allValid);
        }));
        "zero" === this._invalidType || allValid ? this.setMarkStyle(this._symbolMark, {
            visible: !0
        }, "normal", constant_1.AttributeLevel.Series) : this.setMarkStyle(this._symbolMark, {
            visible: this._getInvalidDefined
        }, "normal", constant_1.AttributeLevel.Series);
    }
    initLabelMarkStyle(labelMark) {
        labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getStackValueField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.Series), 
        "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
            visible: this._getInvalidDefined
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.Series));
    }
    handleZoom(e) {
        var _a, _b;
        this.getMarksWithoutRoot().forEach((mark => {
            const vGrammarMark = mark.getProduct();
            if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
            vGrammarMark.elements.forEach(((el, i) => {
                const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
                newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
            }));
        }));
        const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
        vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
    }
    handlePan(e) {
        var _a, _b;
        this.getMarksWithoutRoot().forEach((mark => {
            const vGrammarMark = mark.getProduct();
            if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
            vGrammarMark.elements.forEach(((el, i) => {
                const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
                newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
            }));
        }));
        const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
        vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [ this._symbolMark ];
    }
}

exports.ScatterSeries = ScatterSeries, ScatterSeries.type = type_1.SeriesTypeEnum.scatter, 
ScatterSeries.mark = constant_2.scatterSeriesMark, ScatterSeries.transformerConstructor = scatter_transformer_1.ScatterSeriesSpecTransformer;

const registerScatterSeries = () => {
    (0, symbol_1.registerSymbolMark)(), (0, animation_1.registerScatterAnimation)(), 
    factory_1.Factory.registerSeries(ScatterSeries.type, ScatterSeries);
};

exports.registerScatterSeries = registerScatterSeries;
//# sourceMappingURL=scatter.js.map
