"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerRoseSeries = exports.RoseSeries = exports.DefaultBandWidth = void 0;

const scale_1 = require("../../util/scale"), utils_1 = require("../../animation/utils"), type_1 = require("../interface/type"), animation_1 = require("./animation"), rose_like_1 = require("../polar/rose-like"), arc_1 = require("../../mark/arc"), constant_1 = require("./constant"), factory_1 = require("../../core/factory"), rose_transformer_1 = require("./rose-transformer");

exports.DefaultBandWidth = .5;

class RoseSeries extends rose_like_1.RoseLikeSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.rose, this.transformerConstructor = rose_transformer_1.RoseSeriesSpecTransformer, 
        this._supportStack = !0, this._roseMark = null, this._labelMark = null;
    }
    initMark() {
        this.initRoseMark();
    }
    initMarkStyle() {
        this.initRoseMarkStyle();
    }
    _buildMarkAttributeContext() {
        super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y
        }), this._markAttributeContext.startAngleScale = datum => this.startAngleScale(datum), 
        this._markAttributeContext.endAngleScale = datum => this.endAngleScale(datum);
    }
    initRoseMark() {
        var _a;
        this._roseMark = this._createMark(RoseSeries.mark.rose, {
            morph: (0, utils_1.shouldMarkDoMorph)(this._spec, RoseSeries.mark.rose.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.rose) || void 0 === _a ? void 0 : _a.customShape
        });
    }
    getRoseAngle() {
        var _a, _b, _c;
        return null !== (_c = null === (_b = (_a = this.angleAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _c ? _c : exports.DefaultBandWidth;
    }
    startAngleScale(datum) {
        return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) - .5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
    }
    endAngleScale(datum) {
        return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + this.getRoseAngle() - .5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
    }
    initRoseMarkStyle() {
        const roseMark = this._roseMark;
        roseMark && (this.setMarkStyle(roseMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: datum => this.startAngleScale(datum),
            endAngle: datum => this.endAngleScale(datum),
            fill: this.getColorAttribute(),
            outerRadius: datum => (0, scale_1.valueInScaleRange)(this.radiusAxisHelper.dataToPosition([ datum[this._radiusField[0]] ]), this.radiusAxisHelper.getScale(0)),
            innerRadius: datum => {
                var _a;
                if (!this._stack) return 0;
                const stackStart = (0, scale_1.valueInScaleRange)(this.radiusAxisHelper.dataToPosition([ datum[this._innerRadiusField[0]] ]), this.radiusAxisHelper.getScale(0));
                return stackStart <= Number.MIN_VALUE ? this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0) : stackStart;
            }
        }), this._trigger.registerMark(roseMark));
    }
    initTooltip() {
        super.initTooltip(), this._roseMark && this._tooltipHelper.activeTriggerSet.mark.add(this._roseMark);
    }
    initLabelMarkStyle(textMark) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        textMark && this.setMarkStyle(textMark, {
            visible: null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.visible,
            text: datum => datum[this.getDimensionField()[0]],
            fill: (null === (_d = null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.fill) || this.getColorAttribute(),
            angle: null === (_f = null === (_e = this._spec.label) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.angle,
            limit: null === (_h = null === (_g = this._spec.label) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.limit,
            z: 0
        });
    }
    initAnimation() {
        var _a, _b, _c;
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        if (this._roseMark) {
            const animationParams = {
                innerRadius: () => {
                    var _a;
                    return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
                }
            };
            this._roseMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("rose")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), (0, 
            utils_1.userAnimationConfig)(type_1.SeriesMarkNameEnum.rose, this._spec, this._markAttributeContext)));
        }
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [ this._roseMark ];
    }
}

exports.RoseSeries = RoseSeries, RoseSeries.type = type_1.SeriesTypeEnum.rose, RoseSeries.mark = constant_1.roseSeriesMark, 
RoseSeries.transformerConstructor = rose_transformer_1.RoseSeriesSpecTransformer;

const registerRoseSeries = () => {
    factory_1.Factory.registerSeries(RoseSeries.type, RoseSeries), (0, arc_1.registerArcMark)(), 
    (0, animation_1.registerRoseAnimation)();
};

exports.registerRoseSeries = registerRoseSeries;
//# sourceMappingURL=rose.js.map
