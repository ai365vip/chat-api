"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerSunBurstSeries = exports.SunburstSeries = void 0;

const vutils_1 = require("@visactor/vutils"), animation_1 = require("./animation"), register_1 = require("../../data/register"), flatten_1 = require("../../data/transforms/flatten"), sunburst_1 = require("../../data/transforms/sunburst"), type_1 = require("../interface/type"), type_2 = require("../../mark/interface/type"), constant_1 = require("../../constant"), interface_1 = require("../../compile/mark/interface"), hierarchy_1 = require("../../constant/hierarchy"), config_1 = require("../../animation/config"), data_key_1 = require("../../data/transforms/data-key"), add_property_1 = require("../../data/transforms/add-property"), utils_1 = require("../../animation/utils"), polar_1 = require("../polar/polar"), sunburst_2 = require("../../constant/sunburst"), tooltip_helper_1 = require("./tooltip-helper"), drillable_1 = require("../../interaction/drill/drillable"), arc_1 = require("../../mark/arc"), text_1 = require("../../mark/text"), constant_2 = require("./constant"), factory_1 = require("../../core/factory");

class SunburstSeries extends polar_1.PolarSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.sunburst;
    }
    setCategoryField(f) {
        return this._categoryField = f, this._categoryField;
    }
    getCategoryField() {
        return this._categoryField;
    }
    setValueField(f) {
        return this._valueField = f, this._valueField;
    }
    getValueField() {
        return this._valueField;
    }
    getDimensionField() {
        return [ this._categoryField ];
    }
    getMeasureField() {
        return [ this._valueField ];
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), 
        this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : hierarchy_1.DEFAULT_HIERARCHY_ROOT), 
        this._spec.drill && this.initDrillable({
            event: this.event,
            mode: this._option.mode,
            drillField: () => {
                var _a;
                return null !== (_a = this._spec.drillField) && void 0 !== _a ? _a : constant_1.DEFAULT_DATA_KEY;
            },
            getRawData: () => this.getRawData()
        }), this._startAngle = (0, vutils_1.degreeToRadian)(this._spec.startAngle), this._endAngle = (0, 
        vutils_1.degreeToRadian)(this._spec.endAngle), this._centerX = this._spec.centerX, 
        this._centerY = this._spec.centerY, this._offsetX = this._spec.offsetX, this._offsetY = this._spec.offsetY, 
        this.__innerRadius = this._spec.innerRadius, this.__outerRadius = this._spec.outerRadius, 
        this._gap = this._spec.gap, this._labelLayout = this._spec.labelLayout, this._sunburst = this._spec.sunburst, 
        this._label = this._spec.label, this._labelAutoVisible = this._spec.labelAutoVisible;
    }
    initData() {
        super.initData();
        const rawData = this.getRawData();
        rawData && (this._spec.drill && this.initDrillableData(this._dataSet), (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "sunburstLayout", sunburst_1.sunburstLayout), 
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "flatten", flatten_1.flatten), 
        rawData.transform({
            type: "sunburstLayout",
            options: () => {
                const {innerRadius: innerRadius, outerRadius: outerRadius, gap: gap, label: label} = this._computeLevel();
                return {
                    nodeKey: this._categoryField,
                    width: this.getLayoutRect().width,
                    height: this.getLayoutRect().height,
                    center: [ (0, vutils_1.isValid)(this._centerX) ? this._centerX : this.getLayoutRect().width / 2, (0, 
                    vutils_1.isValid)(this._centerY) ? this._centerY : this.getLayoutRect().height / 2 ],
                    startAngle: this._startAngle,
                    endAngle: this._endAngle,
                    innerRadius: innerRadius,
                    outerRadius: outerRadius,
                    gapRadius: gap,
                    label: label
                };
            }
        }), rawData.transform({
            type: "flatten",
            options: {
                callback: node => {
                    if (node.datum) {
                        const nodeData = node.datum[node.depth];
                        return Object.assign(Object.assign({}, node), nodeData);
                    }
                    return node;
                }
            }
        }));
    }
    getStatisticFields() {
        return super.getStatisticFields().concat([ {
            key: this._categoryField,
            operations: [ "values" ]
        }, {
            key: this._valueField,
            operations: [ "max", "min" ]
        }, {
            key: hierarchy_1.DEFAULT_HIERARCHY_DEPTH,
            operations: [ "max", "min", "values" ]
        }, {
            key: hierarchy_1.DEFAULT_HIERARCHY_ROOT,
            operations: [ "values" ]
        } ]);
    }
    _addDataIndexAndKey() {
        const rawData = this.getRawData();
        (0, vutils_1.isNil)(null == rawData ? void 0 : rawData.dataSet) || ((0, register_1.registerDataSetInstanceTransform)(rawData.dataSet, "addVChartProperty", add_property_1.addVChartProperty), 
        rawData.transform({
            type: "addVChartProperty",
            options: {
                beforeCall: data_key_1.initHierarchyKeyMap.bind(this),
                call: data_key_1.addHierarchyDataKey
            }
        }));
    }
    initMark() {
        this._initArcMark(), this._initLabelMark();
    }
    initMarkStyle() {
        this._initArcMarkStyle(), this._initLabelMarkStyle();
    }
    _initArcMark() {
        var _a;
        if (!1 === this._sunburst.visible) return;
        const sunburstMark = this._createMark(SunburstSeries.mark.sunburst, {
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.sunburst) || void 0 === _a ? void 0 : _a.customShape
        });
        this._sunburstMark = sunburstMark, this._trigger.registerMark(this._sunburstMark);
    }
    _initArcMarkStyle() {
        (0, vutils_1.isNil)(this._sunburstMark) || this.setMarkStyle(this._sunburstMark, {
            x: d => d.x + ((0, vutils_1.isValid)(this._offsetX) ? this._offsetX : 0),
            y: d => d.y + ((0, vutils_1.isValid)(this._offsetY) ? this._offsetY : 0),
            outerRadius: d => d.outerRadius,
            innerRadius: d => d.innerRadius,
            startAngle: d => d.startAngle,
            endAngle: d => d.endAngle,
            fill: this.getColorAttribute()
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.Series);
    }
    _initLabelMark() {
        if (!0 !== this._label.visible) return;
        const labelMark = this._createMark(SunburstSeries.mark.label, {
            isSeriesMark: !1
        });
        this._labelMark = labelMark, this._trigger.registerMark(labelMark);
    }
    _initLabelMarkStyle() {
        (0, vutils_1.isNil)(this._labelMark) || this.setMarkStyle(this._labelMark, {
            visible: d => {
                var _a;
                const labelAutoVisible = this._labelAutoVisible;
                return (0, vutils_1.isObject)(labelAutoVisible) && !0 === labelAutoVisible.enable ? (d.endAngle - d.startAngle) * (d.outerRadius - d.innerRadius) > (null !== (_a = null == labelAutoVisible ? void 0 : labelAutoVisible.circumference) && void 0 !== _a ? _a : sunburst_2.SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD) : this._spec.label.visible;
            },
            x: d => {
                var _a;
                return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.x) + ((0, vutils_1.isValid)(this._offsetX) ? this._offsetX : 0);
            },
            y: d => {
                var _a;
                return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.y) + ((0, vutils_1.isValid)(this._offsetY) ? this._offsetY : 0);
            },
            textBaseline: d => {
                var _a;
                return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textBaseline;
            },
            textAlign: d => {
                var _a;
                return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textAlign;
            },
            angle: d => {
                var _a, _b;
                return null !== (_b = null === (_a = d.label) || void 0 === _a ? void 0 : _a.angle) && void 0 !== _b ? _b : 0;
            },
            fontSize: 10,
            text: d => d.name
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.Series);
    }
    initTooltip() {
        this._tooltipHelper = new tooltip_helper_1.SunburstTooltipHelper(this), this._sunburstMark && this._tooltipHelper.activeTriggerSet.mark.add(this._sunburstMark), 
        this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
    }
    initAnimation() {
        var _a, _b;
        const animationParams = {
            animationInfo: () => ({
                innerRadius: this._computeRadius((0, vutils_1.array)(this.__innerRadius))[0],
                outerRadius: this._computeRadius((0, vutils_1.array)(this.__outerRadius))[0],
                startAngle: (0, vutils_1.array)(this._startAngle)[0],
                endAngle: (0, vutils_1.array)(this._endAngle)[0]
            })
        }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this.getMarksInType(type_2.MarkTypeEnum.arc).forEach((mark => {
            var _a;
            mark.setAnimationConfig((0, utils_1.animationConfig)(null === (_a = factory_1.Factory.getAnimationInKey("sunburst")) || void 0 === _a ? void 0 : _a(animationParams, appearPreset), (0, 
            utils_1.userAnimationConfig)(mark.name, this._spec, this._markAttributeContext)));
        })), this.getMarksInType(type_2.MarkTypeEnum.text).forEach((mark => {
            var _a;
            mark.setAnimationConfig((0, utils_1.animationConfig)(null === (_a = factory_1.Factory.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), (0, 
            utils_1.userAnimationConfig)(mark.name, this._spec, this._markAttributeContext)));
        }));
    }
    initEvent() {
        super.initEvent(), this._spec.drill && this.bindDrillEvent();
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
    }
    _computeRadius(radius) {
        if ((0, vutils_1.isArray)(radius)) return radius.map((r => {
            const {width: width, height: height} = this.getRegion().getLayoutRect();
            return Math.min(width / 2, height / 2) * r;
        }));
        const {width: width, height: height} = this.getRegion().getLayoutRect();
        return Math.min(width / 2, height / 2) * radius;
    }
    _computeLevel() {
        return {
            innerRadius: this._computeRadius(this.__innerRadius),
            outerRadius: this._computeRadius(this.__outerRadius),
            gap: this._gap,
            label: this._labelLayout
        };
    }
    getGroupFields() {
        return [];
    }
    getStackGroupFields() {
        return [];
    }
    getStackValueField() {
        return "";
    }
    _noAnimationDataKey(datum, index) {}
    getActiveMarks() {
        return [ this._sunburstMark ];
    }
}

exports.SunburstSeries = SunburstSeries, SunburstSeries.type = type_1.SeriesTypeEnum.sunburst, 
SunburstSeries.mark = constant_2.sunburstSeriesMark, (0, vutils_1.mixin)(SunburstSeries, drillable_1.Drillable);

const registerSunBurstSeries = () => {
    factory_1.Factory.registerSeries(SunburstSeries.type, SunburstSeries), (0, arc_1.registerArcMark)(), 
    (0, text_1.registerTextMark)(), (0, config_1.registerFadeInOutAnimation)(), (0, 
    animation_1.registerSunburstAnimation)();
};

exports.registerSunBurstSeries = registerSunBurstSeries;
//# sourceMappingURL=sunburst.js.map
