"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerRangeColumnSeries = exports.RangeColumnSeries = exports.DefaultBandWidth = void 0;

const bar_1 = require("../bar/bar"), type_1 = require("../../mark/interface/type"), type_2 = require("../interface/type"), space_1 = require("../../typings/space"), rect_1 = require("../../mark/rect"), text_1 = require("../../mark/text"), label_mark_1 = require("../util/label-mark"), utils_1 = require("../../animation/utils"), tooltip_helper_1 = require("./tooltip-helper"), config_1 = require("../../animation/config"), interface_1 = require("./interface"), animation_1 = require("./animation"), constant_1 = require("./constant"), factory_1 = require("../../core/factory"), utils_2 = require("../util/utils"), range_column_transformer_1 = require("./range-column-transformer");

exports.DefaultBandWidth = 6;

class RangeColumnSeries extends bar_1.BarSeries {
    constructor() {
        super(...arguments), this.type = type_2.SeriesTypeEnum.rangeColumn, this._barMarkType = type_1.MarkTypeEnum.rect, 
        this._barName = type_2.SeriesTypeEnum.bar, this.transformerConstructor = range_column_transformer_1.RangeColumnSeriesSpecTransformer, 
        this._stack = !1;
    }
    initMark() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this._initBarBackgroundMark();
        const labelPosition = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.position;
        this._barMark = this._createMark(RangeColumnSeries.mark.bar, {
            morph: (0, utils_1.shouldMarkDoMorph)(this._spec, RangeColumnSeries.mark.bar.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            isSeriesMark: !0,
            customShape: null === (_b = this._spec.bar) || void 0 === _b ? void 0 : _b.customShape
        }), !1 !== (null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.visible) && labelPosition === interface_1.PositionEnum.bothEnd && (!1 !== (null === (_e = null === (_d = this._spec.label) || void 0 === _d ? void 0 : _d.minLabel) || void 0 === _e ? void 0 : _e.visible) && (this._minLabelMark = this._createMark(RangeColumnSeries.mark.minLabel, {
            markSpec: null === (_f = this._spec.label) || void 0 === _f ? void 0 : _f.minLabel
        })), !1 !== (null === (_h = null === (_g = this._spec.label) || void 0 === _g ? void 0 : _g.maxLabel) || void 0 === _h ? void 0 : _h.visible) && (this._maxLabelMark = this._createMark(RangeColumnSeries.mark.maxLabel, {
            markSpec: null === (_j = this._spec.label) || void 0 === _j ? void 0 : _j.maxLabel
        })));
    }
    initMarkStyle() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super.initMarkStyle();
        const minLabelMark = this._minLabelMark, minLabelSpec = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.minLabel;
        if (minLabelMark) {
            this.setMarkStyle(minLabelMark, {
                fill: null !== (_c = null === (_b = null == minLabelSpec ? void 0 : minLabelSpec.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
                text: datum => {
                    const min = this._spec.direction === space_1.Direction.horizontal ? datum[this._spec.xField[0]] : datum[this._spec.yField[0]];
                    return (null == minLabelSpec ? void 0 : minLabelSpec.formatMethod) ? minLabelSpec.formatMethod(min, datum) : min;
                }
            });
            const position = null !== (_d = null == minLabelSpec ? void 0 : minLabelSpec.position) && void 0 !== _d ? _d : "end", offset = null !== (_e = null == minLabelSpec ? void 0 : minLabelSpec.offset) && void 0 !== _e ? _e : "vertical" === this._direction ? -20 : -25;
            (0, label_mark_1.setRectLabelPos)(this, minLabelMark, position, offset, (datum => this._barMark.getAttribute("x", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum)), (datum => this._barMark.getAttribute("y", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum)), (() => this._direction));
        }
        const maxLabelMark = this._maxLabelMark, maxLabelSpec = null === (_f = this._spec.label) || void 0 === _f ? void 0 : _f.maxLabel;
        if (maxLabelMark) {
            this.setMarkStyle(maxLabelMark, {
                fill: null !== (_h = null === (_g = null == maxLabelSpec ? void 0 : maxLabelSpec.style) || void 0 === _g ? void 0 : _g.fill) && void 0 !== _h ? _h : this.getColorAttribute(),
                text: datum => {
                    const max = this._spec.direction === space_1.Direction.horizontal ? datum[this._spec.xField[1]] : datum[this._spec.yField[1]];
                    return (null == maxLabelSpec ? void 0 : maxLabelSpec.formatMethod) ? maxLabelSpec.formatMethod(max, datum) : max;
                }
            });
            const position = null !== (_j = null == maxLabelSpec ? void 0 : maxLabelSpec.position) && void 0 !== _j ? _j : "start", offset = null !== (_k = null == maxLabelSpec ? void 0 : maxLabelSpec.offset) && void 0 !== _k ? _k : "vertical" === this._direction ? -20 : -25;
            (0, label_mark_1.setRectLabelPos)(this, maxLabelMark, position, offset, (datum => this._barMark.getAttribute("x", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum)), (datum => this._barMark.getAttribute("y", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum)), (() => this._direction));
        }
    }
    initLabelMarkStyle(labelMark) {
        labelMark && (this.setMarkStyle(labelMark, {
            text: datum => {
                let min, max;
                return this._spec.direction === space_1.Direction.horizontal ? (min = datum[this._spec.xField[0]], 
                max = datum[this._spec.xField[1]]) : (min = datum[this._spec.yField[0]], max = datum[this._spec.yField[1]]), 
                min + "-" + max;
            },
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }), this._labelMark = labelMark);
    }
    _dataToPosX(datum) {
        return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[0]), {
            bandPosition: this._bandPosition
        });
    }
    _dataToPosX1(datum) {
        return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
            bandPosition: this._bandPosition
        });
    }
    _dataToPosY(datum) {
        return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[0]), {
            bandPosition: this._bandPosition
        });
    }
    _dataToPosY1(datum) {
        return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
            bandPosition: this._bandPosition
        });
    }
    initAnimation() {
        var _a, _b, _c, _d, _e;
        const animationParams = (0, utils_2.getGroupAnimationParams)(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._barMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("rangeColumn")) || void 0 === _c ? void 0 : _c({
            direction: this.direction
        }, appearPreset), (0, utils_1.userAnimationConfig)(type_2.SeriesMarkNameEnum.bar, this._spec, this._markAttributeContext), animationParams)), 
        this._minLabelMark && this._minLabelMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_d = factory_1.Factory.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), (0, 
        utils_1.userAnimationConfig)(type_2.SeriesMarkNameEnum.label, this._spec, this._markAttributeContext), animationParams)), 
        this._maxLabelMark && this._maxLabelMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_e = factory_1.Factory.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), (0, 
        utils_1.userAnimationConfig)(type_2.SeriesMarkNameEnum.label, this._spec, this._markAttributeContext), animationParams));
    }
    initTooltip() {
        this._tooltipHelper = new tooltip_helper_1.RangeColumnSeriesTooltipHelper(this), 
        this._barMark && this._tooltipHelper.activeTriggerSet.mark.add(this._barMark), this._minLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._minLabelMark), 
        this._maxLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._maxLabelMark), 
        this._labelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._labelMark);
    }
}

exports.RangeColumnSeries = RangeColumnSeries, RangeColumnSeries.type = type_2.SeriesTypeEnum.rangeColumn, 
RangeColumnSeries.mark = constant_1.rangeColumnSeriesMark, RangeColumnSeries.transformerConstructor = range_column_transformer_1.RangeColumnSeriesSpecTransformer;

const registerRangeColumnSeries = () => {
    (0, rect_1.registerRectMark)(), (0, text_1.registerTextMark)(), (0, animation_1.registerRangeColumnAnimation)(), 
    (0, config_1.registerFadeInOutAnimation)(), factory_1.Factory.registerSeries(RangeColumnSeries.type, RangeColumnSeries);
};

exports.registerRangeColumnSeries = registerRangeColumnSeries;
//# sourceMappingURL=range-column.js.map
