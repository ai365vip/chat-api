"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerPieSeries = exports.PieSeries = exports.BasePieSeries = void 0;

const vutils_1 = require("@visactor/vutils"), vdataset_1 = require("@visactor/vdataset"), constant_1 = require("../../constant"), math_1 = require("../../util/math"), scale_1 = require("../../util/scale"), object_1 = require("../../util/object"), polar_1 = require("../polar/polar"), type_1 = require("../../mark/interface/type"), type_2 = require("../interface/type"), pie_1 = require("../../data/transforms/pie"), register_1 = require("../../data/register"), animation_1 = require("./animation/animation"), utils_1 = require("../../animation/utils"), interface_1 = require("../../animation/interface"), series_data_1 = require("../base/series-data"), centerOffset_1 = require("./animation/centerOffset"), arc_1 = require("../../mark/arc"), constant_2 = require("./constant"), factory_1 = require("../../core/factory"), vutils_2 = require("@visactor/vutils"), pie_transformer_1 = require("./pie-transformer");

class BasePieSeries extends polar_1.PolarSeries {
    constructor() {
        super(...arguments), this.transformerConstructor = pie_transformer_1.PieSeriesSpecTransformer, 
        this._pieMarkName = type_2.SeriesMarkNameEnum.pie, this._pieMarkType = type_1.MarkTypeEnum.arc, 
        this._startAngle = constant_1.POLAR_START_RADIAN, this._endAngle = constant_1.POLAR_END_RADIAN, 
        this._pieMark = null, this._labelMark = null, this._labelLineMark = null, this.dataToCentralPosition = datum => {
            const angle = datum[constant_1.ARC_MIDDLE_ANGLE];
            if ((0, vutils_2.isNil)(angle)) return null;
            const radius = this.computeDatumRadius(datum), innerRadius = this.computeDatumInnerRadius(datum), center = this.computeCenter(datum), delta = (0, 
            math_1.polarToCartesian)({
                angle: angle,
                radius: (radius + innerRadius) / 2
            });
            return {
                x: center.x + delta.x,
                y: center.y + delta.y
            };
        };
    }
    get center() {
        var _a, _b, _c, _d;
        return {
            x: null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerX) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2,
            y: null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.centerY) && void 0 !== _d ? _d : this._region.getLayoutRect().height / 2
        };
    }
    _buildMarkAttributeContext() {
        super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
            x: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2;
            },
            y: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : this._region.getLayoutRect().height / 2;
            }
        }), this._markAttributeContext.startAngleScale = datum => this.startAngleScale(datum), 
        this._markAttributeContext.endAngleScale = datum => this.endAngleScale(datum);
    }
    setAttrFromSpec() {
        var _a, _b;
        super.setAttrFromSpec(), this._centerOffset = null !== (_a = this._spec.centerOffset) && void 0 !== _a ? _a : 0, 
        this._cornerRadius = null !== (_b = this._spec.cornerRadius) && void 0 !== _b ? _b : 0;
        const normalized = (0, math_1.normalizeStartEndAngle)((0, vutils_1.isValid)(this._spec.startAngle) ? (0, 
        vutils_1.degreeToRadian)(this._spec.startAngle) : this._startAngle, (0, vutils_1.isValid)(this._spec.endAngle) ? (0, 
        vutils_1.degreeToRadian)(this._spec.endAngle) : this._endAngle);
        this._startAngle = normalized.startAngle, this._endAngle = normalized.endAngle, 
        this._padAngle = (0, vutils_1.isValid)(this._spec.padAngle) ? (0, vutils_1.degreeToRadian)(this._spec.padAngle) : 0, 
        this.setAngleField(this._spec.valueField || this._spec.angleField), this._spec.categoryField && this.setSeriesField(this._spec.categoryField), 
        this._radiusField = [], this._specAngleField = this._angleField.slice(), this._specRadiusField = [];
    }
    initData() {
        super.initData();
        const viewData = this.getViewData();
        if (!viewData) return;
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "pie", pie_1.pie), 
        viewData.transform({
            type: "pie",
            options: {
                angleField: this._angleField[0],
                startAngle: this._startAngle,
                endAngle: this._endAngle,
                minAngle: (0, vutils_1.isValid)(this._spec.minAngle) ? (0, vutils_1.degreeToRadian)(this._spec.minAngle) : 0,
                asStartAngle: constant_1.ARC_START_ANGLE,
                asEndAngle: constant_1.ARC_END_ANGLE,
                asRatio: constant_1.ARC_RATIO,
                asMiddleAngle: constant_1.ARC_MIDDLE_ANGLE,
                asRadian: constant_1.ARC_RADIAN,
                asQuadrant: constant_1.ARC_QUADRANT,
                asK: constant_1.ARC_K
            }
        }, !1);
        const viewDataLabel = new vdataset_1.DataView(this._dataSet, {
            name: `${constant_1.PREFIX}_series_${this.id}_viewDataLabel`
        });
        viewDataLabel.parse([ this.getViewData() ], {
            type: "dataview"
        }), this._viewDataLabel = new series_data_1.SeriesData(this._option, viewDataLabel);
    }
    initMark() {
        var _a;
        this._pieMark = this._createMark(Object.assign(Object.assign({}, BasePieSeries.mark.pie), {
            name: this._pieMarkName,
            type: this._pieMarkType
        }), {
            morph: (0, utils_1.shouldMarkDoMorph)(this._spec, this._pieMarkName),
            defaultMorphElementKey: this._seriesField,
            key: constant_1.DEFAULT_DATA_KEY,
            groupKey: this._seriesField,
            skipBeforeLayouted: !0,
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.pie) || void 0 === _a ? void 0 : _a.customShape
        });
    }
    startAngleScale(datum) {
        return (0, object_1.field)(constant_1.ARC_START_ANGLE)(datum);
    }
    endAngleScale(datum) {
        return (0, object_1.field)(constant_1.ARC_END_ANGLE)(datum);
    }
    initMarkStyle() {
        const pieMark = this._pieMark;
        pieMark && (this.setMarkStyle(pieMark, {
            x: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2;
            },
            y: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : this._region.getLayoutRect().height / 2;
            },
            fill: this.getColorAttribute(),
            outerRadius: (0, scale_1.isSpecValueWithScale)(this._outerRadius) ? this._outerRadius : () => this.computeLayoutRadius() * this._outerRadius,
            innerRadius: (0, scale_1.isSpecValueWithScale)(this._innerRadius) ? this._innerRadius : () => this.computeLayoutRadius() * this._innerRadius,
            cornerRadius: () => this.computeLayoutRadius() * this._cornerRadius,
            startAngle: datum => this.startAngleScale(datum),
            endAngle: datum => this.endAngleScale(datum),
            padAngle: this._padAngle,
            centerOffset: this._centerOffset
        }, "normal", constant_1.AttributeLevel.Series), this._trigger.registerMark(pieMark));
    }
    initTooltip() {
        super.initTooltip(), this._pieMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pieMark);
    }
    initMarkStyleWithSpec(mark, spec, key) {
        if (super.initMarkStyleWithSpec(mark, spec, key), mark.name === this._pieMarkName) {
            const pieSpec = this.getSpec()[mark.name];
            if (pieSpec) for (const state in pieSpec.state || {}) this.setMarkStyle(mark, this.generateRadiusStyle(pieSpec.state[state]), state, constant_1.AttributeLevel.User_Mark);
        }
    }
    initLabelMarkStyle(textMark) {
        var _a, _b, _c, _d, _e, _f;
        textMark && this.setMarkStyle(textMark, {
            visible: (0, object_1.field)(constant_1.DEFAULT_LABEL_VISIBLE).bind(this),
            text: datum => datum[this.getDimensionField()[0]],
            fill: (null === (_b = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) || this.getColorAttribute(),
            angle: null === (_d = null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.angle,
            limit: null === (_f = null === (_e = this._spec.label) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.limit,
            z: this.dataToPositionZ.bind(this)
        });
    }
    afterInitMark() {
        super.afterInitMark(), this._trigger.setStateKeys([ this._seriesField, ...this._radiusField ]);
    }
    initEvent() {
        var _a;
        super.initEvent(), null === (_a = this._viewDataLabel.getDataView()) || void 0 === _a || _a.target.addListener("change", this.viewDataLabelUpdate.bind(this));
    }
    initGroups() {}
    onLayoutEnd(ctx) {
        this._viewDataLabel.getDataView().reRunAllTransform(), this.onMarkPositionUpdate(), 
        super.onLayoutEnd(ctx);
    }
    getDimensionField() {
        return this._seriesField ? [ this._seriesField ] : [];
    }
    getMeasureField() {
        return this._specAngleField;
    }
    viewDataLabelUpdate() {
        this.event.emit(constant_1.ChartEvent.viewDataLabelUpdate, {
            model: this
        }), this._viewDataLabel.updateData();
    }
    generateRadiusStyle(spec) {
        if (!spec) return;
        const style = {};
        return spec.outerRadius && (style.outerRadius = () => this.computeLayoutRadius() * spec.outerRadius), 
        spec.innerRadius && (style.innerRadius = () => this.computeLayoutRadius() * spec.innerRadius), 
        spec.cornerRadius && (style.cornerRadius = () => this.computeLayoutRadius() * spec.cornerRadius), 
        style;
    }
    computeLayoutRadius() {
        const {width: width, height: height} = this._region.getLayoutRect();
        return Math.min(width / 2, height / 2);
    }
    computeCenter(datum) {
        return {
            x: this._pieMark.getAttribute("x", datum, "normal"),
            y: this._pieMark.getAttribute("y", datum, "normal")
        };
    }
    getRadius(state = "normal") {
        var _a, _b, _c, _d, _e, _f, _g;
        const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.outerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.outerRadius;
        return null != styleRadius ? styleRadius : this._outerRadius;
    }
    getInnerRadius(state = "normal") {
        var _a, _b, _c, _d, _e, _f, _g;
        const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.innerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.innerRadius;
        return null != styleRadius ? styleRadius : this._innerRadius;
    }
    computeRadius(r, k) {
        return this.computeLayoutRadius() * r * ((0, vutils_2.isNil)(k) ? 1 : k) + this._centerOffset;
    }
    computeDatumRadius(datum, state) {
        return this.computeLayoutRadius() * this.getRadius(state) + this._centerOffset;
    }
    _compareSpec(spec, prevSpec, ignoreCheckKeys) {
        (ignoreCheckKeys = null != ignoreCheckKeys ? ignoreCheckKeys : {
            data: !0
        }).centerX = !0, ignoreCheckKeys.centerX = !0, ignoreCheckKeys.centerY = !0, ignoreCheckKeys.centerOffset = !0, 
        ignoreCheckKeys.radius = !0, ignoreCheckKeys.innerRadius = !0, ignoreCheckKeys.cornerRadius = !0, 
        ignoreCheckKeys.startAngle = !0, ignoreCheckKeys.endAngle = !0, ignoreCheckKeys.padAngle = !0;
        const {centerX: centerX, centerY: centerY, centerOffset: centerOffset, radius: radius, innerRadius: innerRadius, cornerRadius: cornerRadius, startAngle: startAngle, endAngle: endAngle, padAngle: padAngle} = prevSpec, result = super._compareSpec(spec, prevSpec, ignoreCheckKeys);
        return (spec = null != spec ? spec : {}).centerY === centerY && spec.centerX === centerX && spec.centerOffset === centerOffset && spec.radius === radius && spec.innerRadius === innerRadius && spec.cornerRadius === cornerRadius && spec.startAngle === startAngle && spec.endAngle === endAngle && spec.padAngle === padAngle || (result.reRender = !0, 
        result.change = !0), result;
    }
    computeDatumInnerRadius(datum, state) {
        return this.computeLayoutRadius() * this.getInnerRadius(state) + this._centerOffset;
    }
    dataToPosition(datum) {
        const angle = datum[constant_1.ARC_MIDDLE_ANGLE];
        if ((0, vutils_2.isNil)(angle)) return null;
        const radius = this.computeDatumRadius(datum), center = this.computeCenter(datum), delta = (0, 
        math_1.polarToCartesian)({
            angle: angle,
            radius: radius
        });
        return {
            x: center.x + delta.x,
            y: center.y + delta.y
        };
    }
    initAnimation() {
        var _a, _b;
        const animationParams = {
            growFrom: (datum, element, state) => {
                var _a;
                if (state === interface_1.AnimationStateEnum.appear) return this._startAngle;
                if (state === interface_1.AnimationStateEnum.disappear) return this._endAngle;
                const outState = [ interface_1.AnimationStateEnum.disappear, interface_1.AnimationStateEnum.exit ], markElements = element.mark.elements, data = datum, dataIndex = null == data ? void 0 : data[constant_1.DEFAULT_DATA_INDEX];
                if (void 0 === markElements.find((e => {
                    var _a;
                    return (null === (_a = e.data[0]) || void 0 === _a ? void 0 : _a[constant_1.DEFAULT_DATA_INDEX]) < dataIndex;
                }))) return this._startAngle;
                if (void 0 === markElements.find((e => {
                    var _a;
                    return (null === (_a = e.data[0]) || void 0 === _a ? void 0 : _a[constant_1.DEFAULT_DATA_INDEX]) > dataIndex;
                }))) return this._endAngle;
                const prevMarkElement = [ ...markElements ].reverse().find((e => {
                    var _a;
                    return (null === (_a = e.data[0]) || void 0 === _a ? void 0 : _a[constant_1.DEFAULT_DATA_INDEX]) < dataIndex;
                }));
                return outState.includes(state) ? null === (_a = null == prevMarkElement ? void 0 : prevMarkElement.getNextGraphicAttributes()) || void 0 === _a ? void 0 : _a.endAngle : null == prevMarkElement ? void 0 : prevMarkElement.getGraphicAttribute("endAngle", !0);
            }
        }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
        if (this._pieMark) {
            const pieAnimationConfig = (0, utils_1.animationConfig)(null === (_b = factory_1.Factory.getAnimationInKey("pie")) || void 0 === _b ? void 0 : _b(animationParams, appearPreset), (0, 
            utils_1.userAnimationConfig)(type_2.SeriesMarkNameEnum.pie, this._spec, this._markAttributeContext));
            pieAnimationConfig.normal && pieAnimationConfig.normal.type && (pieAnimationConfig.normal = (0, 
            centerOffset_1.centerOffsetConfig)(this._pieMark, pieAnimationConfig.normal)), this._pieMark.setAnimationConfig(pieAnimationConfig);
        }
    }
    getDefaultShapeType() {
        return "circle";
    }
    getGroupFields() {
        return [];
    }
    getStackGroupFields() {
        return [];
    }
    getStackValueField() {
        return "";
    }
    _noAnimationDataKey(datum, index) {
        return index;
    }
    getActiveMarks() {
        return [ this._pieMark ];
    }
}

exports.BasePieSeries = BasePieSeries, BasePieSeries.transformerConstructor = pie_transformer_1.PieSeriesSpecTransformer, 
BasePieSeries.mark = constant_2.pieSeriesMark;

class PieSeries extends BasePieSeries {
    constructor() {
        super(...arguments), this.type = type_2.SeriesTypeEnum.pie;
    }
}

exports.PieSeries = PieSeries, PieSeries.type = type_2.SeriesTypeEnum.pie;

const registerPieSeries = () => {
    (0, arc_1.registerArcMark)(), (0, animation_1.registerPieAnimation)(), factory_1.Factory.registerSeries(PieSeries.type, PieSeries);
};

exports.registerPieSeries = registerPieSeries;
//# sourceMappingURL=pie.js.map
