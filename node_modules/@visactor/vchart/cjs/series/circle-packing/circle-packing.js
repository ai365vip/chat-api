"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerCirclePackingSeries = exports.CirclePackingSeries = void 0;

const vutils_1 = require("@visactor/vutils"), factory_1 = require("../../core/factory"), type_1 = require("../interface/type"), cartesian_1 = require("../cartesian/cartesian"), register_1 = require("../../data/register"), circle_packing_1 = require("../../data/transforms/circle-packing"), type_2 = require("../../mark/interface/type"), interface_1 = require("../../compile/mark/interface"), constant_1 = require("../../constant"), hierarchy_1 = require("../../constant/hierarchy"), flatten_1 = require("../../data/transforms/flatten"), tooltip_helper_1 = require("./tooltip-helper"), data_key_1 = require("../../data/transforms/data-key"), add_property_1 = require("../../data/transforms/add-property"), utils_1 = require("../../animation/utils"), config_1 = require("../../animation/config"), animation_1 = require("./animation"), drillable_1 = require("../../interaction/drill/drillable"), arc_1 = require("../../mark/arc"), text_1 = require("../../mark/text"), constant_2 = require("./constant");

class CirclePackingSeries extends cartesian_1.CartesianSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.circlePacking;
    }
    setCategoryField(f) {
        return this._categoryField = f, this._categoryField;
    }
    getCategoryField() {
        return this._categoryField;
    }
    setValueField(f) {
        return this._valueField = f, this._valueField;
    }
    getValueField() {
        return this._valueField;
    }
    getDimensionField() {
        return [ this._categoryField ];
    }
    getMeasureField() {
        return [ this._valueField ];
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), 
        this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : hierarchy_1.DEFAULT_HIERARCHY_ROOT), 
        this._spec.drill && this.initDrillable({
            event: this.event,
            mode: this._option.mode,
            drillField: () => {
                var _a;
                return null !== (_a = this._spec.drillField) && void 0 !== _a ? _a : constant_1.DEFAULT_DATA_KEY;
            },
            getRawData: () => this.getRawData()
        }), this._circlePacking = this._spec.circlePacking, this._label = this._spec.label, 
        this._layoutPadding = this._spec.layoutPadding;
    }
    initData() {
        super.initData();
        const rawData = this.getRawData();
        (0, vutils_1.isNil)(rawData) || (this._spec.drill && this.initDrillableData(this._dataSet), 
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "circlePackingLayout", circle_packing_1.circlePackingLayout), 
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "flatten", flatten_1.flatten), 
        rawData.transform({
            type: "circlePackingLayout",
            options: () => ({
                nodeKey: this._categoryField,
                padding: this._layoutPadding,
                includeRoot: !1,
                width: this.getLayoutRect().width || 1,
                height: this.getLayoutRect().height || 1
            })
        }), rawData.transform({
            type: "flatten",
            options: {
                callback: node => {
                    if (node.datum) {
                        const nodeData = node.datum[node.depth];
                        return Object.assign(Object.assign({}, node), nodeData);
                    }
                    return node;
                }
            }
        }));
    }
    _addDataIndexAndKey() {
        const rawData = this.getRawData();
        (0, vutils_1.isNil)(null == rawData ? void 0 : rawData.dataSet) || ((0, register_1.registerDataSetInstanceTransform)(rawData.dataSet, "addVChartProperty", add_property_1.addVChartProperty), 
        rawData.transform({
            type: "addVChartProperty",
            options: {
                beforeCall: data_key_1.initHierarchyKeyMap.bind(this),
                call: data_key_1.addHierarchyDataKey
            }
        }));
    }
    initMark() {
        this._initCirclePackingMark(), this._initLabelMark();
    }
    initMarkStyle() {
        this._initCirclePackingMarkStyle(), this._initLabelMarkStyle();
    }
    _initCirclePackingMark() {
        var _a, _b;
        if (!1 === (null === (_a = this._circlePacking) || void 0 === _a ? void 0 : _a.visible)) return;
        const circlePacking = this._createMark(CirclePackingSeries.mark.circlePacking, {
            isSeriesMark: !0,
            customShape: null === (_b = this._spec.circlePacking) || void 0 === _b ? void 0 : _b.customShape
        });
        this._circlePackingMark = circlePacking, this._trigger.registerMark(circlePacking);
    }
    _initCirclePackingMarkStyle() {
        (0, vutils_1.isNil)(this._circlePackingMark) || this.setMarkStyle(this._circlePackingMark, {
            x: d => d.x,
            y: d => d.y,
            outerRadius: d => d.radius,
            innerRadius: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            fill: this.getColorAttribute(),
            zIndex: d => d.depth
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.Series);
    }
    _initLabelMark() {
        var _a;
        if (!1 === (null === (_a = this._label) || void 0 === _a ? void 0 : _a.visible)) return;
        const labelMark = this._createMark(CirclePackingSeries.mark.label, {
            isSeriesMark: !1
        });
        this._labelMark = labelMark, this._trigger.registerMark(labelMark);
    }
    _initLabelMarkStyle() {
        (0, vutils_1.isNil)(this._labelMark) || this.setMarkStyle(this._labelMark, {
            x: d => d.x,
            y: d => d.y,
            text: d => d.key,
            cursor: "pointer"
        }, interface_1.STATE_VALUE_ENUM.STATE_NORMAL, constant_1.AttributeLevel.Series);
    }
    getStatisticFields() {
        return super.getStatisticFields().concat([ {
            key: this._categoryField,
            operations: [ "values" ]
        }, {
            key: this._valueField,
            operations: [ "max", "min" ]
        }, {
            key: hierarchy_1.DEFAULT_HIERARCHY_DEPTH,
            operations: [ "max", "min", "values" ]
        }, {
            key: hierarchy_1.DEFAULT_HIERARCHY_ROOT,
            operations: [ "values" ]
        } ]);
    }
    initTooltip() {
        this._tooltipHelper = new tooltip_helper_1.CirclePackingTooltipHelper(this), this._tooltipHelper.updateTooltipSpec(), 
        this._circlePackingMark && this._tooltipHelper.activeTriggerSet.mark.add(this._circlePackingMark), 
        this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
    }
    initAnimation() {
        var _a;
        const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
        this.getMarksInType(type_2.MarkTypeEnum.arc).forEach((mark => {
            var _a;
            mark.setAnimationConfig((0, utils_1.animationConfig)(null === (_a = factory_1.Factory.getAnimationInKey("circlePacking")) || void 0 === _a ? void 0 : _a(void 0, appearPreset), (0, 
            utils_1.userAnimationConfig)(mark.name, this._spec, this._markAttributeContext)));
        })), this.getMarksInType(type_2.MarkTypeEnum.text).forEach((mark => {
            var _a;
            mark.setAnimationConfig((0, utils_1.animationConfig)(null === (_a = factory_1.Factory.getAnimationInKey("scaleInOut")) || void 0 === _a ? void 0 : _a(), (0, 
            utils_1.userAnimationConfig)(mark.name, this._spec, this._markAttributeContext)));
        }));
    }
    initEvent() {
        super.initEvent(), this._spec.drill && this.bindDrillEvent();
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
    }
    _noAnimationDataKey(datum, index) {}
    getActiveMarks() {
        return [ this._circlePackingMark ];
    }
}

exports.CirclePackingSeries = CirclePackingSeries, CirclePackingSeries.type = type_1.SeriesTypeEnum.circlePacking, 
CirclePackingSeries.mark = constant_2.circlePackingSeriesMark, (0, vutils_1.mixin)(CirclePackingSeries, drillable_1.Drillable);

const registerCirclePackingSeries = () => {
    factory_1.Factory.registerSeries(CirclePackingSeries.type, CirclePackingSeries), 
    (0, arc_1.registerArcMark)(), (0, text_1.registerTextMark)(), (0, config_1.registerScaleInOutAnimation)(), 
    (0, animation_1.registerCirclePackingAnimation)();
};

exports.registerCirclePackingSeries = registerCirclePackingSeries;
//# sourceMappingURL=circle-packing.js.map
