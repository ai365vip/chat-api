{"version":3,"sources":["../src/mark/group.ts"],"names":[],"mappings":"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","file":"group.js","sourcesContent":["import { Factory } from './../core/factory';\nimport type { Maybe } from '../typings';\n// eslint-disable-next-line no-duplicate-imports\nimport { warn } from '../util/debug';\nimport type { IGroupMarkSpec } from '../typings/visual';\nimport { BaseMark } from './base/base-mark';\nimport type { IMark, IMarkRaw, IMarkStyle, MarkType } from './interface';\n// eslint-disable-next-line no-duplicate-imports\nimport { MarkTypeEnum } from './interface/type';\nimport { registerGroupGraphic, type IGroupMark as IVGrammarGroupMark } from '@visactor/vgrammar-core';\nimport type { IMarkCompileOption } from '../compile/mark';\n\nexport interface IGroupMark extends IMarkRaw<IGroupMarkSpec> {\n  // groupMark的zIndex只能配在外层，encode里不生效，且无法写成signal\n  // {type:'group', zIndex: 100} ✅\n  // {type:'group', encode:{enter:{zIndex:{value:100}}}} ❌\n  // {type:'group', zIndex: {signal: }} ❌\n\n  addMark: (m: IMark) => boolean;\n  removeMark: (m: IMark) => boolean;\n  // TODO: 这里可能会出现mark嵌套的问题\n  getMarks: () => IMark[];\n  getMarkInType: (type: MarkType) => IMark[];\n  getMarkInId: (id: number) => IMark | undefined;\n  getMarkInName: (name: string) => IMark | undefined;\n}\n\nexport class GroupMark extends BaseMark<IGroupMarkSpec> implements IGroupMark {\n  static readonly type = MarkTypeEnum.group;\n  readonly type = GroupMark.type;\n  protected _marks: IMark[] = [];\n  getMarks(): IMark[] {\n    return this._marks;\n  }\n\n  protected declare _product: Maybe<IVGrammarGroupMark>;\n  declare getProduct: () => Maybe<IVGrammarGroupMark>;\n\n  protected _getDefaultStyle() {\n    const defaultStyle: IMarkStyle<IGroupMarkSpec> = {\n      ...super._getDefaultStyle(),\n      clip: false\n    };\n    return defaultStyle;\n  }\n\n  protected isMarkExist(mark: IMark): boolean {\n    return this._marks.find(m => m.id === mark.id || m.name === mark.name) !== undefined;\n  }\n\n  addMark(mark: IMark): boolean {\n    if (this.isMarkExist(mark)) {\n      warn('Mark already exists, add mark failed.');\n      return false;\n    }\n\n    this._marks.push(mark);\n    return true;\n  }\n\n  removeMark(mark: IMark): boolean {\n    const index = this._marks.findIndex(m => m.id === mark.id || m.name === mark.name);\n    if (index === -1) {\n      warn('Mark does not exists, removeMark failed.');\n      return false;\n    }\n    this._marks.splice(index, 1);\n    return true;\n  }\n\n  getMarkInType(type: MarkType) {\n    return this._marks.filter(m => m.type === type);\n  }\n\n  getMarkInId(id: number) {\n    return this._marks.find(m => m.id === id);\n  }\n\n  getMarkInName(name: string) {\n    return this._marks.find(m => m.name === name);\n  }\n\n  protected _compileProduct(option?: IMarkCompileOption): void {\n    // 编译自身\n    super._compileProduct(option);\n\n    // 设置zIndex\n    this._product.configure({\n      zIndex: this.getZIndex()\n    });\n\n    // 编译子元素\n    if (!option?.ignoreChildren) {\n      this.getMarks().forEach(mark => {\n        // TODO: 如果语法元素已创建，先删除再重新指定父结点生成。vgrammar 是否可以动态指定 mark 父结点？\n        if (mark.getProduct()) {\n          mark.removeProduct();\n        }\n        mark.compile({ group: this._product });\n      });\n    }\n  }\n}\n\nexport const registerGroupMark = () => {\n  registerGroupGraphic();\n  Factory.registerMark(GroupMark.type, GroupMark);\n};\n"]}