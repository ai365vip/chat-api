"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseMark = void 0;

const merge_spec_1 = require("../../util/spec/merge-spec"), color_1 = require("../../util/color"), scale_1 = require("../../util/scale"), constant_1 = require("../../constant"), vscale_1 = require("@visactor/vscale"), util_1 = require("../../theme/color-scheme/util"), compilable_mark_1 = require("../../compile/mark/compilable-mark"), vutils_1 = require("@visactor/vutils");

class BaseMark extends compilable_mark_1.CompilableMark {
    constructor(name, option) {
        var _a;
        super(option, name, option.model), this._extensionChannel = {}, this._computeExChannel = {}, 
        this._attributeContext = option.attributeContext, null === (_a = option.map) || void 0 === _a || _a.set(this.id, this);
    }
    created() {
        this._initStyle();
    }
    initStyleWithSpec(spec, key) {
        spec && ((0, vutils_1.isValid)(spec.id) && (this._userId = spec.id), (0, vutils_1.isBoolean)(spec.interactive) && (this._interactive = spec.interactive), 
        (0, vutils_1.isValid)(spec.zIndex) && this.setZIndex(spec.zIndex), (0, vutils_1.isBoolean)(spec.visible) && this.setVisible(spec.visible), 
        this._initSpecStyle(spec, this.stateStyle, key));
    }
    convertAngleToRadian(styleConverter) {
        if ((0, vutils_1.isNumber)(styleConverter)) return (0, vutils_1.degreeToRadian)(styleConverter);
        if (styleConverter.scale) {
            const range = styleConverter.scale.range();
            return styleConverter.scale.range(range.map(vutils_1.degreeToRadian)), styleConverter;
        }
        return "function" == typeof styleConverter ? (item, ctx, opt, source) => (0, vutils_1.degreeToRadian)(styleConverter(item, ctx, opt, source)) : styleConverter;
    }
    isUserLevel(level) {
        return [ constant_1.AttributeLevel.User_Mark, constant_1.AttributeLevel.User_Series, constant_1.AttributeLevel.User_Chart ].includes(level);
    }
    setStyle(style, state = "normal", level = 0, stateStyle = this.stateStyle) {
        if ((0, vutils_1.isNil)(style)) return;
        style = this._filterStyle(style, state, level, stateStyle), void 0 === stateStyle[state] && (stateStyle[state] = {});
        const isUserLevel = this.isUserLevel(level);
        Object.keys(style).forEach((attr => {
            let attrStyle = style[attr];
            (0, vutils_1.isNil)(attrStyle) || (attrStyle = this._filterAttribute(attr, attrStyle, state, level, isUserLevel, stateStyle), 
            this.setAttribute(attr, attrStyle, state, level, stateStyle));
        }));
    }
    getStyle(key, state = "normal") {
        var _a;
        return null === (_a = this.stateStyle[state][key]) || void 0 === _a ? void 0 : _a.style;
    }
    _filterStyle(style, state, level, stateStyle = this.stateStyle) {
        return style;
    }
    _filterAttribute(attr, style, state, level, isUserLevel, stateStyle = this.stateStyle) {
        let newStyle = this._styleConvert(style);
        return isUserLevel && "angle" === attr && (newStyle = this.convertAngleToRadian(newStyle)), 
        newStyle;
    }
    setReferer(mark, styleKey, state, stateStyle = this.stateStyle) {
        var _a;
        if (mark) if (styleKey && state) {
            const style = null !== (_a = stateStyle[state]) && void 0 !== _a ? _a : {
                [styleKey]: {}
            };
            stateStyle[state][styleKey] = Object.assign(Object.assign({}, style[styleKey]), {
                referer: mark
            });
        } else Object.entries(stateStyle).forEach((([state, style]) => {
            Object.entries(style).forEach((([styleKey, style]) => {
                stateStyle[state][styleKey].referer = mark;
            }));
        }));
    }
    setPostProcess(key, postProcessFunc, state = "normal") {
        var _a;
        (null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key]) && (this.stateStyle[state][key].postProcess = postProcessFunc);
    }
    getAttribute(key, datum, state = "normal", opt) {
        return this._computeAttribute(key, state)(datum, opt);
    }
    setAttribute(attr, style, state = "normal", level = 0, stateStyle = this.stateStyle) {
        var _a;
        void 0 === stateStyle[state] && (stateStyle[state] = {}), void 0 === stateStyle[state][attr] && (stateStyle[state][attr] = {
            level: level,
            style: style,
            referer: void 0
        });
        const attrLevel = null === (_a = stateStyle[state][attr]) || void 0 === _a ? void 0 : _a.level;
        (0, vutils_1.isValid)(attrLevel) && attrLevel <= level && (0, merge_spec_1.mergeSpec)(stateStyle[state][attr], {
            style: style,
            level: level
        }), "normal" !== state && attr in this._extensionChannel && this._extensionChannel[attr].forEach((key => {
            void 0 === stateStyle[state][key] && (stateStyle[state][key] = stateStyle.normal[key]);
        }));
    }
    _getDefaultStyle() {
        return {
            visible: !0,
            x: 0,
            y: 0
        };
    }
    _styleConvert(style) {
        if (!style) return style;
        if ((0, vscale_1.isValidScaleType)(style.type) || style.scale) {
            const scale = (0, scale_1.createScaleWithSpec)(style, {
                globalScale: this._option.globalScale,
                seriesId: this._option.seriesId
            });
            if (scale) return {
                scale: scale,
                field: style.field,
                changeDomain: style.changeDomain
            };
        }
        return style;
    }
    _computeAttribute(key, state) {
        var _a;
        let stateStyle = null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key];
        stateStyle || (stateStyle = this.stateStyle.normal[key]);
        const baseValueFunctor = this._computeStateAttribute(stateStyle, key, state), hasPostProcess = (0, 
        vutils_1.isFunction)(null == stateStyle ? void 0 : stateStyle.postProcess), hasExCompute = key in this._computeExChannel;
        if (hasPostProcess && hasExCompute) {
            const exCompute = this._computeExChannel[key];
            return (datum, opt) => {
                let baseValue = baseValueFunctor(datum, opt);
                return baseValue = stateStyle.postProcess(baseValue, datum, this._attributeContext, opt, this.getDataView()), 
                exCompute(key, datum, state, opt, baseValue);
            };
        }
        if (hasPostProcess) return (datum, opt) => stateStyle.postProcess(baseValueFunctor(datum, opt), datum, this._attributeContext, opt, this.getDataView());
        if (hasExCompute) {
            const exCompute = this._computeExChannel[key];
            return (datum, opt) => exCompute(key, datum, state, opt, baseValueFunctor(datum, opt));
        }
        return baseValueFunctor;
    }
    _computeStateAttribute(stateStyle, key, state) {
        var _a;
        return stateStyle ? stateStyle.referer ? stateStyle.referer._computeAttribute(key, state) : "function" == typeof stateStyle.style ? (datum, opt) => stateStyle.style(datum, this._attributeContext, opt, this.getDataView()) : constant_1.GradientType.includes(stateStyle.style.gradient) ? this._computeGradientAttr(stateStyle.style) : [ "outerBorder", "innerBorder" ].includes(key) ? this._computeBorderAttr(stateStyle.style) : (0, 
        vscale_1.isValidScaleType)(null === (_a = stateStyle.style.scale) || void 0 === _a ? void 0 : _a.type) ? (datum, opt) => stateStyle.style.scale.scale(datum[stateStyle.style.field]) : (datum, opt) => stateStyle.style : (datum, opt) => {};
    }
    _initStyle() {
        const defaultStyle = this._getDefaultStyle();
        this.setStyle(defaultStyle, "normal", 0);
    }
    _initSpecStyle(spec, stateStyle, key) {
        spec.style && this.setStyle(spec.style, "normal", constant_1.AttributeLevel.User_Mark, stateStyle);
        const state = spec.state;
        state && Object.keys(state).forEach((key => {
            const stateTemp = state[key];
            if ("style" in stateTemp) {
                const style = stateTemp.style;
                let stateInfo = {
                    stateValue: key
                };
                "level" in stateTemp && (stateInfo.level = stateTemp.level), "filter" in stateTemp && (stateInfo = (0, 
                vutils_1.isFunction)(stateTemp.filter) ? Object.assign({
                    filter: stateTemp.filter
                }, stateInfo) : Object.assign(Object.assign({}, stateTemp.filter), stateInfo)), 
                this.state.addStateInfo(stateInfo), this.setStyle(style, key, constant_1.AttributeLevel.User_Mark, stateStyle);
            } else this.setStyle(stateTemp, key, constant_1.AttributeLevel.User_Mark, stateStyle);
        }));
    }
    _computeGradientAttr(gradientStyle) {
        var _a, _b;
        const {gradient: gradient, scale: scale, field: field} = gradientStyle, rest = __rest(gradientStyle, [ "gradient", "scale", "field" ]);
        let colorScale = scale, colorField = field;
        if (!(scale && field || "series" !== this.model.modelType)) {
            const {scale: globalColorScale, field: globalField} = this.model.getColorAttribute();
            scale || (colorScale = globalColorScale), colorField || (colorField = globalField);
        }
        const themeColor = (0, util_1.computeActualDataScheme)((0, util_1.getDataScheme)(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain()), mergedStyle = Object.assign(Object.assign({}, constant_1.DEFAULT_GRADIENT_CONFIG[gradient]), rest);
        return (data, opt) => {
            const computeStyle = {}, markData = this.getDataView();
            return Object.keys(mergedStyle).forEach((key => {
                const value = mergedStyle[key];
                "stops" === key ? computeStyle.stops = value.map((stop => {
                    const {opacity: opacity, color: color, offset: offset} = stop;
                    let computeColor = null != color ? color : null == colorScale ? void 0 : colorScale.scale(data[colorField]);
                    return (0, vutils_1.isFunction)(color) && (computeColor = color(data, this._attributeContext, opt, markData)), 
                    (0, vutils_1.isValid)(opacity) && (computeColor = color_1.Color.SetOpacity(computeColor, opacity)), 
                    {
                        offset: (0, vutils_1.isFunction)(offset) ? offset(data, this._attributeContext, opt, markData) : offset,
                        color: computeColor || themeColor[0]
                    };
                })) : (0, vutils_1.isFunction)(value) ? computeStyle[key] = value(data, this._attributeContext, opt, markData) : computeStyle[key] = value;
            })), computeStyle.gradient = gradient, computeStyle;
        };
    }
    _computeBorderAttr(borderStyle) {
        const {scale: scale, field: field} = borderStyle, mergedStyle = __rest(borderStyle, [ "scale", "field" ]);
        return (data, opt) => {
            var _a, _b, _c;
            const computeStyle = {};
            if (Object.keys(mergedStyle).forEach((key => {
                const value = mergedStyle[key];
                (0, vutils_1.isFunction)(value) ? computeStyle[key] = value(data, this._attributeContext, opt, this.getDataView()) : computeStyle[key] = value;
            })), "stroke" in computeStyle) constant_1.GradientType.includes(null === (_c = mergedStyle.stroke) || void 0 === _c ? void 0 : _c.gradient) && (computeStyle.stroke = this._computeGradientAttr(mergedStyle.stroke)(data, opt)); else {
                const themeColor = (0, util_1.computeActualDataScheme)((0, util_1.getDataScheme)(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain());
                let colorScale = scale, colorField = field;
                if (!(scale && field || "series" !== this.model.modelType)) {
                    const {scale: globalColorScale, field: globalField} = this.model.getColorAttribute();
                    scale || (colorScale = globalColorScale), colorField || (colorField = globalField), 
                    computeStyle.stroke = (null == colorScale ? void 0 : colorScale.scale(data[colorField])) || themeColor[0];
                }
            }
            return computeStyle;
        };
    }
}

exports.BaseMark = BaseMark;
//# sourceMappingURL=base-mark.js.map
