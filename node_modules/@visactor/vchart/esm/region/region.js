import { isEmpty, isEqual, array, isValid } from "@visactor/vutils";

import { STATE_VALUE_ENUM_REVERSE } from "../compile/mark/interface";

import { DimensionTrigger } from "../interaction/dimension-trigger";

import { MarkTypeEnum } from "../mark/interface/type";

import { Interaction } from "../interaction/interaction";

import { AttributeLevel, ChartEvent, LayoutZIndex } from "../constant";

import { AnimateManager } from "../animation/animate-manager";

import { IFilterMode } from "../component/data-zoom/constant";

import { LayoutModel } from "../model/layout-model";

import { RegionSpecTransformer } from "./region-transformer";

export class Region extends LayoutModel {
    getMaxWidth() {
        return this._layout.maxWidth;
    }
    setMaxWidth(value) {
        this._layout.maxWidth = value;
    }
    getMaxHeight() {
        return this._layout.maxHeight;
    }
    setMaxHeight(value) {
        this._layout.maxHeight = value;
    }
    getGroupMark() {
        return this._groupMark;
    }
    getInteractionMark() {
        return this._interactionMark;
    }
    getStackInverse() {
        return !0 === this._spec.stackInverse;
    }
    constructor(spec, ctx) {
        var _a;
        super(spec, ctx), this.transformerConstructor = RegionSpecTransformer, this.modelType = "region", 
        this.specKey = "region", this.type = Region.type, this._series = [], this.layoutType = "region", 
        this.layoutZIndex = LayoutZIndex.Region, this.interaction = new Interaction, this.seriesDataFilterOver = () => {
            this.event.emit(ChartEvent.regionSeriesDataFilterOver, {
                model: this
            }), this._series.forEach((s => {
                s.getViewDataFilter() && s.reTransformViewData();
            }));
        }, this.getBoundsInRect = () => ({
            x1: this._layout.getLayoutStartPoint().x,
            y1: this._layout.getLayoutStartPoint().y,
            x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
            y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
        }), this.userId = spec.id, this.coordinate = null !== (_a = spec.coordinate) && void 0 !== _a ? _a : "cartesian", 
        this._option.animation && (this.animate = new AnimateManager({
            getCompiler: ctx.getCompiler
        })), this.interaction.setDisableActiveEffect(this._option.disableTriggerEvent);
    }
    _getClipDefaultValue() {
        var _a, _b, _c, _d;
        const chartSpec = this._option.getChart().getSpec(), hasDataZoom = null === (_b = null === (_a = chartSpec.dataZoom) || void 0 === _a ? void 0 : _a.some) || void 0 === _b ? void 0 : _b.call(_a, (entry => {
            var _a;
            return (null !== (_a = entry.filterMode) && void 0 !== _a ? _a : IFilterMode.filter) === IFilterMode.axis;
        })), hasScrollBar = null === (_d = null === (_c = chartSpec.scrollBar) || void 0 === _c ? void 0 : _c.some) || void 0 === _d ? void 0 : _d.call(_c, (entry => {
            var _a;
            return (null !== (_a = entry.filterMode) && void 0 !== _a ? _a : IFilterMode.axis) === IFilterMode.axis;
        }));
        return !(!hasDataZoom && !hasScrollBar) || this._layout.layoutClip;
    }
    created() {
        var _a;
        this.initLayout(), super.created();
        const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
        this._groupMark = this._createGroupMark("regionGroup", this.userId, this.layoutZIndex), 
        this._interactionMark = this._createGroupMark("regionInteractionGroup", this.userId + "_interaction", LayoutZIndex.Interaction), 
        this._spec.style && (this._backgroundMark = this._createMark({
            type: MarkTypeEnum.rect,
            name: "regionBackground"
        }), clip && (this._foregroundMark = this._createMark({
            type: MarkTypeEnum.rect,
            name: "regionForeground"
        })), [ this._backgroundMark, this._foregroundMark ].forEach((mark => {
            mark && (mark.created(), this.setMarkStyle(mark, {
                width: () => this.getLayoutRect().width,
                height: () => this.getLayoutRect().height
            }, "normal", AttributeLevel.Built_In), this._groupMark.addMark(mark));
        })), this._backgroundMark && this._backgroundMark.setZIndex(0), this._foregroundMark && this._foregroundMark.setZIndex(LayoutZIndex.Mark + 1)), 
        this.createTrigger();
    }
    _createGroupMark(name, userId, zIndex) {
        var _a, _b;
        const groupMark = this._createMark({
            type: MarkTypeEnum.group,
            name: name
        });
        groupMark.setUserId(userId), groupMark.setZIndex(zIndex);
        const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
        return this.setMarkStyle(groupMark, {
            x: () => this.getLayoutStartPoint().x,
            y: () => this.getLayoutStartPoint().y,
            width: () => this.getLayoutRect().width,
            height: () => this.getLayoutRect().height,
            clip: clip
        }, "normal", AttributeLevel.Built_In), this.setMarkStyle(groupMark, {
            cornerRadius: null === (_b = this._spec.style) || void 0 === _b ? void 0 : _b.cornerRadius
        }, "normal", AttributeLevel.User_Mark), this._marks.addMark(groupMark), groupMark;
    }
    init(option) {
        super.init(option), this.initMark(), this.initSeriesDataflow(), this.initInteraction(), 
        this.initTrigger();
    }
    initMark() {
        this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
    }
    _initBackgroundMarkStyle() {
        var _a, _b;
        this._backgroundMark && (this.setMarkStyle(this._backgroundMark, Object.assign({
            fillOpacity: (null === (_a = this._spec.style) || void 0 === _a ? void 0 : _a.fill) ? 1 : 0
        }, this._spec.style), "normal", AttributeLevel.User_Mark), (null !== (_b = this._spec.clip) && void 0 !== _b ? _b : this._getClipDefaultValue()) && this.setMarkStyle(this._backgroundMark, {
            strokeOpacity: 0
        }, "normal", AttributeLevel.Built_In));
    }
    _initForegroundMarkStyle() {
        this._foregroundMark && this.setMarkStyle(this._foregroundMark, Object.assign(Object.assign({}, this._spec.style), {
            fillOpacity: 0
        }), "normal", AttributeLevel.User_Mark);
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return isEqual(null == prevSpec ? void 0 : prevSpec.style, null == spec ? void 0 : spec.style) || (result.reMake = !0), 
        result;
    }
    reInit(spec) {
        super.reInit(spec), this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
    }
    addSeries(s) {
        s && (this._series.includes(s) || this._series.push(s));
    }
    removeSeries(s) {
        if (!s) return;
        const index = this._series.findIndex((s_ => s_ === s));
        index >= 0 && this._series.splice(index, 1);
    }
    getSeries(opt = {}) {
        return this._series.filter((s => {
            var _a, _b;
            return (!opt.name || (null == s ? void 0 : s.name) === opt.name) && (!opt.userId || array(opt.userId).includes(s.userId)) && (!isValid(opt.specIndex) || !s.getSpecIndex || array(opt.specIndex).includes(s.getSpecIndex())) && (!opt.id || s.id === opt.id) && (!opt.type || s.type === opt.type) && (!opt.coordinateType || s.coordinate === opt.coordinateType) && (!opt.dataName || (null === (_b = null === (_a = s.getRawData) || void 0 === _a ? void 0 : _a.call(s)) || void 0 === _b ? void 0 : _b.name) === opt.dataName);
        }));
    }
    getSeriesInName(name) {
        return this.getSeries({
            name: name
        })[0];
    }
    getSeriesInUserId(userId) {
        return this.getSeries({
            userId: userId
        })[0];
    }
    getSeriesInId(id) {
        return this.getSeries({
            id: id
        })[0];
    }
    getSeriesInType(type) {
        return this.getSeries({
            type: type
        });
    }
    getSeriesInCoordinateType(coordinateType) {
        return this.getSeries({
            coordinateType: coordinateType
        });
    }
    getSeriesInDataName(dataName) {
        return this.getSeries({
            dataName: dataName
        });
    }
    onRender(ctx) {}
    initSeriesDataflow() {
        const viewDataFilters = this._series.map((s => {
            var _a;
            return null !== (_a = s.getViewDataFilter()) && void 0 !== _a ? _a : s.getViewData();
        })).filter((v => !!v));
        this._option.dataSet.multipleDataViewAddListener(viewDataFilters, "change", this.seriesDataFilterOver);
    }
    release() {
        super.release(), this._series = [];
    }
    createTrigger() {
        const triggerOptions = Object.assign(Object.assign({}, this._option), {
            model: this,
            interaction: this.interaction
        });
        this._trigger = new DimensionTrigger(triggerOptions);
    }
    initTrigger() {
        this._series.forEach((s => {
            s.getMarksWithoutRoot().forEach((m => {
                this._trigger.registerMark(m);
            }));
        })), this._trigger.init();
    }
    initInteraction() {
        this._series.forEach((s => {
            s.getMarksWithoutRoot().forEach((m => {
                for (const key in STATE_VALUE_ENUM_REVERSE) isEmpty(m.stateStyle[STATE_VALUE_ENUM_REVERSE[key]]) || this.interaction.registerMark(STATE_VALUE_ENUM_REVERSE[key], m);
            }));
        }));
    }
    compileMarks(group) {
        this.getMarks().forEach((m => {
            var _a;
            m.compile({
                group: group
            }), null === (_a = m.getProduct()) || void 0 === _a || _a.configure({
                context: {
                    model: this
                }
            }).layout(((group, children, parentLayoutBounds, options) => {}));
        }));
    }
    compile() {
        var _a;
        null === (_a = this.animate) || void 0 === _a || _a.compile(), this.compileMarks();
    }
    onLayoutEnd(ctx) {
        this._series.forEach((s => s.onLayoutEnd(ctx))), super.onLayoutEnd(ctx);
    }
}

Region.type = "region", Region.transformerConstructor = RegionSpecTransformer, Region.specKey = "region";
//# sourceMappingURL=region.js.map
