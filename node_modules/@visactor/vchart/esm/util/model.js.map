{"version":3,"sources":["../src/util/model.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,UAAU,EAAE,MAAM,QAAQ,CAAC;AAEpC,MAAM,UAAU,UAAU,CAAC,OAAkB,EAAE,QAAwC,EAAE,MAAsB;IAC7G,IAAI,IAAI,GAAG,KAAK,CAAC;IACjB,IAAI,QAAQ,IAAI,UAAU,CAAC,QAAQ,CAAC,EAAE;QACpC,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE;YACvB,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE;gBACnC,IAAI,GAAG,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAChC,IAAI,IAAI,EAAE;oBACR,OAAO,IAAI,CAAC;iBACb;aACF;SACF;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,UAAU,SAAS,CAAC,OAAkB,EAAE,MAAsB;IAClE,MAAM,MAAM,GAAc,EAAE,CAAC;IAC7B,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE;QACvB,KAAK,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE;YACnC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SAChB;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,OAAkB,EAAE,cAAsC,EAAE,EAAE;IAC3F,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACvC,MAAM,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QACrB,MAAM,MAAM,GAAG,CAAC,CAAC,SAAS,EAAE,CAAC;QAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACpB,IAAI,cAAc,IAAI,CAAC,IAAI,CAAC,CAAC,UAAU,KAAK,cAAc,EAAE;gBAC1D,OAAO,CAAC,CAAC;aACV;YACD,IAAI,CAAC,cAAc,IAAI,CAAC,EAAE;gBACxB,OAAO,CAAC,CAAC;aACV;SACF;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC","file":"model.js","sourcesContent":["import type { IChart } from '../chart/interface';\nimport type { IRegion, ISeriesFilter } from '../region/interface';\nimport type { ISeries } from '../series/interface';\nimport { isFunction } from './type';\n\nexport function eachSeries(regions: IRegion[], callback: (s: ISeries) => boolean | void, filter?: ISeriesFilter) {\n  let flag = false;\n  if (callback && isFunction(callback)) {\n    for (const r of regions) {\n      for (const s of r.getSeries(filter)) {\n        flag = !!callback.call(null, s);\n        if (flag) {\n          return flag;\n        }\n      }\n    }\n  }\n  return flag;\n}\n\nexport function getSeries(regions: IRegion[], filter?: ISeriesFilter) {\n  const result: ISeries[] = [];\n  for (const r of regions) {\n    for (const s of r.getSeries(filter)) {\n      result.push(s);\n    }\n  }\n  return result;\n}\n\nexport const getFirstSeries = (regions: IRegion[], coordinateType?: 'cartesian' | 'polar') => {\n  for (let i = 0; i < regions.length; i++) {\n    const r = regions[i];\n    const series = r.getSeries();\n    for (let j = 0; j < series.length; j++) {\n      const s = series[j];\n      if (coordinateType && s && s.coordinate === coordinateType) {\n        return s;\n      }\n      if (!coordinateType && s) {\n        return s;\n      }\n    }\n  }\n  return null;\n};\n"]}