import { isNil } from "@visactor/vutils";

import { SeriesTypeEnum } from "../../series/interface";

import { ProgressLikeChartSpecTransformer } from "../polar";

import { LayoutZIndex } from "../../constant";

export class GaugeChartSpecTransformer extends ProgressLikeChartSpecTransformer {
    _getDefaultSeriesSpec(spec) {
        const series = super._getDefaultSeriesSpec(spec);
        return Object.assign(Object.assign({}, series), {
            radiusField: spec.radiusField,
            pin: spec.pin,
            pinBackground: spec.pinBackground,
            pointer: spec.pointer
        });
    }
    _getDefaultCircularProgressSeriesSpec(spec) {
        return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
            type: SeriesTypeEnum.circularProgress
        });
    }
    transformSpec(spec) {
        var _a, _b, _c, _d, _e;
        super.transformSpec(spec);
        let backgroundSeries = null === (_a = spec.series) || void 0 === _a ? void 0 : _a.find((series => series.type === SeriesTypeEnum.gauge || series.type === SeriesTypeEnum.circularProgress));
        isNil(backgroundSeries) && (backgroundSeries = null !== (_b = spec.gauge) && void 0 !== _b ? _b : this._getDefaultCircularProgressSeriesSpec(spec), 
        "circularProgress" === backgroundSeries.type && (isNil(backgroundSeries.radiusField) && isNil(backgroundSeries.categoryField) && (backgroundSeries.radiusField = null !== (_d = null !== (_c = spec.radiusField) && void 0 !== _c ? _c : spec.categoryField) && void 0 !== _d ? _d : spec.seriesField), 
        isNil(backgroundSeries.valueField) && isNil(backgroundSeries.angleField) && (backgroundSeries.valueField = null !== (_e = spec.valueField) && void 0 !== _e ? _e : spec.angleField)), 
        1 === spec.series.length ? spec.series.push(backgroundSeries) : spec.series.forEach((s => {
            s.type === backgroundSeries.type && Object.keys(backgroundSeries).forEach((k => {
                k in s || (s[k] = backgroundSeries[k]);
            }));
        }))), backgroundSeries.type === SeriesTypeEnum.circularProgress ? this._transformProgressAxisSpec(spec, {
            orient: "angle",
            visible: !0,
            domainLine: {
                visible: !1
            },
            grid: {
                visible: !1
            }
        }, {
            orient: "radius",
            visible: !1
        }, {
            zIndex: LayoutZIndex.Region + 50
        }) : this._transformGaugeAxisSpec(spec);
    }
    _transformGaugeAxisSpec(spec) {
        var _a;
        spec.axes || (spec.axes = []);
        const axesPtr = {
            radius: null,
            angle: null
        };
        (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis => {
            const {orient: orient} = axis;
            "radius" === orient && (axesPtr.radius = axis), "angle" === orient && (axesPtr.angle = axis);
        })), axesPtr.angle || (axesPtr.angle = {
            orient: "angle",
            visible: !0
        }, spec.axes.push(axesPtr.angle)), axesPtr.radius || (axesPtr.radius = {
            orient: "radius",
            visible: !1
        }, spec.axes.push(axesPtr.radius)), isNil(axesPtr.angle.type) && (axesPtr.angle.type = "linear"), 
        isNil(axesPtr.radius.type) && (axesPtr.radius.type = "linear"), isNil(axesPtr.angle.zIndex) && (axesPtr.angle.zIndex = LayoutZIndex.Region + 50);
    }
}
//# sourceMappingURL=gauge-transformer.js.map
