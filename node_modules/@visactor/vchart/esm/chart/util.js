import { getContainerSize, isString } from "@visactor/vutils";

import { Direction } from "../typings";

import { array, isMiniAppLikeMode, isTrueBrowser, isValid, mergeSpec } from "../util";

export function setDefaultCrosshairForCartesianChart(spec) {
    spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg => mergeSpec({
        [spec.direction === Direction.horizontal ? "yField" : "xField"]: {
            visible: !0,
            line: {
                visible: !0,
                type: "rect"
            }
        }
    }, crosshairCfg)));
}

export function calculateChartSize(spec, option, defaultSize) {
    var _a;
    const {width: userWidth, height: userHeight} = spec;
    if (isValid(userWidth) && isValid(userHeight)) return {
        width: userWidth,
        height: userHeight
    };
    let width = defaultSize.width, height = defaultSize.height;
    const container = option.container, canvas = option.canvas;
    if (container) {
        const {width: containerWidth, height: containerHeight} = getContainerSize(container, defaultSize.width, defaultSize.height);
        width = containerWidth, height = containerHeight;
    } else if (canvas && isTrueBrowser(option.mode)) {
        let canvasNode;
        canvasNode = isString(canvas) ? null === document || void 0 === document ? void 0 : document.getElementById(canvas) : canvas;
        const {width: containerWidth, height: containerHeight} = getContainerSize(canvasNode, defaultSize.width, defaultSize.height);
        width = containerWidth, height = containerHeight;
    } else if (isMiniAppLikeMode(option.mode) && (null === (_a = option.modeParams) || void 0 === _a ? void 0 : _a.domref)) {
        const domRef = option.modeParams.domref;
        width = domRef.width, height = domRef.height;
    }
    return width = null != userWidth ? userWidth : width, height = null != userHeight ? userHeight : height, 
    {
        width: width,
        height: height
    };
}

export function mergeUpdateResult(target, ...sources) {
    const merge = key => sources.reduce(((value, cur) => value || (null == cur ? void 0 : cur[key])), target[key]);
    return Object.assign(target, {
        change: merge("change"),
        reCompile: merge("reCompile"),
        reMake: merge("reMake"),
        reRender: merge("reRender"),
        reSize: merge("reSize")
    }), target;
}

export function getTrimPaddingConfig(chartType, spec) {
    return "line" === chartType || "area" === chartType || "common" === chartType && spec.series.every((item => "area" === item.type || "line" === item.type)) ? {
        paddingInner: 1,
        paddingOuter: 0
    } : {
        paddingOuter: 0
    };
}
//# sourceMappingURL=util.js.map