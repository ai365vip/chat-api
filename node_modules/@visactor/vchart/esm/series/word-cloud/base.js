import { isValidNumber } from "@visactor/vutils";

import { isValid } from "@visactor/vutils";

import { AttributeLevel, DEFAULT_DATA_KEY, DEFAULT_DATA_SERIES_FIELD } from "../../constant";

import { SeriesMarkNameEnum } from "../interface/type";

import { isTrueBrowser } from "../../util/env";

import { DEFAULT_DRAW_OUT_OF_BOUND, DEFAULT_FONTSIZE_RANGE, DEFAULT_FONT_PADDING, DEFAULT_FONT_WEIGHT_RANGE, DEFAULT_MASK_SHAPE, DEFAULT_MIN_FONT_SIZE, DEFAULT_RANDOM, DEFAULT_ROTATE_ANGLES, DEFAULT_ZOOM_TO_FIT, SHAPE_TYPE } from "./config";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { LinearScale } from "@visactor/vscale";

import { extent } from "@visactor/vgrammar-util";

import { WORD_CLOUD_ANGLE, WORD_CLOUD_FILLING_ANGLE, WORD_CLOUD_TEXT, WORD_CLOUD_WEIGHT } from "../../constant/word-cloud";

import { BaseSeries } from "../base/base-series";

import { ColorOrdinalScale } from "../../scale/color-ordinal-scale";

import { wordCloudSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

export class BaseWordCloudSeries extends BaseSeries {
    constructor() {
        super(...arguments), this._fontSizeRange = [ DEFAULT_MIN_FONT_SIZE, DEFAULT_MIN_FONT_SIZE ], 
        this._isWordCloudShape = !1;
    }
    setValueField(field) {
        isValid(field) && (this._valueField = field);
    }
    setFontSizeRange(fontSizeRange) {
        isValid(fontSizeRange) ? this._fontSizeRange = fontSizeRange : this._fontSizeRange = DEFAULT_FONTSIZE_RANGE;
    }
    setAttrFromSpec() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super.setAttrFromSpec(), this._padding = this._option.getChart().padding, this._nameField = this._spec.nameField, 
        this._fontFamilyField = this._spec.fontFamilyField, this._fontWeightField = this._spec.fontWeightField, 
        this._fontStyleField = this._spec.fontStyleField, this._colorHexField = this._spec.colorHexField, 
        this._colorMode = null !== (_a = this._spec.colorMode) && void 0 !== _a ? _a : "ordinal", 
        this._colorList = this._spec.colorList, this.setValueField(this._spec.valueField), 
        this._fontWeightRange = null !== (_b = this._spec.fontWeightRange) && void 0 !== _b ? _b : DEFAULT_FONT_WEIGHT_RANGE, 
        this._rotateAngles = null !== (_c = this._spec.rotateAngles) && void 0 !== _c ? _c : DEFAULT_ROTATE_ANGLES, 
        this.setFontSizeRange(this._spec.fontSizeRange), this._maskShape = null !== (_d = this._spec.maskShape) && void 0 !== _d ? _d : DEFAULT_MASK_SHAPE, 
        this._keepAspect = this._spec.keepAspect, this._random = null !== (_e = this._spec.random) && void 0 !== _e ? _e : DEFAULT_RANDOM, 
        this._fontPadding = null !== (_g = null === (_f = this._spec.word) || void 0 === _f ? void 0 : _f.padding) && void 0 !== _g ? _g : DEFAULT_FONT_PADDING, 
        this._textField = (null === (_h = this._spec.word) || void 0 === _h ? void 0 : _h.formatMethod) ? WORD_CLOUD_TEXT : this._nameField, 
        this._wordCloudConfig = Object.assign({
            drawOutOfBound: DEFAULT_DRAW_OUT_OF_BOUND,
            layoutMode: "default",
            zoomToFit: DEFAULT_ZOOM_TO_FIT
        }, this._spec.wordCloudConfig), this._wordCloudShapeConfig = Object.assign({
            fillingSeriesField: this.getSeriesField(),
            fillingRotateAngles: DEFAULT_ROTATE_ANGLES,
            layoutMode: "default"
        }, this._spec.wordCloudShapeConfig), this._fillingFontPadding = null !== (_k = null === (_j = this._spec.fillingWord) || void 0 === _j ? void 0 : _j.padding) && void 0 !== _k ? _k : DEFAULT_FONT_PADDING, 
        this._isWordCloudShape = !SHAPE_TYPE.includes(this._maskShape), this._defaultFontFamily = this._option.getTheme().fontFamily;
    }
    initMark() {
        this._wordMark = this._createMark(BaseWordCloudSeries.mark.word, {
            defaultMorphElementKey: this._seriesField,
            groupKey: this._seriesField,
            isSeriesMark: !0
        }), this._isWordCloudShape && (this._fillingWordMark = this._createMark(BaseWordCloudSeries.mark.fillingWord));
    }
    initMarkStyle() {
        var _a, _b, _c, _d, _e;
        const wordMark = this._wordMark, fillingWordMark = this._fillingWordMark, wordSpec = null !== (_a = this._spec.word) && void 0 !== _a ? _a : {};
        wordMark && (this.setMarkStyle(wordMark, {
            fill: this._colorHexField ? datum => datum[this._colorHexField] : this.getWordColorAttribute(this._seriesField, !1),
            text: datum => datum[this._textField],
            x: datum => datum.x,
            y: datum => datum.y,
            fontFamily: datum => datum.fontFamily,
            fontSize: datum => datum.fontSize,
            fontStyle: datum => datum.fontStyle,
            fontWeight: datum => datum.fontWeight,
            angle: datum => datum.angle,
            visible: datum => !datum.isFillingWord && datum.visible
        }, "normal", AttributeLevel.Series), this.setMarkStyle(wordMark, {
            fontFamily: null !== (_c = null === (_b = wordSpec.style) || void 0 === _b ? void 0 : _b.fontFamily) && void 0 !== _c ? _c : this._defaultFontFamily
        }, "normal", AttributeLevel.User_Mark)), fillingWordMark && (this.setMarkStyle(fillingWordMark, {
            fill: this._wordCloudShapeConfig.fillingColorHexField ? datum => datum[this._wordCloudShapeConfig.fillingColorHexField] : this.getWordColorAttribute(this._wordCloudShapeConfig.fillingSeriesField, !0),
            text: datum => datum[this._textField],
            x: datum => datum.x,
            y: datum => datum.y,
            fontFamily: datum => datum.fontFamily,
            fontSize: datum => datum.fontSize,
            fontStyle: datum => datum.fontStyle,
            fontWeight: datum => datum.fontWeight,
            angle: datum => datum.angle,
            visible: datum => datum.isFillingWord && datum.visible
        }, "normal", AttributeLevel.Series), this.setMarkStyle(fillingWordMark, {
            fontFamily: null !== (_e = null === (_d = wordSpec.style) || void 0 === _d ? void 0 : _d.fontFamily) && void 0 !== _e ? _e : this._defaultFontFamily
        }, "normal", AttributeLevel.User_Mark)), this._trigger.registerMark(wordMark), this._trigger.registerMark(fillingWordMark);
    }
    initTooltip() {
        super.initTooltip(), this._wordMark && this._tooltipHelper.activeTriggerSet.mark.add(this._wordMark), 
        this._fillingWordMark && this._tooltipHelper.activeTriggerSet.mark.add(this._fillingWordMark);
    }
    initAnimation() {
        [ this._wordMark, this._fillingWordMark ].forEach((mark => {
            var _a, _b;
            if (mark) {
                const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, params = {
                    animationConfig: () => {
                        var _a, _b;
                        return null === (_b = null === (_a = mark.getAnimationConfig()) || void 0 === _a ? void 0 : _a.appear) || void 0 === _b ? void 0 : _b[0];
                    }
                };
                mark.setAnimationConfig(animationConfig(Factory.getAnimationInKey("wordCloud")(params, appearPreset), userAnimationConfig(SeriesMarkNameEnum.word, this._spec, this._markAttributeContext)));
            }
        }));
    }
    getWordOrdinalColorScale(field, isFillingWord) {
        var _a, _b, _c, _d, _e;
        const colorList = isFillingWord ? this._wordCloudShapeConfig.fillingColorList : this._colorList, colorDomain = field ? null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData.map((datum => datum[field])) : [], colorRange = null !== (_c = null != colorList ? colorList : null === (_b = this._option.globalScale.getScale("color")) || void 0 === _b ? void 0 : _b.range()) && void 0 !== _c ? _c : this._getDataScheme();
        return null === (_e = (_d = (new ColorOrdinalScale).domain(colorDomain)).range) || void 0 === _e ? void 0 : _e.call(_d, colorRange);
    }
    getWordColorAttribute(field, isFillingWord) {
        var _a, _b;
        if ("ordinal" === this._colorMode) return {
            scale: this.getWordOrdinalColorScale(field, isFillingWord),
            field: null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD
        };
        let colorList = null !== (_b = isFillingWord ? this._colorList : this._wordCloudShapeConfig.fillingColorList) && void 0 !== _b ? _b : this._option.globalScale.getScale("color").range();
        return 1 === colorList.length && (colorList = [ colorList[0], colorList[0] ]), datum => colorList[0];
    }
    compile() {
        var _a, _b;
        super.compile();
        const {width: width, height: height} = this._region.getLayoutRect();
        if (!isValidNumber(width) || !isValidNumber(height) || !(height > 0 && width > 0)) return;
        const wordCloudTransforms = [], valueField = this._valueField, valueScale = new LinearScale, fontWeightRange = this._fontWeightRange, rotateAngles = this._rotateAngles, fillingRotateAngles = this._wordCloudShapeConfig.fillingRotateAngles;
        if (valueField) {
            const [minValue, maxValue] = extent(null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData.map((datum => +datum[valueField])));
            valueScale.domain([ minValue, maxValue ], !0).range(fontWeightRange), wordCloudTransforms.push({
                type: "map",
                as: WORD_CLOUD_WEIGHT,
                callback: datum => minValue === maxValue ? valueScale.scale(maxValue) : valueScale.scale(datum[valueField])
            });
        }
        wordCloudTransforms.push({
            type: "map",
            as: WORD_CLOUD_ANGLE,
            callback: () => rotateAngles[Math.floor(Math.random() * rotateAngles.length)]
        }), wordCloudTransforms.push({
            type: "map",
            as: WORD_CLOUD_FILLING_ANGLE,
            callback: () => fillingRotateAngles[Math.floor(Math.random() * fillingRotateAngles.length)]
        });
        const wordSpec = null !== (_b = this._spec.word) && void 0 !== _b ? _b : {};
        wordSpec.formatMethod && wordCloudTransforms.push({
            type: "map",
            as: WORD_CLOUD_TEXT,
            callback: wordSpec.formatMethod
        }), this._isWordCloudShape ? wordCloudTransforms.push(Object.assign({
            type: "wordcloudShape"
        }, this._wordCloudShapeTransformOption())) : (wordCloudTransforms.push(Object.assign({
            type: "wordcloud"
        }, this._wordCloudTransformOption())), this._wordMark.getProduct().transform(wordCloudTransforms)), 
        this._data.getProduct().transform(wordCloudTransforms);
    }
    _wordCloudTransformOption() {
        var _a, _b, _c, _d, _e;
        const {width: width, height: height} = this._region.getLayoutRect(), wordStyleSpec = null !== (_b = null === (_a = this._spec.word) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
        return {
            layoutType: isTrueBrowser(this._option.mode) ? this._wordCloudConfig.layoutMode : "fast",
            size: [ width, height ],
            shape: this._maskShape,
            dataIndexKey: DEFAULT_DATA_KEY,
            text: {
                field: this._textField
            },
            fontSize: this._valueField ? {
                field: this._valueField
            } : this._fontSizeRange[0],
            fontSizeRange: "auto" === this._fontSizeRange ? null : this._fontSizeRange,
            padding: this._fontPadding,
            rotate: {
                field: WORD_CLOUD_ANGLE
            },
            fontFamily: null !== (_d = null !== (_c = this._fontFamilyField) && void 0 !== _c ? _c : wordStyleSpec.fontFamily) && void 0 !== _d ? _d : this._defaultFontFamily,
            fontWeight: this._fontWeightField ? {
                field: this._fontWeightField
            } : this._valueField ? {
                field: WORD_CLOUD_WEIGHT
            } : null,
            fontStyle: null !== (_e = this._fontStyleField) && void 0 !== _e ? _e : wordStyleSpec.fontStyle,
            randomVisible: this._random,
            clip: "clip" === this._wordCloudConfig.drawOutOfBound,
            shrink: this._wordCloudConfig.zoomToFit.shrink,
            enlarge: this._wordCloudConfig.zoomToFit.enlarge,
            minFontSize: this._wordCloudConfig.zoomToFit.fontSizeLimitMin,
            progressiveTime: this._wordCloudConfig.progressiveTime,
            progressiveStep: this._wordCloudConfig.progressiveStep
        };
    }
    _wordCloudShapeTransformOption() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const {width: width, height: height} = this._region.getLayoutRect(), wordStyleSpec = null !== (_b = null === (_a = this._spec.word) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {}, wordCloudShapeConfig = null !== (_c = this._wordCloudShapeConfig) && void 0 !== _c ? _c : {}, fillingRotateAngles = this._wordCloudShapeConfig.fillingRotateAngles;
        return {
            dataIndexKey: DEFAULT_DATA_KEY,
            size: [ width, height ],
            shape: this._maskShape,
            text: {
                field: this._textField
            },
            fontSize: this._valueField ? {
                field: this._valueField
            } : this._fontSizeRange[0],
            fontSizeRange: "auto" === this._fontSizeRange ? null : this._fontSizeRange,
            padding: this._fontPadding,
            rotateList: this._rotateAngles,
            fontFamily: null !== (_e = null !== (_d = this._fontFamilyField) && void 0 !== _d ? _d : wordStyleSpec.fontFamily) && void 0 !== _e ? _e : this._defaultFontFamily,
            fontWeight: this._fontWeightField ? {
                field: this._fontWeightField
            } : this._valueField ? {
                field: WORD_CLOUD_WEIGHT
            } : null,
            fontStyle: null !== (_f = this._fontStyleField) && void 0 !== _f ? _f : wordStyleSpec.fontStyle,
            fillingFontFamily: null !== (_h = null !== (_g = wordCloudShapeConfig.fillingFontFamilyField) && void 0 !== _g ? _g : wordStyleSpec.fontFamily) && void 0 !== _h ? _h : this._defaultFontFamily,
            fillingPadding: this._fillingFontPadding,
            fillingFontStyle: null !== (_j = wordCloudShapeConfig.fillingFontStyleField) && void 0 !== _j ? _j : wordStyleSpec.fontStyle,
            fillingFontWeight: null !== (_k = wordCloudShapeConfig.fillingFontWeightField) && void 0 !== _k ? _k : wordStyleSpec.fontWeight,
            fillingRotateList: fillingRotateAngles,
            fillingTimes: wordCloudShapeConfig.fillingTimes,
            fillingXStep: wordCloudShapeConfig.fillingXStep,
            fillingYStep: wordCloudShapeConfig.fillingYStep,
            fillingXRatioStep: wordCloudShapeConfig.fillingXRatioStep,
            fillingYRatioStep: wordCloudShapeConfig.fillingYRatioStep,
            fillingInitialOpacity: wordCloudShapeConfig.fillingInitialOpacity,
            fillingDeltaOpacity: wordCloudShapeConfig.fillingDeltaOpacity,
            fillingInitialFontSize: wordCloudShapeConfig.fillingInitialFontSize,
            fillingDeltaFontSize: wordCloudShapeConfig.fillingDeltaFontSize,
            ratio: wordCloudShapeConfig.ratio,
            fillingRatio: wordCloudShapeConfig.fillingRatio,
            removeWhiteBorder: wordCloudShapeConfig.removeWhiteBorder,
            textLayoutTimes: wordCloudShapeConfig.textLayoutTimes,
            fontSizeShrinkFactor: wordCloudShapeConfig.fontSizeShrinkFactor,
            stepFactor: wordCloudShapeConfig.stepFactor,
            layoutMode: wordCloudShapeConfig.layoutMode,
            importantWordCount: wordCloudShapeConfig.importantWordCount,
            globalShinkLimit: wordCloudShapeConfig.globalShinkLimit,
            fontSizeEnlargeFactor: wordCloudShapeConfig.fontSizeEnlargeFactor,
            fillingDeltaFontSizeFactor: wordCloudShapeConfig.fillingDeltaFontSizeFactor
        };
    }
    getStatisticFields() {
        const fields = [];
        return fields.push({
            key: this._nameField,
            operations: [ "values" ]
        }), fields.push({
            key: this._valueField,
            operations: [ "max", "min" ]
        }), fields;
    }
    dataToPosition(data) {
        return null;
    }
    dataToPositionX(data) {
        return null;
    }
    dataToPositionY(data) {
        return null;
    }
    dataToPositionZ(data) {
        return null;
    }
    valueToPosition(value1, value2) {
        return null;
    }
    getGroupFields() {
        return [];
    }
    getStackGroupFields() {
        return [];
    }
    getStackValueField() {
        return "";
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this.compile();
    }
    getActiveMarks() {
        return [ this._wordMark, this._fillingWordMark ];
    }
}

BaseWordCloudSeries.mark = wordCloudSeriesMark;
//# sourceMappingURL=base.js.map
