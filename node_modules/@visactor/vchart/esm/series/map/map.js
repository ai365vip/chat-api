import { Matrix, isValid, isValidNumber } from "@visactor/vutils";

import { registerProjection } from "@visactor/vgrammar-projection";

import { DataView } from "@visactor/vdataset";

import { geoSourceMap, registerMapSource, unregisterMapSource } from "./geo-source";

import { lookup } from "../../data/transforms/lookup";

import { GeoSeries } from "../geo/geo";

import { DEFAULT_MAP_LOOK_UP_KEY, map } from "../../data/transforms/map";

import { copyDataView } from "../../data/transforms/copy-data-view";

import { registerDataSetInstanceTransform } from "../../data/register";

import { MapSeriesTooltipHelper } from "./tooltip-helper";

import { AttributeLevel, DEFAULT_DATA_SERIES_FIELD, DEFAULT_DATA_INDEX } from "../../constant/index";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { SeriesData } from "../base/series-data";

import { animationConfig, shouldMarkDoMorph, userAnimationConfig } from "../../animation/utils";

import { registerFadeInOutAnimation } from "../../animation/config";

import { registerPathMark } from "../../mark/path";

import { mapSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { registerGeoCoordinate } from "../../component/geo";

import { TransformLevel } from "../../data/initialize";

import { MapSeriesSpecTransformer } from "./map-transformer";

export class MapSeries extends GeoSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.map, this.transformerConstructor = MapSeriesSpecTransformer, 
        this._areaCache = new Map;
    }
    getNameMap() {
        return this._nameMap;
    }
    get areaPath() {
        return this._areaCache;
    }
    setAttrFromSpec() {
        var _a, _b;
        super.setAttrFromSpec(), this.map = this._spec.map, this._nameMap = this._spec.nameMap, 
        this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, 
        this._spec.nameProperty && (this._nameProperty = this._spec.nameProperty), this._spec.centroidProperty && (this._centroidProperty = this._spec.centroidProperty), 
        this.map || null === (_a = this._option) || void 0 === _a || _a.onError(`map type '${this.map}' is not specified !`), 
        geoSourceMap.get(this.map) || null === (_b = this._option) || void 0 === _b || _b.onError(`'${this.map}' data is not registered !`);
    }
    initData() {
        var _a, _b;
        super.initData(), registerDataSetInstanceTransform(this._dataSet, "copyDataView", copyDataView), 
        registerDataSetInstanceTransform(this._dataSet, "map", map), registerDataSetInstanceTransform(this._dataSet, "lookup", lookup);
        const features = geoSourceMap.get(this.map);
        features || null === (_a = this._option) || void 0 === _a || _a.onError("no valid map data found!");
        const mapData = new DataView(this._dataSet, {
            name: `map_${this.id}_data`
        });
        mapData.parse([ features ], {
            type: "dataview"
        }).transform({
            type: "copyDataView",
            options: {
                deep: !0
            },
            level: TransformLevel.copyDataView
        }).transform({
            type: "map",
            options: {
                nameMap: this._nameMap,
                nameProperty: this._nameProperty
            }
        }).transform({
            type: "lookup",
            options: {
                from: () => {
                    var _a;
                    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData();
                },
                key: DEFAULT_MAP_LOOK_UP_KEY,
                fields: this._nameField,
                set: (feature, datum) => {
                    datum && Object.keys(datum).forEach((key => {
                        key in feature || (feature[key] = datum[key]);
                    }));
                }
            }
        }), null === (_b = this._data) || void 0 === _b || _b.getDataView().target.addListener("change", mapData.reRunAllTransform), 
        this._mapViewData = new SeriesData(this._option, mapData);
    }
    initMark() {
        this._pathMark = this._createMark(MapSeries.mark.area, {
            morph: shouldMarkDoMorph(this._spec, MapSeries.mark.area.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this.getDimensionField()[0],
            isSeriesMark: !0,
            skipBeforeLayouted: !0,
            dataView: this._mapViewData.getDataView(),
            dataProductId: this._mapViewData.getProductId()
        });
    }
    initMarkStyle() {
        const pathMark = this._pathMark;
        pathMark && (this.setMarkStyle(pathMark, {
            fill: datum => {
                var _a, _b, _c, _d;
                return isValid(datum[null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD]) ? (null !== (_b = this._option.globalScale.getScale("color")) && void 0 !== _b ? _b : this._getDefaultColorScale()).scale(datum[null !== (_c = this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD]) : null === (_d = this._spec) || void 0 === _d ? void 0 : _d.defaultFillColor;
            },
            path: this.getPath.bind(this)
        }, "normal", AttributeLevel.Series), pathMark.setPostProcess("fill", (result => isValid(result) ? result : this._spec.defaultFillColor)), 
        this.setMarkStyle(pathMark, {
            smoothScale: !0
        }, "normal", AttributeLevel.Built_In), this._trigger.registerMark(pathMark));
    }
    initLabelMarkStyle(labelMark) {
        labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
            text: datum => this.getDatumName(datum),
            x: datum => {
                var _a;
                return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
            },
            y: datum => {
                var _a;
                return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
            }
        }));
    }
    initAnimation() {
        var _a;
        this._pathMark.setAnimationConfig(animationConfig(null === (_a = Factory.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(SeriesMarkNameEnum.area, this._spec, this._markAttributeContext)));
    }
    initTooltip() {
        this._tooltipHelper = new MapSeriesTooltipHelper(this), this._pathMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pathMark);
    }
    getPath(datum) {
        var _a;
        const area = this._areaCache.get(datum[DEFAULT_DATA_INDEX]);
        if (area) return area.shape;
        const shape = null === (_a = this._coordinateHelper) || void 0 === _a ? void 0 : _a.shape(datum);
        return this._areaCache.set(datum[DEFAULT_DATA_INDEX], {
            shape: shape
        }), shape;
    }
    onEvaluateEnd() {
        this._mapViewData.updateData();
    }
    getDimensionField() {
        return [ this.nameField ];
    }
    getMeasureField() {
        return [ this.valueField ];
    }
    release() {
        super.release(), this._areaCache.clear(), this._nameMap = {}, this._trigger = this._mapViewData = null;
    }
    handleZoom(e) {
        var _a, _b, _c;
        const {scale: scale, scaleCenter: scaleCenter} = e;
        if (1 === scale) return;
        const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
        pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
            postMatrix: new Matrix
        }), pathGroup.scale(scale, scale, scaleCenter));
        const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
        vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
    }
    handlePan(e) {
        var _a, _b, _c;
        const {delta: delta} = e;
        if (0 === delta[0] && 0 === delta[1]) return;
        const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
        pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
            postMatrix: new Matrix
        }), pathGroup.translate(delta[0], delta[1]));
        const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
        vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
    }
    getDatumCenter(datum) {
        var _a, _b, _c, _d;
        return this._centroidProperty && (null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._centroidProperty]) ? null === (_b = datum.properties) || void 0 === _b ? void 0 : _b[this._centroidProperty] : isValidNumber(datum.centroidX * datum.centroidY) ? [ datum.centroidX, datum.centroidY ] : (null === (_c = datum.properties) || void 0 === _c ? void 0 : _c.center) ? datum.properties.center : (null === (_d = datum.properties) || void 0 === _d ? void 0 : _d.centroid) ? datum.properties.centroid : [ Number.NaN, Number.NaN ];
    }
    getDatumName(datum) {
        var _a, _b, _c, _d;
        return datum[this.nameField] ? datum[this.nameField] : (null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._nameProperty]) ? (null === (_b = this._spec) || void 0 === _b ? void 0 : _b.nameMap) ? null !== (_c = this._spec.nameMap[datum.properties[this._nameProperty]]) && void 0 !== _c ? _c : "" : null !== (_d = datum.properties[this._nameProperty]) && void 0 !== _d ? _d : "" : "";
    }
    dataToPositionX(data) {
        var _a;
        return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 
        0;
    }
    dataToPositionY(data) {
        var _a;
        return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 
        0;
    }
    viewDataUpdate(d) {
        var _a, _b, _c;
        super.viewDataUpdate(d), null === (_b = null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), 
        null === (_c = this._mapViewData) || void 0 === _c || _c.updateData();
    }
    _getDataIdKey() {
        return DEFAULT_DATA_INDEX;
    }
    getActiveMarks() {
        return [ this._pathMark ];
    }
}

MapSeries.type = SeriesTypeEnum.map, MapSeries.mark = mapSeriesMark, MapSeries.transformerConstructor = MapSeriesSpecTransformer;

export const registerMapSeries = () => {
    registerProjection(), registerGeoCoordinate(), registerPathMark(), Factory.registerSeries(MapSeries.type, MapSeries), 
    Factory.registerImplement("registerMap", registerMapSource), Factory.registerImplement("unregisterMap", unregisterMapSource), 
    registerFadeInOutAnimation();
};
//# sourceMappingURL=map.js.map
