import { array, isArray, isNil, isValid, isObject, degreeToRadian, mixin } from "@visactor/vutils";

import { registerSunburstAnimation } from "./animation";

import { registerDataSetInstanceTransform } from "../../data/register";

import { flatten } from "../../data/transforms/flatten";

import { sunburstLayout } from "../../data/transforms/sunburst";

import { SeriesTypeEnum } from "../interface/type";

import { MarkTypeEnum } from "../../mark/interface/type";

import { AttributeLevel, DEFAULT_DATA_KEY } from "../../constant";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { DEFAULT_HIERARCHY_DEPTH, DEFAULT_HIERARCHY_ROOT } from "../../constant/hierarchy";

import { registerFadeInOutAnimation } from "../../animation/config";

import { addHierarchyDataKey, initHierarchyKeyMap } from "../../data/transforms/data-key";

import { addVChartProperty } from "../../data/transforms/add-property";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { PolarSeries } from "../polar/polar";

import { SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD } from "../../constant/sunburst";

import { SunburstTooltipHelper } from "./tooltip-helper";

import { Drillable } from "../../interaction/drill/drillable";

import { registerArcMark } from "../../mark/arc";

import { registerTextMark } from "../../mark/text";

import { sunburstSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

export class SunburstSeries extends PolarSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.sunburst;
    }
    setCategoryField(f) {
        return this._categoryField = f, this._categoryField;
    }
    getCategoryField() {
        return this._categoryField;
    }
    setValueField(f) {
        return this._valueField = f, this._valueField;
    }
    getValueField() {
        return this._valueField;
    }
    getDimensionField() {
        return [ this._categoryField ];
    }
    getMeasureField() {
        return [ this._valueField ];
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), 
        this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), 
        this._spec.drill && this.initDrillable({
            event: this.event,
            mode: this._option.mode,
            drillField: () => {
                var _a;
                return null !== (_a = this._spec.drillField) && void 0 !== _a ? _a : DEFAULT_DATA_KEY;
            },
            getRawData: () => this.getRawData()
        }), this._startAngle = degreeToRadian(this._spec.startAngle), this._endAngle = degreeToRadian(this._spec.endAngle), 
        this._centerX = this._spec.centerX, this._centerY = this._spec.centerY, this._offsetX = this._spec.offsetX, 
        this._offsetY = this._spec.offsetY, this.__innerRadius = this._spec.innerRadius, 
        this.__outerRadius = this._spec.outerRadius, this._gap = this._spec.gap, this._labelLayout = this._spec.labelLayout, 
        this._sunburst = this._spec.sunburst, this._label = this._spec.label, this._labelAutoVisible = this._spec.labelAutoVisible;
    }
    initData() {
        super.initData();
        const rawData = this.getRawData();
        rawData && (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "sunburstLayout", sunburstLayout), 
        registerDataSetInstanceTransform(this._dataSet, "flatten", flatten), rawData.transform({
            type: "sunburstLayout",
            options: () => {
                const {innerRadius: innerRadius, outerRadius: outerRadius, gap: gap, label: label} = this._computeLevel();
                return {
                    nodeKey: this._categoryField,
                    width: this.getLayoutRect().width,
                    height: this.getLayoutRect().height,
                    center: [ isValid(this._centerX) ? this._centerX : this.getLayoutRect().width / 2, isValid(this._centerY) ? this._centerY : this.getLayoutRect().height / 2 ],
                    startAngle: this._startAngle,
                    endAngle: this._endAngle,
                    innerRadius: innerRadius,
                    outerRadius: outerRadius,
                    gapRadius: gap,
                    label: label
                };
            }
        }), rawData.transform({
            type: "flatten",
            options: {
                callback: node => {
                    if (node.datum) {
                        const nodeData = node.datum[node.depth];
                        return Object.assign(Object.assign({}, node), nodeData);
                    }
                    return node;
                }
            }
        }));
    }
    getStatisticFields() {
        return super.getStatisticFields().concat([ {
            key: this._categoryField,
            operations: [ "values" ]
        }, {
            key: this._valueField,
            operations: [ "max", "min" ]
        }, {
            key: DEFAULT_HIERARCHY_DEPTH,
            operations: [ "max", "min", "values" ]
        }, {
            key: DEFAULT_HIERARCHY_ROOT,
            operations: [ "values" ]
        } ]);
    }
    _addDataIndexAndKey() {
        const rawData = this.getRawData();
        isNil(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), 
        rawData.transform({
            type: "addVChartProperty",
            options: {
                beforeCall: initHierarchyKeyMap.bind(this),
                call: addHierarchyDataKey
            }
        }));
    }
    initMark() {
        this._initArcMark(), this._initLabelMark();
    }
    initMarkStyle() {
        this._initArcMarkStyle(), this._initLabelMarkStyle();
    }
    _initArcMark() {
        var _a;
        if (!1 === this._sunburst.visible) return;
        const sunburstMark = this._createMark(SunburstSeries.mark.sunburst, {
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.sunburst) || void 0 === _a ? void 0 : _a.customShape
        });
        this._sunburstMark = sunburstMark, this._trigger.registerMark(this._sunburstMark);
    }
    _initArcMarkStyle() {
        isNil(this._sunburstMark) || this.setMarkStyle(this._sunburstMark, {
            x: d => d.x + (isValid(this._offsetX) ? this._offsetX : 0),
            y: d => d.y + (isValid(this._offsetY) ? this._offsetY : 0),
            outerRadius: d => d.outerRadius,
            innerRadius: d => d.innerRadius,
            startAngle: d => d.startAngle,
            endAngle: d => d.endAngle,
            fill: this.getColorAttribute()
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    _initLabelMark() {
        if (!0 !== this._label.visible) return;
        const labelMark = this._createMark(SunburstSeries.mark.label, {
            isSeriesMark: !1
        });
        this._labelMark = labelMark, this._trigger.registerMark(labelMark);
    }
    _initLabelMarkStyle() {
        isNil(this._labelMark) || this.setMarkStyle(this._labelMark, {
            visible: d => {
                var _a;
                const labelAutoVisible = this._labelAutoVisible;
                return isObject(labelAutoVisible) && !0 === labelAutoVisible.enable ? (d.endAngle - d.startAngle) * (d.outerRadius - d.innerRadius) > (null !== (_a = null == labelAutoVisible ? void 0 : labelAutoVisible.circumference) && void 0 !== _a ? _a : SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD) : this._spec.label.visible;
            },
            x: d => {
                var _a;
                return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.x) + (isValid(this._offsetX) ? this._offsetX : 0);
            },
            y: d => {
                var _a;
                return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.y) + (isValid(this._offsetY) ? this._offsetY : 0);
            },
            textBaseline: d => {
                var _a;
                return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textBaseline;
            },
            textAlign: d => {
                var _a;
                return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textAlign;
            },
            angle: d => {
                var _a, _b;
                return null !== (_b = null === (_a = d.label) || void 0 === _a ? void 0 : _a.angle) && void 0 !== _b ? _b : 0;
            },
            fontSize: 10,
            text: d => d.name
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    initTooltip() {
        this._tooltipHelper = new SunburstTooltipHelper(this), this._sunburstMark && this._tooltipHelper.activeTriggerSet.mark.add(this._sunburstMark), 
        this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
    }
    initAnimation() {
        var _a, _b;
        const animationParams = {
            animationInfo: () => ({
                innerRadius: this._computeRadius(array(this.__innerRadius))[0],
                outerRadius: this._computeRadius(array(this.__outerRadius))[0],
                startAngle: array(this._startAngle)[0],
                endAngle: array(this._endAngle)[0]
            })
        }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this.getMarksInType(MarkTypeEnum.arc).forEach((mark => {
            var _a;
            mark.setAnimationConfig(animationConfig(null === (_a = Factory.getAnimationInKey("sunburst")) || void 0 === _a ? void 0 : _a(animationParams, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
        })), this.getMarksInType(MarkTypeEnum.text).forEach((mark => {
            var _a;
            mark.setAnimationConfig(animationConfig(null === (_a = Factory.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
        }));
    }
    initEvent() {
        super.initEvent(), this._spec.drill && this.bindDrillEvent();
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
    }
    _computeRadius(radius) {
        if (isArray(radius)) return radius.map((r => {
            const {width: width, height: height} = this.getRegion().getLayoutRect();
            return Math.min(width / 2, height / 2) * r;
        }));
        const {width: width, height: height} = this.getRegion().getLayoutRect();
        return Math.min(width / 2, height / 2) * radius;
    }
    _computeLevel() {
        return {
            innerRadius: this._computeRadius(this.__innerRadius),
            outerRadius: this._computeRadius(this.__outerRadius),
            gap: this._gap,
            label: this._labelLayout
        };
    }
    getGroupFields() {
        return [];
    }
    getStackGroupFields() {
        return [];
    }
    getStackValueField() {
        return "";
    }
    _noAnimationDataKey(datum, index) {}
    getActiveMarks() {
        return [ this._sunburstMark ];
    }
}

SunburstSeries.type = SeriesTypeEnum.sunburst, SunburstSeries.mark = sunburstSeriesMark, 
mixin(SunburstSeries, Drillable);

export const registerSunBurstSeries = () => {
    Factory.registerSeries(SunburstSeries.type, SunburstSeries), registerArcMark(), 
    registerTextMark(), registerFadeInOutAnimation(), registerSunburstAnimation();
};
//# sourceMappingURL=sunburst.js.map
