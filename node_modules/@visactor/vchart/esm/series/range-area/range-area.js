import { AreaSeries } from "../area/area";

import { SeriesTypeEnum } from "../interface/type";

import { registerAreaMark } from "../../mark/area";

import { DEFAULT_SMOOTH_INTERPOLATE } from "../../typings/interpolate";

import { Direction } from "../../typings/space";

import { AttributeLevel } from "../../constant";

import { RangeAreaSeriesTooltipHelper } from "./tooltip-helper";

import { rangeAreaSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

export class RangeAreaSeries extends AreaSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.rangeArea;
    }
    initMark() {
        var _a;
        this._areaMark = this._createMark(RangeAreaSeries.mark.area, {
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.customShape
        });
    }
    initMarkStyle() {
        var _a, _b, _c, _d, _e;
        const userCurveType = null !== (_c = null === (_b = null === (_a = this.getSpec().area) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType) && void 0 !== _c ? _c : null === (_e = null === (_d = this.getSpec().line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? this._direction === Direction.vertical ? "monotoneX" : "monotoneY" : userCurveType, areaMark = this._areaMark;
        areaMark && (this._direction === Direction.vertical ? this.setMarkStyle(this._areaMark, {
            x: this.dataToPositionX.bind(this),
            y1: datum => {
                if (!this._yAxisHelper) return Number.NaN;
                const {dataToPosition: dataToPosition} = this._yAxisHelper;
                return dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
                    bandPosition: this._bandPosition
                });
            },
            y: this.dataToPositionY.bind(this)
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
            x: this.dataToPositionX.bind(this),
            x1: datum => {
                if (!this._xAxisHelper) return Number.NaN;
                const {dataToPosition: dataToPosition} = this._xAxisHelper;
                return dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
                    bandPosition: this._bandPosition
                });
            },
            y: this.dataToPositionY.bind(this),
            orient: this._direction
        }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
            fill: this.getColorAttribute(),
            stroke: !1
        }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
            defined: this._getInvalidDefined,
            connectedType: this._getInvalidConnectType()
        }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
            curveType: curveType
        }, "normal", AttributeLevel.Built_In), this._trigger.registerMark(areaMark));
    }
    initTooltip() {
        this._tooltipHelper = new RangeAreaSeriesTooltipHelper(this), this._areaMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._areaMark);
    }
    viewDataStatisticsUpdate(d) {
        super.viewDataStatisticsUpdate(d), this.encodeDefined(this._areaMark, "defined");
    }
}

RangeAreaSeries.type = SeriesTypeEnum.rangeArea, RangeAreaSeries.mark = rangeAreaSeriesMark;

export const registerRangeAreaSeries = () => {
    registerAreaMark(), Factory.registerSeries(RangeAreaSeries.type, RangeAreaSeries);
};
//# sourceMappingURL=range-area.js.map
