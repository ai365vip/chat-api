import { isContinuous } from "@visactor/vscale";

import { Direction } from "../../typings/space";

import { CartesianSeries } from "../cartesian/cartesian";

import { MarkTypeEnum } from "../../mark/interface/type";

import { AttributeLevel } from "../../constant";

import { valueInScaleRange } from "../../util/scale";

import { getRegionStackGroup } from "../../util/data";

import { getActualNumValue } from "../../util/space";

import { registerBarAnimation } from "./animation";

import { animationConfig, shouldMarkDoMorph, userAnimationConfig } from "../../animation/utils";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { registerRectMark } from "../../mark/rect";

import { array, isValid, last } from "@visactor/vutils";

import { barSeriesMark } from "./constant";

import { stackWithMinHeight } from "../util/stack";

import { Factory } from "../../core/factory";

import { registerDataSetInstanceTransform } from "../../data/register";

import { SeriesData } from "../base/series-data";

import { DataView } from "@visactor/vdataset";

import { addVChartProperty } from "../../data/transforms/add-property";

import { addDataKey, initKeyMap } from "../../data/transforms/data-key";

import { registerSampleTransform } from "@visactor/vgrammar-core";

import { getGroupAnimationParams } from "../util/utils";

import { BarSeriesSpecTransformer } from "./bar-transformer";

import { RECT_X, RECT_X1, RECT_Y, RECT_Y1 } from "../base/constant";

export const DefaultBandWidth = 6;

export class BarSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.bar, this._barMarkName = SeriesMarkNameEnum.bar, 
        this._barMarkType = MarkTypeEnum.rect, this.transformerConstructor = BarSeriesSpecTransformer, 
        this._supportStack = !0, this._bandPosition = 0;
    }
    initMark() {
        var _a;
        const progressive = {
            progressiveStep: this._spec.progressiveStep,
            progressiveThreshold: this._spec.progressiveThreshold,
            large: this._spec.large,
            largeThreshold: this._spec.largeThreshold
        };
        this._initBarBackgroundMark(progressive), this._barMark = this._createMark(Object.assign(Object.assign({}, BarSeries.mark.bar), {
            name: this._barMarkName,
            type: this._barMarkType
        }), {
            morph: shouldMarkDoMorph(this._spec, this._barMarkName),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            isSeriesMark: !0,
            progressive: progressive,
            customShape: null === (_a = this._spec.bar) || void 0 === _a ? void 0 : _a.customShape
        });
    }
    _initBarBackgroundMark(progressive) {
        var _a, _b;
        (null === (_a = this._spec.barBackground) || void 0 === _a ? void 0 : _a.visible) && (this._barBackgroundMark = this._createMark(BarSeries.mark.barBackground, {
            dataView: this._barBackgroundViewData.getDataView(),
            dataProductId: this._barBackgroundViewData.getProductId(),
            progressive: progressive,
            customShape: null === (_b = this._spec.barBackground) || void 0 === _b ? void 0 : _b.customShape
        }));
    }
    initMarkStyle() {
        this._barMark && (this.setMarkStyle(this._barMark, {
            fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(this._barMark));
    }
    initLabelMarkStyle(textMark) {
        textMark && this.setMarkStyle(textMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getStackValueField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        });
    }
    initTooltip() {
        super.initTooltip(), this._barMark && this._tooltipHelper.activeTriggerSet.mark.add(this._barMark);
    }
    _statisticViewData() {
        var _a, _b;
        if (super._statisticViewData(), !(null === (_a = this._spec.barBackground) || void 0 === _a ? void 0 : _a.visible)) return;
        registerDataSetInstanceTransform(this._option.dataSet, "addVChartProperty", addVChartProperty), 
        registerDataSetInstanceTransform(this._option.dataSet, "dimensionItems", (([data], op) => {
            var _a;
            let dataCollect = [ {} ];
            const fields = this.getDimensionField();
            for (let i = 0; i < fields.length; i++) {
                const field = fields[i], values = null === (_a = data.latestData[field]) || void 0 === _a ? void 0 : _a.values;
                if (!(null == values ? void 0 : values.length)) continue;
                const newDataCollect = [];
                for (let j = 0; j < values.length; j++) for (let k = 0; k < dataCollect.length; k++) newDataCollect.push(Object.assign(Object.assign({}, dataCollect[k]), {
                    [field]: values[j]
                }));
                dataCollect = newDataCollect;
            }
            return dataCollect;
        }));
        const barBackgroundData = new DataView(this._option.dataSet).parse([ this._viewDataStatistics ], {
            type: "dataview"
        }).transform({
            type: "dimensionItems"
        }, !1).transform({
            type: "addVChartProperty",
            options: {
                beforeCall: initKeyMap.bind(this),
                call: addDataKey
            }
        }, !1);
        null === (_b = this._viewDataStatistics) || void 0 === _b || _b.target.addListener("change", barBackgroundData.reRunAllTransform), 
        this._barBackgroundViewData = new SeriesData(this._option, barBackgroundData);
    }
    init(option) {
        var _a, _b;
        super.init(option), "vertical" === this.direction ? "band" === (null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle() : "band" === (null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle();
    }
    _shouldDoPreCalculate() {
        const region = this.getRegion();
        return this._stack && region.getSeries().filter((s => s.type === this.type && s.getSpec().barMinHeight)).length;
    }
    _calculateStackRectPosition(isVertical) {
        const region = this.getRegion();
        if (region._bar_series_position_calculated) return;
        let start, end, startMethod, endMethod, axisHelper;
        region._bar_series_position_calculated = !0, isVertical ? (start = RECT_Y1, end = RECT_Y, 
        startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (start = RECT_X1, 
        end = RECT_X, startMethod = "_dataToPosX1", endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
        const stackValueGroup = getRegionStackGroup(region, !1, (s => s.type === this.type));
        for (const stackValue in stackValueGroup) for (const key in stackValueGroup[stackValue].nodes) stackWithMinHeight(stackValueGroup[stackValue].nodes[key], region.getStackInverse(), {
            isVertical: isVertical,
            start: start,
            end: end,
            startMethod: startMethod,
            endMethod: endMethod,
            axisHelper: axisHelper
        });
    }
    _calculateRectPosition(datum, isVertical) {
        var _a, _b;
        let startMethod, endMethod, axisHelper;
        isVertical ? (startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (startMethod = "_dataToPosX1", 
        endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
        const seriesScale = null === (_b = (_a = this[axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), inverse = this[axisHelper].isInverse(), barMinHeight = this._spec.barMinHeight, y1 = valueInScaleRange(this[startMethod](datum), seriesScale), y = valueInScaleRange(this[endMethod](datum), seriesScale);
        let height = Math.abs(y1 - y);
        height < barMinHeight && (height = barMinHeight);
        let flag = 1;
        return y < y1 ? flag = -1 : y === y1 && (flag = isVertical ? inverse ? 1 : -1 : inverse ? -1 : 1), 
        y1 + flag * height;
    }
    _dataToPosX(datum) {
        return this.dataToPositionX(datum);
    }
    _dataToPosX1(datum) {
        return this.dataToPositionX1(datum);
    }
    _dataToPosY(datum) {
        return this.dataToPositionY(datum);
    }
    _dataToPosY1(datum) {
        return this.dataToPositionY1(datum);
    }
    initBandRectMarkStyle() {
        var _a, _b, _c, _d;
        const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
        this.direction === Direction.horizontal ? this.setMarkStyle(this._barMark, {
            x: datum => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!1), 
            datum[RECT_X]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, !1) : valueInScaleRange(this._dataToPosX(datum), xScale),
            x1: datum => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!1), 
            datum[RECT_X1]) : valueInScaleRange(this._dataToPosX1(datum), xScale),
            y: datum => this._getPosition(this.direction, datum),
            height: () => this._getBarWidth(this._yAxisHelper)
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barMark, {
            x: datum => this._getPosition(this.direction, datum),
            y: (datum, ctx, opt, dataView) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!0), 
            datum[RECT_Y]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, !0) : valueInScaleRange(this._dataToPosY(datum), yScale),
            y1: datum => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!0), 
            datum[RECT_Y1]) : valueInScaleRange(this._dataToPosY1(datum), yScale),
            width: () => this._getBarWidth(this._xAxisHelper)
        }, "normal", AttributeLevel.Series), this._initBarBackgroundMarkStyle();
    }
    _initBarBackgroundMarkStyle() {
        var _a, _b, _c, _d;
        if (!this._barBackgroundMark) return;
        const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
        this.direction === Direction.horizontal ? this.setMarkStyle(this._barBackgroundMark, {
            x: () => {
                const range = xScale.range();
                return Math.min(range[0], range[range.length - 1]);
            },
            x1: () => {
                const range = xScale.range();
                return Math.max(range[0], range[range.length - 1]);
            },
            y: datum => this._getPosition(this.direction, datum),
            height: () => this._getBarWidth(this._yAxisHelper)
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barBackgroundMark, {
            x: datum => this._getPosition(this.direction, datum),
            y: () => {
                const range = yScale.range();
                return Math.min(range[0], range[range.length - 1]);
            },
            y1: () => {
                const range = yScale.range();
                return Math.max(range[0], range[range.length - 1]);
            },
            width: () => this._getBarWidth(this._xAxisHelper)
        }, "normal", AttributeLevel.Series);
    }
    initLinearRectMarkStyle() {
        var _a, _b, _c, _d;
        const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
        this.direction === Direction.vertical ? this.setMarkStyle(this._barMark, {
            x: datum => valueInScaleRange(this.dataToPositionX(datum), xScale),
            x1: datum => valueInScaleRange(this.dataToPositionX1(datum), xScale),
            y: (datum, ctx, opt, dataView) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!0), 
            datum[RECT_Y]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, !0) : valueInScaleRange(this.dataToPositionY(datum), yScale),
            y1: datum => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!0), 
            datum[RECT_Y1]) : valueInScaleRange(this.dataToPositionY1(datum), yScale)
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barMark, {
            x: datum => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!1), 
            datum[RECT_X]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, !1) : valueInScaleRange(this.dataToPositionX(datum), xScale),
            x1: datum => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(!1), 
            datum[RECT_X1]) : valueInScaleRange(this.dataToPositionX1(datum), xScale),
            y: datum => valueInScaleRange(this.dataToPositionY(datum), yScale),
            y1: datum => valueInScaleRange(this.dataToPositionY1(datum), yScale)
        }, "normal", AttributeLevel.Series);
    }
    initAnimation() {
        var _a, _b;
        const barAnimationParams = {
            yField: this._fieldY[0],
            xField: this._fieldX[0],
            direction: this.direction,
            growFrom: () => {
                var _a, _b;
                return "horizontal" === this.direction ? null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale(0).scale(0) : null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.getScale(0).scale(0);
            }
        }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset, animationParams = getGroupAnimationParams(this);
        this._barMark.setAnimationConfig(animationConfig(null === (_b = Factory.getAnimationInKey("bar")) || void 0 === _b ? void 0 : _b(barAnimationParams, appearPreset), userAnimationConfig(this._barMarkName, this._spec, this._markAttributeContext), animationParams));
    }
    _getBarWidth(axisHelper) {
        var _a, _b;
        const hasBarWidth = void 0 !== this._spec.barWidth, bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _b ? _b : 6;
        if (hasBarWidth) return getActualNumValue(this._spec.barWidth, bandWidth);
        const hasBarMinWidth = void 0 !== this._spec.barMinWidth, hasBarMaxWidth = void 0 !== this._spec.barMaxWidth;
        let width = bandWidth;
        return hasBarMinWidth && (width = Math.max(width, getActualNumValue(this._spec.barMinWidth, bandWidth))), 
        hasBarMaxWidth && (width = Math.min(width, getActualNumValue(this._spec.barMaxWidth, bandWidth))), 
        width;
    }
    _getPosition(direction, datum) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        let axisHelper, sizeAttribute, dataToPosition;
        direction === Direction.horizontal ? (axisHelper = this.getYAxisHelper(), sizeAttribute = "height", 
        dataToPosition = this.dataToPositionY.bind(this)) : (axisHelper = this.getXAxisHelper(), 
        sizeAttribute = "width", dataToPosition = this.dataToPositionX.bind(this));
        const scale = axisHelper.getScale(0), size = this._barMark.getAttribute(sizeAttribute, datum), bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _b ? _b : 6;
        if ((null === (_d = null === (_c = this._groups) || void 0 === _c ? void 0 : _c.fields) || void 0 === _d ? void 0 : _d.length) > 1 && isValid(this._spec.barGapInGroup)) {
            const groupFields = this._groups.fields, barInGroup = array(this._spec.barGapInGroup);
            let totalWidth = 0, offSet = 0;
            for (let index = groupFields.length - 1; index >= 1; index--) {
                const groupField = groupFields[index], groupValues = null !== (_h = null === (_g = null === (_f = null === (_e = this.getViewDataStatistics()) || void 0 === _e ? void 0 : _e.latestData) || void 0 === _f ? void 0 : _f[groupField]) || void 0 === _g ? void 0 : _g.values) && void 0 !== _h ? _h : [], groupCount = groupValues.length, gap = getActualNumValue(null !== (_j = barInGroup[index - 1]) && void 0 !== _j ? _j : last(barInGroup), bandWidth), i = groupValues.indexOf(datum[groupField]);
                index === groupFields.length - 1 ? (totalWidth += groupCount * size + (groupCount - 1) * gap, 
                offSet += i * (size + gap)) : (offSet += i * (totalWidth + gap), totalWidth += totalWidth + (groupCount - 1) * gap);
            }
            return scale.scale(datum[groupFields[0]]) + axisHelper.getBandwidth(0) / 2 - totalWidth / 2 + offSet;
        }
        const continuous = isContinuous(scale.type || "band");
        return dataToPosition(datum) + .5 * (bandWidth - size) + (continuous ? -bandWidth / 2 : 0);
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx);
        this.getRegion()._bar_series_position_calculated = !1, this._spec.sampling && this.compile();
    }
    compile() {
        if (super.compile(), this._spec.sampling) {
            const {width: width, height: height} = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
            samplingTrans.push({
                type: "sampling",
                size: this._direction === Direction.vertical ? width : height,
                factor: this._spec.samplingFactor,
                yfield: this._direction === Direction.vertical ? fieldsY[0] : fieldsX[0],
                groupBy: this._seriesField,
                mode: this._spec.sampling
            }), this._data.getProduct().transform(samplingTrans);
        }
    }
    getDefaultShapeType() {
        return "square";
    }
    getActiveMarks() {
        return [ this._barMark ];
    }
    compileData() {
        var _a;
        super.compileData(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.compile();
    }
    fillData() {
        var _a, _b;
        super.fillData(), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform();
    }
    viewDataUpdate(d) {
        var _a, _b, _c;
        super.viewDataUpdate(d), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), 
        null === (_c = this._barBackgroundViewData) || void 0 === _c || _c.updateData();
    }
    release() {
        var _a;
        super.release(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.release(), 
        this._barBackgroundViewData = null;
    }
}

BarSeries.type = SeriesTypeEnum.bar, BarSeries.mark = barSeriesMark, BarSeries.transformerConstructor = BarSeriesSpecTransformer;

export const registerBarSeries = () => {
    registerSampleTransform(), registerRectMark(), registerBarAnimation(), Factory.registerSeries(BarSeries.type, BarSeries);
};
//# sourceMappingURL=bar.js.map
