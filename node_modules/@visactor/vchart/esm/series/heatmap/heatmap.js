import { registerCellMark } from "./../../mark/cell";

import { CartesianSeries } from "../cartesian/cartesian";

import { AttributeLevel } from "../../constant";

import { registerHeatmapAnimation } from "./animation";

import { animationConfig, shouldMarkDoMorph, userAnimationConfig } from "../../animation/utils";

import { registerTextMark } from "../../mark/text";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { normalizePadding, array } from "@visactor/vutils";

import { HeatmapSeriesTooltipHelper } from "./tooltip-helper";

import { heatmapSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { getGroupAnimationParams } from "../util/utils";

import { HeatmapSeriesSpecTransformer } from "./heatmap-transformer";

export const DefaultBandWidth = 6;

export class HeatmapSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.heatmap, this.transformerConstructor = HeatmapSeriesSpecTransformer;
    }
    getFieldValue() {
        return this._fieldValue;
    }
    setFieldValue(f) {
        this._fieldValue = array(f);
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this.setFieldValue(this._spec.valueField);
    }
    initMark() {
        var _a, _b;
        const progressive = {
            progressiveStep: this._spec.progressiveStep,
            progressiveThreshold: this._spec.progressiveThreshold,
            large: this._spec.large,
            largeThreshold: this._spec.largeThreshold
        };
        this._cellMark = this._createMark(HeatmapSeries.mark.cell, {
            morph: shouldMarkDoMorph(this._spec, HeatmapSeries.mark.cell.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            isSeriesMark: !0,
            progressive: progressive,
            customShape: null === (_a = this._spec.cell) || void 0 === _a ? void 0 : _a.customShape
        }), this._backgroundMark = this._createMark(HeatmapSeries.mark.cellBackground, {
            progressive: progressive,
            customShape: null === (_b = this._spec.cellBackground) || void 0 === _b ? void 0 : _b.customShape
        });
    }
    initMarkStyle() {
        this.initCellMarkStyle(), this.initCellBackgroundMarkStyle();
    }
    initLabelMarkStyle(textMark) {
        textMark && this.setMarkStyle(textMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getMeasureField()[0]]
        });
    }
    initCellMarkStyle() {
        this.setMarkStyle(this._cellMark, {
            x: datum => this.dataToPositionX(datum),
            y: datum => this.dataToPositionY(datum),
            size: () => [ this.getCellSize(this._xAxisHelper), this.getCellSize(this._yAxisHelper) ],
            fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(this._cellMark);
    }
    initCellBackgroundMarkStyle() {
        var _a, _b, _c;
        const padding = normalizePadding(null !== (_c = null === (_b = null === (_a = this._spec.cellBackground) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.padding) && void 0 !== _c ? _c : 0);
        this.setMarkStyle(this._backgroundMark, {
            x: datum => {
                const width = this.getCellSize(this._xAxisHelper);
                return this.dataToPositionX(datum) - width / 2 + padding[3];
            },
            y: datum => {
                const height = this.getCellSize(this._yAxisHelper);
                return this.dataToPositionY(datum) - height / 2 + padding[0];
            },
            width: () => this.getCellSize(this._xAxisHelper) - padding[1] - padding[3],
            height: () => this.getCellSize(this._yAxisHelper) - padding[0] - padding[2]
        }, "normal", AttributeLevel.Series);
    }
    getColorAttribute() {
        var _a;
        return {
            scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
            field: this.getFieldValue[0]
        };
    }
    initAnimation() {
        var _a, _b, _c;
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, animationParams = getGroupAnimationParams(this);
        this._cellMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("heatmap")) || void 0 === _c ? void 0 : _c(appearPreset), userAnimationConfig(SeriesMarkNameEnum.cell, this._spec, this._markAttributeContext), animationParams));
    }
    getCellSize(axisHelper) {
        var _a, _b;
        return null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, 0)) && void 0 !== _b ? _b : 6;
    }
    initTooltip() {
        this._tooltipHelper = new HeatmapSeriesTooltipHelper(this), this._cellMark && this._tooltipHelper.activeTriggerSet.mark.add(this._cellMark);
    }
    getDefaultShapeType() {
        return "square";
    }
    getDimensionField() {
        return [].concat(this.fieldX, this.fieldY);
    }
    getMeasureField() {
        return this.getFieldValue();
    }
    getActiveMarks() {
        return [ this._cellMark ];
    }
}

HeatmapSeries.type = SeriesTypeEnum.heatmap, HeatmapSeries.mark = heatmapSeriesMark, 
HeatmapSeries.transformerConstructor = HeatmapSeriesSpecTransformer;

export const registerHeatmapSeries = () => {
    registerTextMark(), registerCellMark(), registerHeatmapAnimation(), Factory.registerSeries(HeatmapSeries.type, HeatmapSeries);
};
//# sourceMappingURL=heatmap.js.map
