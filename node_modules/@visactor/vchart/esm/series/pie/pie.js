import { degreeToRadian, isValid } from "@visactor/vutils";

import { DataView } from "@visactor/vdataset";

import { AttributeLevel, ARC_START_ANGLE, ARC_END_ANGLE, ARC_RATIO, ARC_MIDDLE_ANGLE, ARC_RADIAN, ARC_QUADRANT, ARC_K, PREFIX, DEFAULT_LABEL_VISIBLE, POLAR_START_RADIAN, POLAR_END_RADIAN, DEFAULT_DATA_INDEX, ChartEvent, DEFAULT_DATA_KEY } from "../../constant";

import { normalizeStartEndAngle, polarToCartesian } from "../../util/math";

import { isSpecValueWithScale } from "../../util/scale";

import { field } from "../../util/object";

import { PolarSeries } from "../polar/polar";

import { MarkTypeEnum } from "../../mark/interface/type";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { pie } from "../../data/transforms/pie";

import { registerDataSetInstanceTransform } from "../../data/register";

import { registerPieAnimation } from "./animation/animation";

import { animationConfig, shouldMarkDoMorph, userAnimationConfig } from "../../animation/utils";

import { AnimationStateEnum } from "../../animation/interface";

import { SeriesData } from "../base/series-data";

import { centerOffsetConfig } from "./animation/centerOffset";

import { registerArcMark } from "../../mark/arc";

import { pieSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { isNil } from "@visactor/vutils";

import { PieSeriesSpecTransformer } from "./pie-transformer";

export class BasePieSeries extends PolarSeries {
    constructor() {
        super(...arguments), this.transformerConstructor = PieSeriesSpecTransformer, this._pieMarkName = SeriesMarkNameEnum.pie, 
        this._pieMarkType = MarkTypeEnum.arc, this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, 
        this._pieMark = null, this._labelMark = null, this._labelLineMark = null, this.dataToCentralPosition = datum => {
            const angle = datum[ARC_MIDDLE_ANGLE];
            if (isNil(angle)) return null;
            const radius = this.computeDatumRadius(datum), innerRadius = this.computeDatumInnerRadius(datum), center = this.computeCenter(datum), delta = polarToCartesian({
                angle: angle,
                radius: (radius + innerRadius) / 2
            });
            return {
                x: center.x + delta.x,
                y: center.y + delta.y
            };
        };
    }
    get center() {
        var _a, _b, _c, _d;
        return {
            x: null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerX) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2,
            y: null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.centerY) && void 0 !== _d ? _d : this._region.getLayoutRect().height / 2
        };
    }
    _buildMarkAttributeContext() {
        super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
            x: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2;
            },
            y: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : this._region.getLayoutRect().height / 2;
            }
        }), this._markAttributeContext.startAngleScale = datum => this.startAngleScale(datum), 
        this._markAttributeContext.endAngleScale = datum => this.endAngleScale(datum);
    }
    setAttrFromSpec() {
        var _a, _b;
        super.setAttrFromSpec(), this._centerOffset = null !== (_a = this._spec.centerOffset) && void 0 !== _a ? _a : 0, 
        this._cornerRadius = null !== (_b = this._spec.cornerRadius) && void 0 !== _b ? _b : 0;
        const normalized = normalizeStartEndAngle(isValid(this._spec.startAngle) ? degreeToRadian(this._spec.startAngle) : this._startAngle, isValid(this._spec.endAngle) ? degreeToRadian(this._spec.endAngle) : this._endAngle);
        this._startAngle = normalized.startAngle, this._endAngle = normalized.endAngle, 
        this._padAngle = isValid(this._spec.padAngle) ? degreeToRadian(this._spec.padAngle) : 0, 
        this.setAngleField(this._spec.valueField || this._spec.angleField), this._spec.categoryField && this.setSeriesField(this._spec.categoryField), 
        this._radiusField = [], this._specAngleField = this._angleField.slice(), this._specRadiusField = [];
    }
    initData() {
        super.initData();
        const viewData = this.getViewData();
        if (!viewData) return;
        registerDataSetInstanceTransform(this._dataSet, "pie", pie), viewData.transform({
            type: "pie",
            options: {
                angleField: this._angleField[0],
                startAngle: this._startAngle,
                endAngle: this._endAngle,
                minAngle: isValid(this._spec.minAngle) ? degreeToRadian(this._spec.minAngle) : 0,
                asStartAngle: ARC_START_ANGLE,
                asEndAngle: ARC_END_ANGLE,
                asRatio: ARC_RATIO,
                asMiddleAngle: ARC_MIDDLE_ANGLE,
                asRadian: ARC_RADIAN,
                asQuadrant: ARC_QUADRANT,
                asK: ARC_K
            }
        }, !1);
        const viewDataLabel = new DataView(this._dataSet, {
            name: `${PREFIX}_series_${this.id}_viewDataLabel`
        });
        viewDataLabel.parse([ this.getViewData() ], {
            type: "dataview"
        }), this._viewDataLabel = new SeriesData(this._option, viewDataLabel);
    }
    initMark() {
        var _a;
        this._pieMark = this._createMark(Object.assign(Object.assign({}, BasePieSeries.mark.pie), {
            name: this._pieMarkName,
            type: this._pieMarkType
        }), {
            morph: shouldMarkDoMorph(this._spec, this._pieMarkName),
            defaultMorphElementKey: this._seriesField,
            key: DEFAULT_DATA_KEY,
            groupKey: this._seriesField,
            skipBeforeLayouted: !0,
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.pie) || void 0 === _a ? void 0 : _a.customShape
        });
    }
    startAngleScale(datum) {
        return field(ARC_START_ANGLE)(datum);
    }
    endAngleScale(datum) {
        return field(ARC_END_ANGLE)(datum);
    }
    initMarkStyle() {
        const pieMark = this._pieMark;
        pieMark && (this.setMarkStyle(pieMark, {
            x: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : this._region.getLayoutRect().width / 2;
            },
            y: () => {
                var _a, _b;
                return null !== (_b = null === (_a = this._center) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : this._region.getLayoutRect().height / 2;
            },
            fill: this.getColorAttribute(),
            outerRadius: isSpecValueWithScale(this._outerRadius) ? this._outerRadius : () => this.computeLayoutRadius() * this._outerRadius,
            innerRadius: isSpecValueWithScale(this._innerRadius) ? this._innerRadius : () => this.computeLayoutRadius() * this._innerRadius,
            cornerRadius: () => this.computeLayoutRadius() * this._cornerRadius,
            startAngle: datum => this.startAngleScale(datum),
            endAngle: datum => this.endAngleScale(datum),
            padAngle: this._padAngle,
            centerOffset: this._centerOffset
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(pieMark));
    }
    initTooltip() {
        super.initTooltip(), this._pieMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pieMark);
    }
    initMarkStyleWithSpec(mark, spec, key) {
        if (super.initMarkStyleWithSpec(mark, spec, key), mark.name === this._pieMarkName) {
            const pieSpec = this.getSpec()[mark.name];
            if (pieSpec) for (const state in pieSpec.state || {}) this.setMarkStyle(mark, this.generateRadiusStyle(pieSpec.state[state]), state, AttributeLevel.User_Mark);
        }
    }
    initLabelMarkStyle(textMark) {
        var _a, _b, _c, _d, _e, _f;
        textMark && this.setMarkStyle(textMark, {
            visible: field(DEFAULT_LABEL_VISIBLE).bind(this),
            text: datum => datum[this.getDimensionField()[0]],
            fill: (null === (_b = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) || this.getColorAttribute(),
            angle: null === (_d = null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.angle,
            limit: null === (_f = null === (_e = this._spec.label) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.limit,
            z: this.dataToPositionZ.bind(this)
        });
    }
    afterInitMark() {
        super.afterInitMark(), this._trigger.setStateKeys([ this._seriesField, ...this._radiusField ]);
    }
    initEvent() {
        var _a;
        super.initEvent(), null === (_a = this._viewDataLabel.getDataView()) || void 0 === _a || _a.target.addListener("change", this.viewDataLabelUpdate.bind(this));
    }
    initGroups() {}
    onLayoutEnd(ctx) {
        this._viewDataLabel.getDataView().reRunAllTransform(), this.onMarkPositionUpdate(), 
        super.onLayoutEnd(ctx);
    }
    getDimensionField() {
        return this._seriesField ? [ this._seriesField ] : [];
    }
    getMeasureField() {
        return this._specAngleField;
    }
    viewDataLabelUpdate() {
        this.event.emit(ChartEvent.viewDataLabelUpdate, {
            model: this
        }), this._viewDataLabel.updateData();
    }
    generateRadiusStyle(spec) {
        if (!spec) return;
        const style = {};
        return spec.outerRadius && (style.outerRadius = () => this.computeLayoutRadius() * spec.outerRadius), 
        spec.innerRadius && (style.innerRadius = () => this.computeLayoutRadius() * spec.innerRadius), 
        spec.cornerRadius && (style.cornerRadius = () => this.computeLayoutRadius() * spec.cornerRadius), 
        style;
    }
    computeLayoutRadius() {
        const {width: width, height: height} = this._region.getLayoutRect();
        return Math.min(width / 2, height / 2);
    }
    computeCenter(datum) {
        return {
            x: this._pieMark.getAttribute("x", datum, "normal"),
            y: this._pieMark.getAttribute("y", datum, "normal")
        };
    }
    getRadius(state = "normal") {
        var _a, _b, _c, _d, _e, _f, _g;
        const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.outerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.outerRadius;
        return null != styleRadius ? styleRadius : this._outerRadius;
    }
    getInnerRadius(state = "normal") {
        var _a, _b, _c, _d, _e, _f, _g;
        const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.innerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.innerRadius;
        return null != styleRadius ? styleRadius : this._innerRadius;
    }
    computeRadius(r, k) {
        return this.computeLayoutRadius() * r * (isNil(k) ? 1 : k) + this._centerOffset;
    }
    computeDatumRadius(datum, state) {
        return this.computeLayoutRadius() * this.getRadius(state) + this._centerOffset;
    }
    _compareSpec(spec, prevSpec, ignoreCheckKeys) {
        (ignoreCheckKeys = null != ignoreCheckKeys ? ignoreCheckKeys : {
            data: !0
        }).centerX = !0, ignoreCheckKeys.centerX = !0, ignoreCheckKeys.centerY = !0, ignoreCheckKeys.centerOffset = !0, 
        ignoreCheckKeys.radius = !0, ignoreCheckKeys.innerRadius = !0, ignoreCheckKeys.cornerRadius = !0, 
        ignoreCheckKeys.startAngle = !0, ignoreCheckKeys.endAngle = !0, ignoreCheckKeys.padAngle = !0;
        const {centerX: centerX, centerY: centerY, centerOffset: centerOffset, radius: radius, innerRadius: innerRadius, cornerRadius: cornerRadius, startAngle: startAngle, endAngle: endAngle, padAngle: padAngle} = prevSpec, result = super._compareSpec(spec, prevSpec, ignoreCheckKeys);
        return (spec = null != spec ? spec : {}).centerY === centerY && spec.centerX === centerX && spec.centerOffset === centerOffset && spec.radius === radius && spec.innerRadius === innerRadius && spec.cornerRadius === cornerRadius && spec.startAngle === startAngle && spec.endAngle === endAngle && spec.padAngle === padAngle || (result.reRender = !0, 
        result.change = !0), result;
    }
    computeDatumInnerRadius(datum, state) {
        return this.computeLayoutRadius() * this.getInnerRadius(state) + this._centerOffset;
    }
    dataToPosition(datum) {
        const angle = datum[ARC_MIDDLE_ANGLE];
        if (isNil(angle)) return null;
        const radius = this.computeDatumRadius(datum), center = this.computeCenter(datum), delta = polarToCartesian({
            angle: angle,
            radius: radius
        });
        return {
            x: center.x + delta.x,
            y: center.y + delta.y
        };
    }
    initAnimation() {
        var _a, _b;
        const animationParams = {
            growFrom: (datum, element, state) => {
                var _a;
                if (state === AnimationStateEnum.appear) return this._startAngle;
                if (state === AnimationStateEnum.disappear) return this._endAngle;
                const outState = [ AnimationStateEnum.disappear, AnimationStateEnum.exit ], markElements = element.mark.elements, data = datum, dataIndex = null == data ? void 0 : data[DEFAULT_DATA_INDEX];
                if (void 0 === markElements.find((e => {
                    var _a;
                    return (null === (_a = e.data[0]) || void 0 === _a ? void 0 : _a[DEFAULT_DATA_INDEX]) < dataIndex;
                }))) return this._startAngle;
                if (void 0 === markElements.find((e => {
                    var _a;
                    return (null === (_a = e.data[0]) || void 0 === _a ? void 0 : _a[DEFAULT_DATA_INDEX]) > dataIndex;
                }))) return this._endAngle;
                const prevMarkElement = [ ...markElements ].reverse().find((e => {
                    var _a;
                    return (null === (_a = e.data[0]) || void 0 === _a ? void 0 : _a[DEFAULT_DATA_INDEX]) < dataIndex;
                }));
                return outState.includes(state) ? null === (_a = null == prevMarkElement ? void 0 : prevMarkElement.getNextGraphicAttributes()) || void 0 === _a ? void 0 : _a.endAngle : null == prevMarkElement ? void 0 : prevMarkElement.getGraphicAttribute("endAngle", !0);
            }
        }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
        if (this._pieMark) {
            const pieAnimationConfig = animationConfig(null === (_b = Factory.getAnimationInKey("pie")) || void 0 === _b ? void 0 : _b(animationParams, appearPreset), userAnimationConfig(SeriesMarkNameEnum.pie, this._spec, this._markAttributeContext));
            pieAnimationConfig.normal && pieAnimationConfig.normal.type && (pieAnimationConfig.normal = centerOffsetConfig(this._pieMark, pieAnimationConfig.normal)), 
            this._pieMark.setAnimationConfig(pieAnimationConfig);
        }
    }
    getDefaultShapeType() {
        return "circle";
    }
    getGroupFields() {
        return [];
    }
    getStackGroupFields() {
        return [];
    }
    getStackValueField() {
        return "";
    }
    _noAnimationDataKey(datum, index) {
        return index;
    }
    getActiveMarks() {
        return [ this._pieMark ];
    }
}

BasePieSeries.transformerConstructor = PieSeriesSpecTransformer, BasePieSeries.mark = pieSeriesMark;

export class PieSeries extends BasePieSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.pie;
    }
}

PieSeries.type = SeriesTypeEnum.pie;

export const registerPieSeries = () => {
    registerArcMark(), registerPieAnimation(), Factory.registerSeries(PieSeries.type, PieSeries);
};
//# sourceMappingURL=pie.js.map
