import { isArray } from "@visactor/vutils";

import { LineLikeSeriesMixin } from "../mixin/line-mixin";

import { Direction } from "../../typings/space";

import { CartesianSeries } from "../cartesian/cartesian";

import { AttributeLevel } from "../../constant";

import { valueInScaleRange } from "../../util/scale";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { mixin } from "@visactor/vutils";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { DEFAULT_SMOOTH_INTERPOLATE } from "../../typings/interpolate";

import { registerLineMark } from "../../mark/line";

import { registerAreaMark } from "../../mark/area";

import { registerSymbolMark } from "../../mark/symbol";

import { AreaSeriesTooltipHelper } from "./tooltip-helpter";

import { areaSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { registerAreaAnimation } from "./animation";

import { registerSampleTransform, registerMarkOverlapTransform } from "@visactor/vgrammar-core";

import { AreaSeriesSpecTransformer } from "./area-transformer";

import { getGroupAnimationParams } from "../util/utils";

export class AreaSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.area, this.transformerConstructor = AreaSeriesSpecTransformer, 
        this._supportStack = !0, this._sortDataByAxis = !1;
    }
    initMark() {
        var _a, _b, _c, _d, _e;
        const progressive = {
            progressiveStep: this._spec.progressiveStep,
            progressiveThreshold: this._spec.progressiveThreshold,
            large: this._spec.large,
            largeThreshold: this._spec.largeThreshold
        }, isAreaVisible = !1 !== (null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.visible) && !1 !== (null === (_c = null === (_b = this._spec.area) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible), seriesMark = null !== (_d = this._spec.seriesMark) && void 0 !== _d ? _d : "area";
        this._areaMark = this._createMark(AreaSeries.mark.area, {
            groupKey: this._seriesField,
            defaultMorphElementKey: this.getDimensionField()[0],
            progressive: progressive,
            isSeriesMark: isAreaVisible && "point" !== seriesMark,
            customShape: null === (_e = this._spec.area) || void 0 === _e ? void 0 : _e.customShape
        }), this.initSymbolMark(progressive, "point" === seriesMark);
    }
    initMarkStyle() {
        var _a, _b, _c, _d, _e;
        const userCurveType = null !== (_c = null === (_b = null === (_a = this.getSpec().area) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType) && void 0 !== _c ? _c : null === (_e = null === (_d = this.getSpec().line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? this._direction === Direction.vertical ? "monotoneX" : "monotoneY" : userCurveType, areaMark = this._areaMark;
        areaMark && (this._direction === Direction.vertical ? this.setMarkStyle(this._areaMark, {
            x: this.dataToPositionX.bind(this),
            y1: datum => {
                var _a, _b;
                return valueInScaleRange(this.dataToPositionY1(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0));
            },
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
            x: this.dataToPositionX.bind(this),
            x1: datum => {
                var _a, _b;
                return valueInScaleRange(this.dataToPositionX1(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0));
            },
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
            orient: this._direction
        }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
            fill: this.getColorAttribute(),
            stroke: this.getColorAttribute()
        }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
            defined: this._getInvalidDefined,
            connectedType: this._getInvalidConnectType()
        }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
            curveType: curveType
        }, "normal", AttributeLevel.Built_In), this._trigger.registerMark(areaMark), Object.keys(areaMark.stateStyle).forEach((state => {
            areaMark.stateStyle[state].stroke && areaMark.setPostProcess("stroke", (result => [ result, !1, !1, !1 ]), state);
        }))), this.initLineMarkStyle(this._direction, userCurveType), this.initSymbolMarkStyle();
    }
    initAnimation() {
        var _a, _b, _c, _d;
        const areaAnimationParams = {
            direction: this.direction
        }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
        if (this._lineMark && this._lineMark.setAnimationConfig(animationConfig(null === (_b = Factory.getAnimationInKey("line")) || void 0 === _b ? void 0 : _b(areaAnimationParams, appearPreset), userAnimationConfig(SeriesMarkNameEnum.line, this._spec, this._markAttributeContext))), 
        this._areaMark && this._areaMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("area")) || void 0 === _c ? void 0 : _c(areaAnimationParams, appearPreset), userAnimationConfig(SeriesMarkNameEnum.area, this._spec, this._markAttributeContext))), 
        this._symbolMark) {
            const animationParams = getGroupAnimationParams(this);
            this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig(SeriesMarkNameEnum.point, this._spec, this._markAttributeContext), animationParams));
        }
    }
    initTooltip() {
        this._tooltipHelper = new AreaSeriesTooltipHelper(this), this._areaMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._areaMark), 
        this._lineMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._lineMark), 
        this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
    }
    viewDataStatisticsUpdate(d) {
        super.viewDataStatisticsUpdate(d), this.encodeDefined(this._areaMark, "defined");
    }
    compile() {
        super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
    }
    getDefaultShapeType() {
        return "square";
    }
    getActiveMarks() {
        return [ this._areaMark, this._symbolMark, this._lineMark ];
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this.reCompileSampling();
    }
    getSeriesStyle(datum) {
        return attribute => {
            var _a, _b, _c, _d, _e;
            const seriesMarkType = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "area";
            let result = null !== (_c = null === (_b = this._seriesMark) || void 0 === _b ? void 0 : _b.getAttribute(attribute, datum)) && void 0 !== _c ? _c : void 0;
            return "fill" !== attribute || result && "line" !== seriesMarkType || (attribute = "stroke", 
            result = null !== (_e = null === (_d = this._seriesMark) || void 0 === _d ? void 0 : _d.getAttribute(attribute, datum)) && void 0 !== _e ? _e : void 0), 
            "stroke" === attribute && isArray(result) ? result[0] : result;
        };
    }
}

AreaSeries.type = SeriesTypeEnum.area, AreaSeries.mark = areaSeriesMark, AreaSeries.transformerConstructor = AreaSeriesSpecTransformer, 
mixin(AreaSeries, LineLikeSeriesMixin);

export const registerAreaSeries = () => {
    registerSampleTransform(), registerMarkOverlapTransform(), registerLineMark(), registerAreaMark(), 
    registerSymbolMark(), registerAreaAnimation(), Factory.registerSeries(AreaSeries.type, AreaSeries);
};
//# sourceMappingURL=area.js.map
