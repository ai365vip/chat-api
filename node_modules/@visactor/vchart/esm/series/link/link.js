import { AttributeLevel, DEFAULT_DATA_SERIES_FIELD } from "../../constant/index";

import { CartesianSeries } from "../cartesian/cartesian";

import { isValid } from "@visactor/vutils";

import { SeriesTypeEnum } from "../interface/type";

import { registerDataSetInstanceTransform } from "../../data/register";

import { ShapeTypeEnum } from "../../typings/shape";

import { LinkSeriesTooltipHelper } from "./tooltip-helper";

import { registerRuleMark } from "../../mark/rule";

import { registerSymbolMark } from "../../mark/symbol";

import { linkSeriesMark } from "./constant";

import { linkDotInfo } from "../../data/transforms/link-dot-info";

import { Factory } from "../../core/factory";

import { TransformLevel } from "../../data/initialize";

export class LinkSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.link;
    }
    getFromField() {
        return this._fromField;
    }
    setFromField(field) {
        isValid(field) && (this._fromField = field);
    }
    getToField() {
        return this._toField;
    }
    setToField(field) {
        isValid(field) && (this._toField = field);
    }
    getDotTypeField() {
        return this._dotTypeField;
    }
    setDotTypeField(field) {
        isValid(field) && (this._dotTypeField = field);
    }
    getDotSeriesSpec() {
        return this._dotSeriesSpec;
    }
    setDotSeriesSpec(spec) {
        isValid(spec) && (this._dotSeriesSpec = spec);
    }
    _getDotData() {
        const dotSeries = this._option.getChart().getSeriesInIndex([ this._spec.dotSeriesIndex ])[0];
        return dotSeries ? dotSeries.getRawData().latestData : [];
    }
    initData() {
        var _a;
        super.initData(), registerDataSetInstanceTransform(this._option.dataSet, "linkDotInfo", linkDotInfo), 
        null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
            type: "linkDotInfo",
            options: {
                infoKey: "dots",
                fields: () => ({
                    fromField: this._fromField,
                    toField: this._toField,
                    xField: this._dotSeriesSpec.xField,
                    yField: this._dotSeriesSpec.yField
                }),
                linkData: () => this._rawData.latestData,
                dotData: () => this._getDotData()
            },
            level: TransformLevel.linkDotInfo
        }, !1);
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this.setFromField(this._spec.fromField), this.setToField(this._spec.toField), 
        this.setDotTypeField(this._spec.dotTypeField), this.setDotSeriesSpec(this._spec.dotSeriesSpec);
    }
    initMark() {
        this._clipMark = this._createMark(LinkSeries.mark.group), this._containerMark = this._createMark(LinkSeries.mark.group, {
            parent: this._clipMark
        }), this._linkMark = this._createMark(LinkSeries.mark.link, {
            skipBeforeLayouted: !1,
            parent: this._containerMark
        }), this._arrowMark = this._createMark(LinkSeries.mark.arrow, {
            skipBeforeLayouted: !1,
            isSeriesMark: !0,
            parent: this._containerMark
        });
    }
    initMarkStyle() {
        var _a, _b, _c, _d;
        const clipMark = this._clipMark;
        clipMark && (this.setMarkStyle(clipMark, {
            x: -this._spec.leftAppendPadding,
            y: 0,
            width: 1e4,
            height: this._spec.clipHeight,
            clip: !0
        }, "normal", AttributeLevel.Series), clipMark.setInteractive(!1));
        const containerMark = this._containerMark;
        containerMark && (this.setMarkStyle(containerMark, {
            x: this._spec.leftAppendPadding,
            width: this.getLayoutRect().width
        }, "normal", AttributeLevel.Series), containerMark.setInteractive(!1));
        const linkMark = this._linkMark;
        linkMark && (this.setMarkStyle(linkMark, {
            stroke: this.getColorAttribute(),
            strokeOpacity: this.dataToOpacity.bind(this),
            x: this.dataToPositionXFrom.bind(this),
            y: this.dataToPositionYFrom.bind(this),
            x1: this.dataToPositionXTo.bind(this),
            y1: this.dataToPositionYTo.bind(this)
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(linkMark));
        const arrowMark = this._arrowMark;
        if (arrowMark) {
            const arrowSize = null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.arrow) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
            this.setMarkStyle(arrowMark, {
                x: this.dataToPositionXTo.bind(this),
                y: datum => this.dataToPositionArrowYTo(datum, arrowSize),
                fill: this.getColorAttribute(),
                fillOpacity: this.dataToOpacity.bind(this),
                size: arrowSize,
                symbolType: datum => this.isPositionYFromHigher(datum) ? ShapeTypeEnum.triangleDown : ShapeTypeEnum.triangleUp
            }, "normal", AttributeLevel.Series), this._trigger.registerMark(arrowMark);
        }
    }
    afterInitMark() {
        super.afterInitMark(), this._trigger.setStateKeys([ this._seriesField, this._fromField ]);
    }
    dataToPositionXFrom(datum) {
        if (!this._xAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition} = this._xAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_xField"), {
            bandPosition: this._bandPosition
        });
    }
    dataToPositionYFrom(datum) {
        if (!this._yAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition} = this._yAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_yField"));
    }
    dataToPositionXTo(datum) {
        if (!this._xAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition} = this._xAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_xField"), {
            bandPosition: this._bandPosition
        });
    }
    dataToPositionYTo(datum) {
        if (!this._yAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition} = this._yAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
            bandPosition: this._bandPosition
        });
    }
    dataToPositionArrowYTo(datum, arrowSize) {
        if (!this._yAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition} = this._yAxisHelper, offset = this.isPositionYFromHigher(datum) ? -arrowSize / 2 : arrowSize / 2;
        return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
            bandPosition: this._bandPosition
        }) + offset;
    }
    dataToOpacity(datum) {
        return this.isPositionXOuterRange(datum, this._fromField + "_xField") || this.isPositionXOuterRange(datum, this._toField + "_xField") || datum[this._fromField] === datum[this._toField] ? 0 : 1;
    }
    isPositionYFromHigher(datum) {
        return this.dataToPositionYFrom(datum) < this.dataToPositionYTo(datum);
    }
    isPositionXOuterRange(datum, field) {
        if (!this._xAxisHelper) return !1;
        const {dataToPosition: dataToPosition, getScale: getScale} = this._xAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, field), {
            bandPosition: this._bandPosition
        }) < getScale(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, field), {
            bandPosition: this._bandPosition
        }) > getScale(0).range()[1];
    }
    getDefaultColorDomain() {
        var _a, _b;
        return this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
    }
    getColorAttribute() {
        var _a, _b, _c;
        return {
            scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
            field: null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD
        };
    }
    initTooltip() {
        this._tooltipHelper = new LinkSeriesTooltipHelper(this), this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark), 
        this._arrowMark && this._tooltipHelper.activeTriggerSet.mark.add(this._arrowMark);
    }
    onMarkTreePositionUpdate(marks) {
        marks.forEach((m => {
            "group" === m.type ? this.onMarkTreePositionUpdate(m.getMarks()) : m.updateLayoutState();
        }));
    }
    getDotInfoData() {
        var _a, _b;
        return null === (_b = null !== (_a = this._linkMark) && void 0 !== _a ? _a : this._arrowMark) || void 0 === _b ? void 0 : _b.getData();
    }
    getActiveMarks() {
        return [ this._linkMark, this._arrowMark ];
    }
}

LinkSeries.type = SeriesTypeEnum.link, LinkSeries.mark = linkSeriesMark;

export const registerLinkSeries = () => {
    registerRuleMark(), registerSymbolMark(), Factory.registerSeries(LinkSeries.type, LinkSeries);
};
//# sourceMappingURL=link.js.map
