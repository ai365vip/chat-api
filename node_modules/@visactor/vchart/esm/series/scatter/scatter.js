import { PREFIX } from "../../constant/base";

import { CartesianSeries } from "../cartesian/cartesian";

import { isNil, isValid, isObject, isFunction, isString, isArray, isNumber, isNumeric } from "@visactor/vutils";

import { AttributeLevel } from "../../constant";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { SCATTER_DEFAULT_RANGE_SHAPE, SCATTER_DEFAULT_RANGE_SIZE, SCATTER_DEFAULT_SHAPE, SCATTER_DEFAULT_SHAPE_SCALE_TYPE, SCATTER_DEFAULT_SIZE, SCATTER_DEFAULT_SIZE_SCALE_TYPE } from "../../constant/scatter";

import { animationConfig, shouldMarkDoMorph, userAnimationConfig } from "../../animation/utils";

import { registerScatterAnimation } from "./animation";

import { registerSymbolMark } from "../../mark/symbol";

import { scatterSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { ScatterSeriesSpecTransformer } from "./scatter-transformer";

import { getGroupAnimationParams } from "../util/utils";

export class ScatterSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.scatter, this.transformerConstructor = ScatterSeriesSpecTransformer, 
        this._invalidType = "zero";
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._size = this._spec.size, this._sizeField = this._spec.sizeField, 
        this._shape = this._spec.shape, this._shapeField = this._spec.shapeField;
    }
    _getSeriesAttribute(field, spec, {defaultScaleType: defaultScaleType, defaultRange: defaultRange}, key) {
        var _a, _b, _c, _d;
        if (isFunction(spec)) return spec;
        if (isArray(spec)) {
            if (isNil(field)) return null === (_a = this._option) || void 0 === _a || _a.onError(`${key}Field is required.`), 
            spec;
            if ("ordinal" !== defaultScaleType && spec.length > 2) return null === (_b = this._option) || void 0 === _b || _b.onError(`${key} length is invalid, specify up to 2 ${key}s.`), 
            spec;
            const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`;
            return this._option.globalScale.registerModelScale({
                id: scaleName,
                type: defaultScaleType,
                domain: [ {
                    dataId: this._rawData.name,
                    fields: [ field ]
                } ],
                range: spec
            }), {
                scale: scaleName,
                field: field
            };
        }
        if (isObject(spec)) {
            if (isNil(field)) return null === (_c = this._option) || void 0 === _c || _c.onError(`${key}Field is required.`), 
            spec;
            const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`, visualSpec = Object.assign({
                id: scaleName,
                type: defaultScaleType,
                domain: [ {
                    dataId: this._rawData.name,
                    fields: [ field ]
                } ],
                range: defaultRange
            }, spec);
            return this._option.globalScale.registerModelScale(visualSpec), {
                scale: visualSpec.id,
                field: field
            };
        }
        return null === (_d = this._option) || void 0 === _d || _d.onError(`${key} attribute is invalid.`), 
        spec;
    }
    getSizeAttribute(field, sizeSpec) {
        return isNil(sizeSpec) ? SCATTER_DEFAULT_SIZE : isNumber(sizeSpec) ? sizeSpec : isString(sizeSpec) && isNumeric(sizeSpec) ? parseFloat(sizeSpec) : this._getSeriesAttribute(field, sizeSpec, {
            defaultScaleType: SCATTER_DEFAULT_SIZE_SCALE_TYPE,
            defaultRange: SCATTER_DEFAULT_RANGE_SIZE
        }, "size");
    }
    getShapeAttribute(field, shapeSpec) {
        return isNil(shapeSpec) ? SCATTER_DEFAULT_SHAPE : isString(shapeSpec) ? shapeSpec : this._getSeriesAttribute(field, shapeSpec, {
            defaultScaleType: SCATTER_DEFAULT_SHAPE_SCALE_TYPE,
            defaultRange: SCATTER_DEFAULT_RANGE_SHAPE
        }, "shape");
    }
    initMark() {
        var _a;
        const progressive = {
            progressiveStep: this._spec.progressiveStep,
            progressiveThreshold: this._spec.progressiveThreshold,
            large: this._spec.large,
            largeThreshold: this._spec.largeThreshold
        };
        this._symbolMark = this._createMark(ScatterSeries.mark.point, {
            morph: shouldMarkDoMorph(this._spec, ScatterSeries.mark.point.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            progressive: progressive,
            isSeriesMark: !0,
            customShape: null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.customShape
        });
    }
    initMarkStyle() {
        this.initSymbolMarkStyle();
    }
    initAnimation() {
        var _a, _b, _c;
        const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._symbolMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("scatter")) || void 0 === _c ? void 0 : _c({}, appearPreset), userAnimationConfig(SeriesMarkNameEnum.point, this._spec, this._markAttributeContext), animationParams));
    }
    initSymbolMarkStyle() {
        const symbolMark = this._symbolMark;
        symbolMark && ("zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
            visible: this._getInvalidDefined
        }), this.setMarkStyle(symbolMark, {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
            fill: this.getColorAttribute(),
            size: isNumber(this._size) || isFunction(this._size) ? this._size : SCATTER_DEFAULT_SIZE,
            symbolType: isString(this._shape) || isFunction(this._shape) ? this._shape : SCATTER_DEFAULT_SHAPE
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), (isValid(this._sizeField) || isValid(this._size)) && this.setMarkStyle(symbolMark, {
            size: this.getSizeAttribute(this._sizeField, this._size)
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark), (isValid(this._shapeField) || isValid(this._shape)) && this.setMarkStyle(symbolMark, {
            symbolType: this.getShapeAttribute(this._shapeField, this._shape)
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark), this._trigger.registerMark(symbolMark));
    }
    initTooltip() {
        super.initTooltip(), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
    }
    viewDataStatisticsUpdate(d) {
        super.viewDataStatisticsUpdate(d);
        const allValid = [ this.getDimensionField()[0], this.getStackValueField() ].every((field => {
            var _a, _b, _c;
            return field && (null === (_c = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[field]) || void 0 === _c ? void 0 : _c.allValid);
        }));
        "zero" === this._invalidType || allValid ? this.setMarkStyle(this._symbolMark, {
            visible: !0
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._symbolMark, {
            visible: this._getInvalidDefined
        }, "normal", AttributeLevel.Series);
    }
    initLabelMarkStyle(labelMark) {
        labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getStackValueField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
            visible: this._getInvalidDefined
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
    }
    handleZoom(e) {
        var _a, _b;
        this.getMarksWithoutRoot().forEach((mark => {
            const vGrammarMark = mark.getProduct();
            if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
            vGrammarMark.elements.forEach(((el, i) => {
                const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
                newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
            }));
        }));
        const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
        vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
    }
    handlePan(e) {
        var _a, _b;
        this.getMarksWithoutRoot().forEach((mark => {
            const vGrammarMark = mark.getProduct();
            if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length) return;
            vGrammarMark.elements.forEach(((el, i) => {
                const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
                newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
            }));
        }));
        const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
        vgrammarLabel && vgrammarLabel.evaluateSync(null, null);
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [ this._symbolMark ];
    }
}

ScatterSeries.type = SeriesTypeEnum.scatter, ScatterSeries.mark = scatterSeriesMark, 
ScatterSeries.transformerConstructor = ScatterSeriesSpecTransformer;

export const registerScatterSeries = () => {
    registerSymbolMark(), registerScatterAnimation(), Factory.registerSeries(ScatterSeries.type, ScatterSeries);
};
//# sourceMappingURL=scatter.js.map
