import { BarSeries } from "../bar/bar";

import { MarkTypeEnum } from "../../mark/interface/type";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { Direction } from "../../typings/space";

import { registerRectMark } from "../../mark/rect";

import { registerTextMark } from "../../mark/text";

import { setRectLabelPos } from "../util/label-mark";

import { animationConfig, shouldMarkDoMorph, userAnimationConfig } from "../../animation/utils";

import { RangeColumnSeriesTooltipHelper } from "./tooltip-helper";

import { registerFadeInOutAnimation } from "../../animation/config";

import { PositionEnum } from "./interface";

import { registerRangeColumnAnimation } from "./animation";

import { rangeColumnSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { getGroupAnimationParams } from "../util/utils";

import { RangeColumnSeriesSpecTransformer } from "./range-column-transformer";

export const DefaultBandWidth = 6;

export class RangeColumnSeries extends BarSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.rangeColumn, this._barMarkType = MarkTypeEnum.rect, 
        this._barName = SeriesTypeEnum.bar, this.transformerConstructor = RangeColumnSeriesSpecTransformer, 
        this._stack = !1;
    }
    initMark() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this._initBarBackgroundMark();
        const labelPosition = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.position;
        this._barMark = this._createMark(RangeColumnSeries.mark.bar, {
            morph: shouldMarkDoMorph(this._spec, RangeColumnSeries.mark.bar.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            isSeriesMark: !0,
            customShape: null === (_b = this._spec.bar) || void 0 === _b ? void 0 : _b.customShape
        }), !1 !== (null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.visible) && labelPosition === PositionEnum.bothEnd && (!1 !== (null === (_e = null === (_d = this._spec.label) || void 0 === _d ? void 0 : _d.minLabel) || void 0 === _e ? void 0 : _e.visible) && (this._minLabelMark = this._createMark(RangeColumnSeries.mark.minLabel, {
            markSpec: null === (_f = this._spec.label) || void 0 === _f ? void 0 : _f.minLabel
        })), !1 !== (null === (_h = null === (_g = this._spec.label) || void 0 === _g ? void 0 : _g.maxLabel) || void 0 === _h ? void 0 : _h.visible) && (this._maxLabelMark = this._createMark(RangeColumnSeries.mark.maxLabel, {
            markSpec: null === (_j = this._spec.label) || void 0 === _j ? void 0 : _j.maxLabel
        })));
    }
    initMarkStyle() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super.initMarkStyle();
        const minLabelMark = this._minLabelMark, minLabelSpec = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.minLabel;
        if (minLabelMark) {
            this.setMarkStyle(minLabelMark, {
                fill: null !== (_c = null === (_b = null == minLabelSpec ? void 0 : minLabelSpec.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
                text: datum => {
                    const min = this._spec.direction === Direction.horizontal ? datum[this._spec.xField[0]] : datum[this._spec.yField[0]];
                    return (null == minLabelSpec ? void 0 : minLabelSpec.formatMethod) ? minLabelSpec.formatMethod(min, datum) : min;
                }
            });
            const position = null !== (_d = null == minLabelSpec ? void 0 : minLabelSpec.position) && void 0 !== _d ? _d : "end", offset = null !== (_e = null == minLabelSpec ? void 0 : minLabelSpec.offset) && void 0 !== _e ? _e : "vertical" === this._direction ? -20 : -25;
            setRectLabelPos(this, minLabelMark, position, offset, (datum => this._barMark.getAttribute("x", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum)), (datum => this._barMark.getAttribute("y", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum)), (() => this._direction));
        }
        const maxLabelMark = this._maxLabelMark, maxLabelSpec = null === (_f = this._spec.label) || void 0 === _f ? void 0 : _f.maxLabel;
        if (maxLabelMark) {
            this.setMarkStyle(maxLabelMark, {
                fill: null !== (_h = null === (_g = null == maxLabelSpec ? void 0 : maxLabelSpec.style) || void 0 === _g ? void 0 : _g.fill) && void 0 !== _h ? _h : this.getColorAttribute(),
                text: datum => {
                    const max = this._spec.direction === Direction.horizontal ? datum[this._spec.xField[1]] : datum[this._spec.yField[1]];
                    return (null == maxLabelSpec ? void 0 : maxLabelSpec.formatMethod) ? maxLabelSpec.formatMethod(max, datum) : max;
                }
            });
            const position = null !== (_j = null == maxLabelSpec ? void 0 : maxLabelSpec.position) && void 0 !== _j ? _j : "start", offset = null !== (_k = null == maxLabelSpec ? void 0 : maxLabelSpec.offset) && void 0 !== _k ? _k : "vertical" === this._direction ? -20 : -25;
            setRectLabelPos(this, maxLabelMark, position, offset, (datum => this._barMark.getAttribute("x", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum)), (datum => this._barMark.getAttribute("y", datum)), (datum => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum)), (() => this._direction));
        }
    }
    initLabelMarkStyle(labelMark) {
        labelMark && (this.setMarkStyle(labelMark, {
            text: datum => {
                let min, max;
                return this._spec.direction === Direction.horizontal ? (min = datum[this._spec.xField[0]], 
                max = datum[this._spec.xField[1]]) : (min = datum[this._spec.yField[0]], max = datum[this._spec.yField[1]]), 
                min + "-" + max;
            },
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }), this._labelMark = labelMark);
    }
    _dataToPosX(datum) {
        return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[0]), {
            bandPosition: this._bandPosition
        });
    }
    _dataToPosX1(datum) {
        return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
            bandPosition: this._bandPosition
        });
    }
    _dataToPosY(datum) {
        return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[0]), {
            bandPosition: this._bandPosition
        });
    }
    _dataToPosY1(datum) {
        return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
            bandPosition: this._bandPosition
        });
    }
    initAnimation() {
        var _a, _b, _c, _d, _e;
        const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._barMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("rangeColumn")) || void 0 === _c ? void 0 : _c({
            direction: this.direction
        }, appearPreset), userAnimationConfig(SeriesMarkNameEnum.bar, this._spec, this._markAttributeContext), animationParams)), 
        this._minLabelMark && this._minLabelMark.setAnimationConfig(animationConfig(null === (_d = Factory.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig(SeriesMarkNameEnum.label, this._spec, this._markAttributeContext), animationParams)), 
        this._maxLabelMark && this._maxLabelMark.setAnimationConfig(animationConfig(null === (_e = Factory.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig(SeriesMarkNameEnum.label, this._spec, this._markAttributeContext), animationParams));
    }
    initTooltip() {
        this._tooltipHelper = new RangeColumnSeriesTooltipHelper(this), this._barMark && this._tooltipHelper.activeTriggerSet.mark.add(this._barMark), 
        this._minLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._minLabelMark), 
        this._maxLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._maxLabelMark), 
        this._labelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._labelMark);
    }
}

RangeColumnSeries.type = SeriesTypeEnum.rangeColumn, RangeColumnSeries.mark = rangeColumnSeriesMark, 
RangeColumnSeries.transformerConstructor = RangeColumnSeriesSpecTransformer;

export const registerRangeColumnSeries = () => {
    registerRectMark(), registerTextMark(), registerRangeColumnAnimation(), registerFadeInOutAnimation(), 
    Factory.registerSeries(RangeColumnSeries.type, RangeColumnSeries);
};
//# sourceMappingURL=range-column.js.map
