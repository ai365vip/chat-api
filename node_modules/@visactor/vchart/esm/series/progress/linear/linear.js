import { CartesianSeries } from "../../cartesian/cartesian";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../../interface/type";

import { valueInScaleRange } from "../../../util/scale";

import { AttributeLevel } from "../../../constant";

import { animationConfig, userAnimationConfig } from "../../../animation/utils";

import { registerLinearProgressAnimation } from "./animation";

import { LinearProgressSeriesTooltipHelper } from "./tooltip-helper";

import { registerRectMark } from "../../../mark/rect";

import { createRect } from "@visactor/vrender-core";

import { linearProgressSeriesMark } from "./constant";

import { Factory } from "../../../core/factory";

import { registerFadeInOutAnimation } from "../../../animation/config";

export class LinearProgressSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.linearProgress, this._progressMark = null, 
        this._trackMark = null, this._progressGroupMark = null;
    }
    initMark() {
        this._initProgressGroupMark(), this._initTrackMark(), this._initProgressMark();
    }
    initMarkStyle() {
        this._initProgressGroupMarkStyle(), this._initTrackMarkStyle(), this._initProgressMarkStyle();
    }
    _initProgressMark() {
        var _a;
        return this._progressMark = this._createMark(LinearProgressSeries.mark.progress, {
            isSeriesMark: !0,
            parent: this._progressGroupMark,
            customShape: null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.customShape
        }), this._progressMark;
    }
    _initProgressMarkStyle() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const progressMark = this._progressMark;
        if (progressMark) {
            if ("vertical" === this._spec.direction) {
                const leftPadding = null !== (_b = null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.leftPadding) && void 0 !== _b ? _b : 0, rightPadding = null !== (_d = null === (_c = this._spec.progress) || void 0 === _c ? void 0 : _c.rightPadding) && void 0 !== _d ? _d : 0;
                this.setMarkStyle(progressMark, {
                    x: datum => {
                        var _a, _b;
                        return valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2 + leftPadding;
                    },
                    y: datum => {
                        var _a, _b;
                        return valueInScaleRange(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0));
                    },
                    height: () => {
                        var _a;
                        return null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.dataToPosition([ 0 ], {
                            bandPosition: this._bandPosition
                        });
                    },
                    width: this._spec.bandWidth - leftPadding - rightPadding,
                    cornerRadius: this._spec.cornerRadius,
                    fill: this.getColorAttribute()
                }, "normal", AttributeLevel.Series);
            } else {
                const topPadding = null !== (_f = null === (_e = this._spec.progress) || void 0 === _e ? void 0 : _e.topPadding) && void 0 !== _f ? _f : 0, bottomPadding = null !== (_h = null === (_g = this._spec.progress) || void 0 === _g ? void 0 : _g.bottomPadding) && void 0 !== _h ? _h : 0;
                this.setMarkStyle(progressMark, {
                    x: datum => {
                        var _a, _b;
                        return valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._xAxisHelper.dataToPosition([ 1 ], {
                            bandPosition: this._bandPosition
                        });
                    },
                    y: datum => {
                        var _a, _b;
                        return valueInScaleRange(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2 + topPadding;
                    },
                    height: this._spec.bandWidth - topPadding - bottomPadding,
                    width: () => {
                        var _a;
                        return null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.dataToPosition([ 1 ], {
                            bandPosition: this._bandPosition
                        });
                    },
                    cornerRadius: this._spec.cornerRadius,
                    fill: this.getColorAttribute()
                }, "normal", AttributeLevel.Series);
            }
            this._trigger.registerMark(progressMark);
        }
    }
    _initTrackMark() {
        var _a;
        return this._trackMark = this._createMark(LinearProgressSeries.mark.track, {
            parent: this._progressGroupMark,
            customShape: null === (_a = this._spec.track) || void 0 === _a ? void 0 : _a.customShape
        }), this._trackMark;
    }
    _initTrackMarkStyle() {
        const trackMark = this._trackMark;
        trackMark && ("vertical" === this._spec.direction ? this.setMarkStyle(trackMark, {
            x: datum => {
                var _a, _b;
                return valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2;
            },
            y: 0,
            width: this._spec.bandWidth,
            height: () => this._scaleY.range()[0],
            cornerRadius: this._spec.cornerRadius
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(trackMark, {
            x: 0,
            y: datum => {
                var _a, _b;
                return valueInScaleRange(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2;
            },
            height: this._spec.bandWidth,
            width: () => this._scaleX.range()[1],
            cornerRadius: this._spec.cornerRadius
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(trackMark));
    }
    _initProgressGroupMark() {
        return this._progressGroupMark = this._createMark(LinearProgressSeries.mark.group, {
            skipBeforeLayouted: !1
        }), this._progressGroupMark;
    }
    _initProgressGroupMarkStyle() {
        const groupMark = this._progressGroupMark;
        groupMark.setZIndex(this.layoutZIndex), groupMark.created(), this.setMarkStyle(groupMark, {
            clip: !0,
            x: 0,
            y: 0,
            path: () => {
                var _a;
                const rectPaths = [];
                return null === (_a = this._rawData) || void 0 === _a || _a.rawData.forEach(((datum, index) => {
                    var _a, _b, _c, _d;
                    if ("vertical" === this._spec.direction) {
                        const x = valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2, height = this._scaleY.range()[0];
                        rectPaths.push(createRect({
                            x: x,
                            y: 0,
                            height: height,
                            width: this._spec.bandWidth,
                            cornerRadius: this._spec.cornerRadius,
                            fill: !0
                        }));
                    } else {
                        const y = valueInScaleRange(this.dataToPositionY(datum), null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0)) - this._spec.bandWidth / 2, width = this._scaleX.range()[1];
                        rectPaths.push(createRect({
                            x: 0,
                            y: y,
                            height: this._spec.bandWidth,
                            width: width,
                            cornerRadius: this._spec.cornerRadius,
                            fill: !0
                        }));
                    }
                })), rectPaths;
            }
        }, "normal", AttributeLevel.Series), this._progressGroupMark.setInteractive(!1);
    }
    initAnimation() {
        var _a, _b, _c, _d;
        const animationParams = {
            direction: this.direction
        }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._progressMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("linearProgress")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig(SeriesMarkNameEnum.progress, this._spec, this._markAttributeContext))), 
        this._trackMark.setAnimationConfig(animationConfig(null === (_d = Factory.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig(SeriesMarkNameEnum.track, this._spec, this._markAttributeContext)));
    }
    initTooltip() {
        this._tooltipHelper = new LinearProgressSeriesTooltipHelper(this), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark), 
        this._trackMark && this._tooltipHelper.activeTriggerSet.mark.add(this._trackMark);
    }
    getActiveMarks() {
        return [ this._progressMark ];
    }
}

LinearProgressSeries.type = SeriesTypeEnum.linearProgress, LinearProgressSeries.mark = linearProgressSeriesMark;

export const registerLinearProgressSeries = () => {
    registerRectMark(), registerLinearProgressAnimation(), registerFadeInOutAnimation(), 
    Factory.registerSeries(LinearProgressSeries.type, LinearProgressSeries);
};
//# sourceMappingURL=linear.js.map
