import { PREFIX } from "../../constant/base";

import { DataView } from "@visactor/vdataset";

import { ChartEvent } from "../../constant/event";

import { AttributeLevel } from "../../constant";

import { MarkTypeEnum } from "../../mark/interface/type";

import { DEFAULT_LINEAR_INTERPOLATE, DEFAULT_SMOOTH_INTERPOLATE } from "../../typings/interpolate";

import { Direction } from "../../typings/space";

import { DEFAULT_CLOSE_STROKE_JOIN } from "../../typings/line-stroke";

import { shouldMarkDoMorph } from "../../animation/utils";

import { DimensionEventEnum } from "../../event/events/dimension";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { lineLikeSeriesMark } from "./constant";

import { mergeSpec } from "../../util/spec";

export class LineLikeSeriesMixin {
    addSamplingCompile() {
        if (this._spec.sampling) {
            const {width: width, height: height} = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
            samplingTrans.push({
                type: "sampling",
                size: this._direction === Direction.vertical ? width : height,
                factor: this._spec.samplingFactor,
                yfield: this._direction === Direction.vertical ? fieldsY[0] : fieldsX[0],
                groupBy: this._seriesField,
                mode: this._spec.sampling
            }), this._data.getProduct().transform(samplingTrans);
        }
    }
    addOverlapCompile() {
        var _a;
        if (this._spec.markOverlap) {
            const overlapTrans = [];
            overlapTrans.push({
                type: "markoverlap",
                direction: this._direction === Direction.horizontal && "cartesian" === this.coordinate ? 2 : 1,
                delta: this._spec.pointDis,
                deltaMul: this._spec.pointDisMul,
                groupBy: this._seriesField
            }), null === (_a = this._symbolMark) || void 0 === _a || _a.getProduct().transform(overlapTrans);
        }
    }
    reCompileSampling() {
        this._spec.sampling && this.compile();
    }
    initLineMark(progressive, isSeriesMark) {
        var _a;
        return this._lineMark = this._createMark(lineLikeSeriesMark.line, {
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            isSeriesMark: null == isSeriesMark || isSeriesMark,
            progressive: progressive,
            customShape: null === (_a = this._spec.line) || void 0 === _a ? void 0 : _a.customShape
        }), this._lineMark;
    }
    initLineMarkStyle(direction, areaCurveType) {
        var _a, _b;
        const lineMark = this._lineMark;
        if (lineMark) {
            if (this.setMarkStyle(lineMark, {
                stroke: this.getColorAttribute()
            }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(lineMark, {
                defined: this._getInvalidDefined,
                connectedType: this._getInvalidConnectType()
            }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
                filter: param => param.model === this
            }, (() => {
                this.encodeDefined(lineMark, "defined");
            })), "polar" === this.coordinate) this.setMarkStyle(lineMark, {
                lineJoin: DEFAULT_CLOSE_STROKE_JOIN,
                curveType: DEFAULT_LINEAR_INTERPOLATE,
                closePath: !0
            }, "normal", AttributeLevel.Series); else {
                const userCurveType = null != areaCurveType ? areaCurveType : null === (_b = null === (_a = this.getSpec().line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? direction === Direction.vertical ? "monotoneX" : "monotoneY" : userCurveType;
                this.setMarkStyle(lineMark, {
                    curveType: curveType
                }, "normal", AttributeLevel.Built_In);
            }
            this.setMarkStyle(lineMark, {
                x: this.dataToPositionX.bind(this),
                y: this.dataToPositionY.bind(this),
                z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
            }, "normal", AttributeLevel.Series), this._trigger.registerMark(lineMark);
        }
        return lineMark;
    }
    _getEventElement(params, reverse = !1) {
        let data = [];
        return params.dimensionInfo.some((df => (df.data.some((dd => dd.series === this && (data = dd.datum, 
        !0))), !data.length))), data;
    }
    _dimensionTrigger(params) {
        const elements = this._getEventElement(params);
        switch (params.action) {
          case "enter":
            this._symbolActiveMark.getDataView().parse(elements), this._symbolActiveMark.getData().updateData(!1);
            break;

          case "leave":
            this._symbolActiveMark.getDataView().parse([]), this._symbolActiveMark.getData().updateData(!1);
        }
    }
    initSymbolMark(progressive, isSeriesMark) {
        var _a, _b, _c;
        if (!1 !== (null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.visible) && (this._symbolMark = this._createMark(lineLikeSeriesMark.point, {
            morph: shouldMarkDoMorph(this._spec, lineLikeSeriesMark.point.name),
            defaultMorphElementKey: this.getDimensionField()[0],
            groupKey: this._seriesField,
            progressive: progressive,
            isSeriesMark: !!isSeriesMark,
            customShape: null === (_b = this._spec.point) || void 0 === _b ? void 0 : _b.customShape
        })), !0 === this._spec.activePoint) {
            const activeData = new DataView(this._option.dataSet, {
                name: `${PREFIX}_series_${this.id}_active_point`
            });
            activeData.parse([]), this._symbolActiveMark = this._createMark({
                name: "active_point",
                type: MarkTypeEnum.symbol
            }, {
                morph: !1,
                groupKey: this._seriesField,
                isSeriesMark: !1,
                dataView: activeData,
                parent: this._region.getInteractionMark(),
                customShape: null === (_c = this._spec.point) || void 0 === _c ? void 0 : _c.customShape
            }), this._symbolActiveMark.setVisible(!1);
        }
        return this._symbolMark;
    }
    initSymbolMarkStyle() {
        const symbolMark = this._symbolMark;
        if (!symbolMark) return this._initSymbolActiveMarkAlone(), symbolMark;
        if (this._initSymbolMark(symbolMark), this._trigger.registerMark(symbolMark), this._symbolActiveMark && this._symbolMark.stateStyle.dimension_hover) {
            this._symbolActiveMark.setVisible(!0), this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this));
            for (const state in this._symbolMark.stateStyle) {
                this._symbolActiveMark.stateStyle[state] = {};
                for (const key in this._symbolMark.stateStyle[state]) this._symbolActiveMark.stateStyle[state][key] = {
                    style: null,
                    level: AttributeLevel.Series,
                    referer: symbolMark
                };
            }
            this._symbolActiveMark.state.changeStateInfo({
                stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
                filter: () => !0
            });
        }
        return symbolMark;
    }
    _initSymbolMark(symbolMark) {
        symbolMark && (this.setMarkStyle(symbolMark, {
            fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
            visible: this._getInvalidDefined
        }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
            filter: param => param.model === this
        }, (() => {
            this.encodeDefined(symbolMark, "visible");
        })), this.setMarkStyle(symbolMark, {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }, "normal", AttributeLevel.Series));
    }
    _initSymbolActiveMarkAlone() {
        var _a, _b;
        const symbolMark = this._symbolActiveMark;
        symbolMark && (this._initSymbolMark(symbolMark), symbolMark && (null === (_b = null === (_a = this._spec[lineLikeSeriesMark.point.name]) || void 0 === _a ? void 0 : _a.state) || void 0 === _b ? void 0 : _b.dimension_hover) && (symbolMark.setVisible(!0), 
        this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this)), 
        this.initMarkStyleWithSpec(symbolMark, mergeSpec({}, this._spec[lineLikeSeriesMark.point.name], {
            visible: !0
        })), this._symbolActiveMark.state.changeStateInfo({
            stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
            filter: () => !0
        })));
    }
    initLabelMarkStyle(labelMark) {
        var _a;
        labelMark && ("symbol" !== (null === (_a = labelMark.getTarget()) || void 0 === _a ? void 0 : _a.type) && labelMark.setRule("line-data"), 
        this.setMarkStyle(labelMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getStackValueField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
            visible: this._getInvalidDefined
        }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
            filter: param => param.model === this
        }, (() => {
            this.encodeDefined(labelMark, "visible");
        })));
    }
    initLineLabelMarkStyle(labelMark) {
        labelMark && this.setMarkStyle(labelMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getSeriesField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        });
    }
    encodeDefined(mark, attr) {
        var _a, _b, _c, _d, _e, _f;
        if (!mark) return;
        const statistics = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[this.getStackValueField()];
        if ("zero" === this._invalidType || statistics && (null == statistics ? void 0 : statistics.allValid)) {
            if (!0 === (null === (_d = null === (_c = mark.stateStyle.normal) || void 0 === _c ? void 0 : _c[attr]) || void 0 === _d ? void 0 : _d.style)) return;
            this.setMarkStyle(mark, {
                [attr]: !0
            }, "normal", AttributeLevel.Series);
        } else {
            if (!0 !== (null === (_f = null === (_e = mark.stateStyle.normal) || void 0 === _e ? void 0 : _e[attr]) || void 0 === _f ? void 0 : _f.style)) return;
            this.setMarkStyle(mark, {
                [attr]: this._getInvalidDefined
            }, "normal", AttributeLevel.Series);
        }
        mark.getProduct() && mark.compileEncode();
    }
}
//# sourceMappingURL=line-mixin.js.map
