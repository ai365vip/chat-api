import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { ProgressLikeSeries } from "../polar/progress-like/progress-like";

import { registerDataSetInstanceTransform } from "../../data/register";

import { SEGMENT_FIELD_END, SEGMENT_FIELD_START } from "../../constant";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { registerProgressArcMark } from "../../mark/progress-arc";

import { gaugeSeriesMark } from "./constant";

import { degreeToRadian, isValid } from "@visactor/vutils";

import { Factory } from "../../core/factory";

import { registerProgressLikeAnimation } from "../polar/progress-like";

import { GaugeSeriesSpecTransformer } from "./gauge-transformer";

export class GaugeSeries extends ProgressLikeSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.gauge, this.transformerConstructor = GaugeSeriesSpecTransformer, 
        this._segmentMark = null, this._trackMark = null, this._stack = !1, this._padAngle = 0;
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this._padAngle = degreeToRadian(null !== (_a = this._spec.padAngle) && void 0 !== _a ? _a : 0);
    }
    initData() {
        var _a;
        super.initData();
        registerDataSetInstanceTransform(this._option.dataSet, "spiltSegment", ((data, op) => {
            const dataCollect = data.slice();
            return dataCollect.sort(((a, b) => a[this._angleField[0]] - b[this._angleField[0]])), 
            dataCollect.forEach(((datum, i) => {
                datum[SEGMENT_FIELD_END] = datum[this._angleField[0]], datum[SEGMENT_FIELD_START] = i > 0 ? dataCollect[i - 1][SEGMENT_FIELD_END] : void 0;
            })), dataCollect;
        })), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
            type: "spiltSegment"
        }, !1);
    }
    initMark() {
        super.initMark(), this._trackMark = this._createMark(GaugeSeries.mark.track, {
            parent: this._arcGroupMark,
            dataView: !1
        }), this._segmentMark = this._createMark(GaugeSeries.mark.segment, {
            parent: this._arcGroupMark,
            isSeriesMark: !0
        });
    }
    initMarkStyle() {
        super.initMarkStyle(), this.initTrackMarkStyle(), this.initSegmentMarkStyle();
    }
    initSegmentMarkStyle() {
        var _a;
        const segmentMark = this._segmentMark;
        segmentMark && (this.setMarkStyle(segmentMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._getAngleValueStart.bind(this),
            endAngle: this._getAngleValueEnd.bind(this),
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute(),
            zIndex: 200,
            forceShowCap: !0
        }), this._trigger.registerMark(segmentMark));
    }
    initTooltip() {
        super.initTooltip(), this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);
    }
    initTrackMarkStyle() {
        var _a;
        const trackMark = this._trackMark;
        trackMark && (this.setMarkStyle(trackMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._startAngle,
            endAngle: this._endAngle,
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            zIndex: 100
        }), this._trigger.registerMark(trackMark));
    }
    _getAngleValueStartWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
        return Math.min(startAngle + this._padAngle / 2, (startAngle + endAngle) / 2);
    }
    _getAngleValueEndWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
        return Math.max(endAngle - this._padAngle / 2, (startAngle + endAngle) / 2);
    }
    _getAngleValueStartWithoutPadAngle(datum) {
        return isValid(datum[SEGMENT_FIELD_START]) ? this.angleAxisHelper.dataToPosition([ datum[SEGMENT_FIELD_START] ]) : this._startAngle;
    }
    _getAngleValueEndWithoutPadAngle(datum) {
        return this.angleAxisHelper.dataToPosition([ datum[SEGMENT_FIELD_END] ]);
    }
    initAnimation() {
        var _a, _b, _c;
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._segmentMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
            startAngle: this._startAngle
        }, appearPreset), userAnimationConfig(SeriesMarkNameEnum.segment, this._spec, this._markAttributeContext)));
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [];
    }
}

GaugeSeries.type = SeriesTypeEnum.gauge, GaugeSeries.mark = gaugeSeriesMark, GaugeSeries.transformerConstructor = GaugeSeriesSpecTransformer;

export const registerGaugeSeries = () => {
    registerProgressArcMark(), registerProgressLikeAnimation(), Factory.registerSeries(GaugeSeries.type, GaugeSeries);
};
//# sourceMappingURL=gauge.js.map
