import { AttributeLevel, DEFAULT_DATA_SERIES_FIELD } from "../../constant/index";

import { CartesianSeries } from "../cartesian/cartesian";

import { mergeSpec } from "../../util/spec/merge-spec";

import { isValid } from "@visactor/vutils";

import { MarkTypeEnum } from "../../mark/interface/type";

import { SeriesTypeEnum } from "../interface/type";

import { dataViewParser } from "@visactor/vdataset";

import { registerDataSetInstanceParser, registerDataSetInstanceTransform } from "../../data/register";

import { DotSeriesTooltipHelper } from "./tooltip-helper";

import { copyDataView } from "../../data/transforms/copy-data-view";

import { objFlat } from "../../data/transforms/obj-flat";

import { DEFAULT_GRID_BACKGROUND } from "./config";

import { ColorOrdinalScale } from "../../scale/color-ordinal-scale";

import { registerSymbolMark } from "../../mark/symbol";

import { registerTextMark } from "../../mark/text";

import { registerRuleMark } from "../../mark/rule";

import { registerRectMark } from "../../mark/rect";

import { dotSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { TransformLevel } from "../../data/initialize";

export class DotSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.dot;
    }
    getSeriesGroupField() {
        return this._seriesField;
    }
    setSeriesGroupField(field) {
        isValid(field) && (this._seriesGroupField = field);
    }
    getTitleField() {
        return this._titleField;
    }
    setTitleField(field) {
        isValid(field) && (this._titleField = field);
    }
    getSubTitleField() {
        return this._subTitleField;
    }
    setSubTitleField(field) {
        isValid(field) && (this._subTitleField = field);
    }
    getDotTypeField() {
        return this._dotTypeField;
    }
    setDotTypeField(field) {
        isValid(field) && (this._dotTypeField = field);
    }
    getHighLightSeriesGroup() {
        return this._highLightSeriesGroup;
    }
    setHighLightSeriesGroup(field) {
        isValid(field) && (this._highLightSeriesGroup = field);
    }
    setGridBackground(gridBackground) {
        isValid(gridBackground) && (this._gridBackground = gridBackground);
    }
    initData() {
        var _a;
        super.initData(), this._xDimensionStatisticsDomain = this.getRawData().latestData.map((d => d[this._fieldY[0]])), 
        registerDataSetInstanceTransform(this._option.dataSet, "objFlat", objFlat), registerDataSetInstanceTransform(this._option.dataSet, "copyDataView", copyDataView), 
        registerDataSetInstanceParser(this._option.dataSet, "dataview", dataViewParser), 
        null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
            type: "objFlat",
            options: "dots",
            level: TransformLevel.dotObjFlat
        }, !1);
    }
    setSeriesField(field) {
        isValid(field) && (this._seriesField = field, this.getMarksInType([ MarkTypeEnum.line, MarkTypeEnum.area ]).forEach((m => {
            m.setFacet(this._seriesField);
        })));
    }
    getStatisticFields() {
        return [ {
            key: this._fieldY[0],
            operations: [ "values" ],
            customize: this._xDimensionStatisticsDomain
        } ];
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this.setSeriesGroupField(this._spec.seriesGroupField), 
        this.setTitleField(this._spec.titleField), this.setSubTitleField(this._spec.subTitleField), 
        this.setDotTypeField(this._spec.dotTypeField), this.setHighLightSeriesGroup(this._spec.highLightSeriesGroup), 
        this.setGridBackground(mergeSpec(DEFAULT_GRID_BACKGROUND, (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.background) || {}));
    }
    initMark() {
        this._clipMark = this._createMark(DotSeries.mark.group), this._containerMark = this._createMark(DotSeries.mark.group, {
            parent: this._clipMark,
            dataView: this.getRawData()
        }), this._gridBackgroundMark = this._createMark(DotSeries.mark.gridBackground, {
            parent: this._containerMark,
            dataView: this.getRawData()
        }), this._gridMark = this._createMark(DotSeries.mark.grid, {
            parent: this._containerMark,
            dataView: this.getRawData()
        }), this._dotMark = this._createMark(DotSeries.mark.dot, {
            skipBeforeLayouted: !1,
            isSeriesMark: !0,
            parent: this._containerMark
        }), this._titleMark = this._createMark(DotSeries.mark.title, {
            parent: this._containerMark,
            dataView: this.getRawData()
        }), this._subTitleMark = this._createMark(DotSeries.mark.subTitle, {
            parent: this._containerMark,
            dataView: this.getRawData()
        }), this._symbolMark = this._createMark(DotSeries.mark.symbol, {
            parent: this._containerMark,
            dataView: this.getRawData()
        });
    }
    initMarkStyle() {
        const clipMark = this._clipMark;
        clipMark && (this.setMarkStyle(clipMark, {
            x: -this._spec.leftAppendPadding,
            y: 0,
            width: 1e4,
            height: this._spec.clipHeight,
            clip: !0
        }, "normal", AttributeLevel.Series), clipMark.setInteractive(!1));
        const containerMark = this._containerMark;
        containerMark && (this.setMarkStyle(containerMark, {
            x: this._spec.leftAppendPadding
        }, "normal", AttributeLevel.Series), containerMark.setInteractive(!1));
        const gridBackgroundMark = this._gridBackgroundMark;
        gridBackgroundMark && (this.setMarkStyle(gridBackgroundMark, {
            x: this.getRegionRectLeft.bind(this),
            x1: this.getRegionRectRight.bind(this),
            y: this.dataToGridBackgroundPositionY.bind(this),
            y1: this.dataToGridBackgroundPositionY1.bind(this),
            fill: this._gridBackground.fill,
            fillOpacity: this.dataToGridBackgroundOpacity.bind(this)
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(gridBackgroundMark));
        const gridMark = this._gridMark;
        gridMark && (this.setMarkStyle(gridMark, {
            stroke: this.getColorAttribute(),
            x: this.getRegionRectLeft.bind(this),
            y: this.dataToPositionY.bind(this),
            x1: this.getRegionRectRight.bind(this),
            y1: this.dataToPositionY.bind(this)
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(gridMark));
        const dotMark = this._dotMark;
        dotMark && (this.setMarkStyle(dotMark, {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            fill: this.getDotColorAttribute(),
            fillOpacity: this.dataToOpacity.bind(this)
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(dotMark));
        const titleMark = this._titleMark;
        titleMark && (this.setMarkStyle(titleMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getTitleField()],
            x: this.getRegionRectLeft.bind(this),
            y: this.dataToPositionY.bind(this)
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(titleMark));
        const subTitleMark = this._subTitleMark;
        subTitleMark && (this.setMarkStyle(subTitleMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getSubTitleField()],
            x: this.getRegionRectLeft.bind(this),
            y: this.dataToPositionY.bind(this)
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(subTitleMark));
        const symbolMark = this._symbolMark;
        symbolMark && (this.setMarkStyle(symbolMark, {
            x: this.getRegionRectLeft.bind(this),
            y: this.dataToPositionY.bind(this),
            fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series), this._trigger.registerMark(symbolMark));
    }
    dataToGridBackgroundPositionY(datum) {
        if (!this._yAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition, getBandwidth: getBandwidth} = this._yAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
            bandPosition: this._bandPosition
        }) - getBandwidth(0) / 2;
    }
    dataToGridBackgroundPositionY1(datum) {
        if (!this._yAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition, getBandwidth: getBandwidth} = this._yAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
            bandPosition: this._bandPosition
        }) + getBandwidth(0) / 2;
    }
    dataToOpacity(datum) {
        var _a, _b, _c, _d;
        if (!this._xAxisHelper) return Number.NaN;
        const {dataToPosition: dataToPosition, getScale: getScale} = this._xAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
            bandPosition: this._bandPosition
        }) < getScale(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
            bandPosition: this._bandPosition
        }) > getScale(0).range()[1] ? 0 : null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.dot) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.fillOpacity) && void 0 !== _d ? _d : 1;
    }
    dataToGridBackgroundOpacity(datum) {
        return datum[this._seriesGroupField] === this._highLightSeriesGroup ? this._gridBackground.fillOpacity : 0;
    }
    onLayoutEnd(ctx) {
        var _a, _b;
        super.onLayoutEnd(ctx);
        const layoutOffsetX = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.leftAppendPadding) && void 0 !== _b ? _b : 0;
        this.setMarkStyle(this._clipMark, {
            width: this.getLayoutRect().width + layoutOffsetX
        }, "normal", AttributeLevel.Series);
    }
    getDefaultColorDomain() {
        var _a, _b;
        return this._seriesGroupField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._seriesGroupField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
    }
    getColorAttribute() {
        var _a, _b, _c;
        return {
            scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
            field: null !== (_c = null !== (_b = this._seriesGroupField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD
        };
    }
    getDotColorScale() {
        var _a, _b, _c;
        const colorDomain = this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesGroupField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesGroupField].values : this._seriesField ? null === (_c = this.getViewDataStatistics()) || void 0 === _c ? void 0 : _c.latestData[this._seriesField].values : [], colorRange = this._getDataScheme();
        return (new ColorOrdinalScale).domain(colorDomain).range(colorRange);
    }
    getDotColorAttribute() {
        var _a, _b, _c, _d;
        return {
            scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this.getDotColorScale(),
            field: null !== (_d = null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesGroupField) && void 0 !== _c ? _c : this._seriesField) && void 0 !== _d ? _d : DEFAULT_DATA_SERIES_FIELD
        };
    }
    initTooltip() {
        this._tooltipHelper = new DotSeriesTooltipHelper(this), this._dotMark && this._tooltipHelper.activeTriggerSet.mark.add(this._dotMark);
    }
    onEvaluateEnd(ctx) {
        super.onEvaluateEnd(ctx);
    }
    onMarkTreePositionUpdate(marks) {
        marks.forEach((m => {
            "group" === m.type ? this.onMarkTreePositionUpdate(m.getMarks()) : m.updateLayoutState();
        }));
    }
    getDotData() {
        var _a;
        return null === (_a = this._dotMark) || void 0 === _a ? void 0 : _a.getData();
    }
    _getDataIdKey() {}
    getStackValueField() {
        return null;
    }
    getActiveMarks() {
        return [ this._dotMark ];
    }
}

DotSeries.type = SeriesTypeEnum.dot, DotSeries.mark = dotSeriesMark;

export const registerDotSeries = () => {
    registerSymbolMark(), registerRuleMark(), registerRectMark(), registerTextMark(), 
    Factory.registerSeries(DotSeries.type, DotSeries);
};
//# sourceMappingURL=dot.js.map
