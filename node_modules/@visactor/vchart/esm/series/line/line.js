import { CartesianSeries } from "../cartesian/cartesian";

import { SeriesMarkNameEnum, SeriesTypeEnum } from "../interface/type";

import { LineLikeSeriesMixin } from "../mixin/line-mixin";

import { mixin } from "@visactor/vutils";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { registerLineAnimation, registerScaleInOutAnimation } from "../../animation/config";

import { lineSeriesMark } from "./constant";

import { registerLineMark } from "../../mark/line";

import { registerSymbolMark } from "../../mark/symbol";

import { Factory } from "../../core/factory";

import { registerSampleTransform, registerMarkOverlapTransform } from "@visactor/vgrammar-core";

import { LineLikeSeriesSpecTransformer } from "../mixin/line-mixin-transformer";

import { getGroupAnimationParams } from "../util/utils";

export class LineSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.line, this.transformerConstructor = LineLikeSeriesSpecTransformer, 
        this._sortDataByAxis = !1;
    }
    compile() {
        super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
    }
    initMark() {
        var _a;
        const progressive = {
            progressiveStep: this._spec.progressiveStep,
            progressiveThreshold: this._spec.progressiveThreshold,
            large: this._spec.large,
            largeThreshold: this._spec.largeThreshold
        }, seriesMark = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "line";
        this.initLineMark(progressive, "line" === seriesMark), this.initSymbolMark(progressive, "point" === seriesMark);
    }
    initTooltip() {
        super.initTooltip(), this._lineMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._lineMark), 
        this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
    }
    initMarkStyle() {
        this.initLineMarkStyle(this._direction), this.initSymbolMarkStyle();
    }
    initAnimation() {
        var _a, _b, _c, _d;
        const lineAnimationParams = {
            direction: this.direction
        }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        if (this._lineMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("line")) || void 0 === _c ? void 0 : _c(lineAnimationParams, appearPreset), userAnimationConfig(SeriesMarkNameEnum.line, this._spec, this._markAttributeContext))), 
        this._symbolMark) {
            const animationParams = getGroupAnimationParams(this);
            this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig(SeriesMarkNameEnum.point, this._spec, this._markAttributeContext), animationParams));
        }
    }
    onLayoutEnd(ctx) {
        super.onLayoutEnd(ctx), this.reCompileSampling();
    }
    getSeriesStyle(datum) {
        var _a;
        const isLineAsSeriesMark = "point" !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.seriesMark);
        return attribute => {
            var _a, _b;
            return isLineAsSeriesMark && "fill" === attribute && (attribute = "stroke"), null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
        };
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [ this._lineMark, this._symbolMark ];
    }
}

LineSeries.type = SeriesTypeEnum.line, LineSeries.mark = lineSeriesMark, LineSeries.transformerConstructor = LineLikeSeriesSpecTransformer, 
mixin(LineSeries, LineLikeSeriesMixin);

export const registerLineSeries = () => {
    registerSampleTransform(), registerMarkOverlapTransform(), registerLineMark(), registerSymbolMark(), 
    registerLineAnimation(), registerScaleInOutAnimation(), Factory.registerSeries(LineSeries.type, LineSeries);
};
//# sourceMappingURL=line.js.map
