import { SeriesTypeEnum } from "../interface/type";

import { BaseSeries } from "../base/base-series";

import { isNil } from "@visactor/vutils";

import { PREFIX } from "../../constant";

export class GeoSeries extends BaseSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.geo, this.coordinate = "geo", this._nameProperty = "name";
    }
    getMapViewData() {
        var _a;
        return null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView();
    }
    get nameField() {
        return this._nameField;
    }
    set nameField(f) {
        this._nameField = f;
    }
    get valueField() {
        return this._valueField;
    }
    set valueField(f) {
        this._valueField = f;
    }
    getNameProperty() {
        return this._nameProperty;
    }
    getCentroidProperty() {
        return this._centroidProperty;
    }
    getCoordinateHelper() {
        return this._coordinateHelper;
    }
    setCoordinateHelper(h) {
        this._coordinateHelper = h;
    }
    getStatisticFields() {
        const fields = [];
        return fields.push({
            key: this._nameField,
            operations: [ "values" ]
        }), fields.push({
            key: this._valueField,
            operations: [ "max", "min" ]
        }), fields;
    }
    getGroupFields() {
        return null;
    }
    dataToPosition(datum) {
        var _a;
        let result = null;
        if (!datum) return result;
        const {dataToPosition: dataToPosition, latitudeField: latitudeField, longitudeField: longitudeField} = this._coordinateHelper;
        if (result = this.nameToPosition(datum), null === result) {
            const lonValue = longitudeField ? null == datum ? void 0 : datum[longitudeField] : Number.NaN, latValue = latitudeField ? null == datum ? void 0 : datum[latitudeField] : Number.NaN;
            result = null !== (_a = null == dataToPosition ? void 0 : dataToPosition([ lonValue, latValue ])) && void 0 !== _a ? _a : null;
        }
        return result;
    }
    nameToPosition(datum) {
        var _a, _b;
        const name = this.getDatumName(datum);
        if (isNil(name)) return null;
        const mapData = null === (_b = null === (_a = this.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.filter((data => this.getDatumName(data) === name))[0];
        if (isNil(mapData)) return null;
        const {dataToPosition: dataToPosition} = this._coordinateHelper, center = this.getDatumCenter(mapData), pos = null == dataToPosition ? void 0 : dataToPosition(center);
        return isNil(pos) || isNaN(pos.x) || isNaN(pos.y) ? null : pos;
    }
    dataToLatitude(latValue) {
        if (!this._coordinateHelper) return Number.NaN;
        const {dataToLatitude: dataToLatitude} = this._coordinateHelper;
        return dataToLatitude(latValue);
    }
    dataToLongitude(lonValue) {
        if (!this._coordinateHelper) return Number.NaN;
        const {dataToLatitude: dataToLatitude} = this._coordinateHelper;
        return dataToLatitude(lonValue);
    }
    valueToPosition(lonValue, latValue) {
        return {
            x: this.dataToLongitude(lonValue),
            y: this.dataToLatitude(latValue)
        };
    }
    positionToData(p) {}
    latitudeToData(lat) {}
    longitudeToData(lon) {}
    dataToPositionX(data) {
        var _a;
        return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 
        0;
    }
    dataToPositionY(data) {
        var _a;
        return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 
        0;
    }
    dataToPositionZ(data) {
        var _a;
        return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 
        0;
    }
    release() {
        super.release(), this._mapViewData.release(), this._mapViewData = this._mapViewDataStatistics = null;
    }
    getStackGroupFields() {
        return [ this._nameField ];
    }
    getStackValueField() {
        return this._spec.valueField;
    }
    compileData() {
        var _a;
        null === (_a = this._mapViewData) || void 0 === _a || _a.compile();
    }
    initStatisticalData() {
        if (super.initStatisticalData(), this._mapViewData) {
            const viewDataName = `${PREFIX}_series_${this.id}_mapViewDataStatic`;
            this._mapViewDataStatistics = this.createStatisticalData(viewDataName, this._mapViewData.getDataView()), 
            this._mapViewData.getDataView().target.removeListener("change", this._mapViewDataStatistics.reRunAllTransform);
        }
    }
    getSeriesKeys() {
        var _a, _b, _c, _d, _e;
        return this._seriesField ? null !== (_e = null !== (_b = null === (_a = this.getRawDataStatisticsByField(this._seriesField)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : null === (_d = null === (_c = this._mapViewDataStatistics) || void 0 === _c ? void 0 : _c.latestData[this._seriesField]) || void 0 === _d ? void 0 : _d.values) && void 0 !== _e ? _e : [] : this.name ? [ this.name ] : this.userId ? [ `${this.userId}` ] : [ `${this.type}_${this.id}` ];
    }
    fillData() {
        var _a, _b;
        super.fillData(), null === (_a = this._mapViewData.getDataView()) || void 0 === _a || _a.reRunAllTransform(), 
        null === (_b = this._mapViewDataStatistics) || void 0 === _b || _b.reRunAllTransform();
    }
    getActiveMarks() {
        return [];
    }
}
//# sourceMappingURL=geo.js.map
