import { isNil, isFunction, minInArray, maxInArray } from "@visactor/vutils";

import { couldBeValidNumber } from "../../util/type";

import { mergeFields } from "../../util/data";

const methods = {
    min: arr => arr.length ? minInArray(arr.map((n => 1 * n))) : 0,
    max: arr => arr.length ? maxInArray(arr.map((n => 1 * n))) : 0,
    "array-min": arr => arr.length ? minInArray(arr.map((n => 1 * n))) : 0,
    "array-max": arr => arr.length ? maxInArray(arr.map((n => 1 * n))) : 0,
    values: arr => {
        const map = {}, res = [];
        for (const entry of arr) map[entry] || (res.push(entry), map[entry] = 1);
        return res;
    }
};

export const dimensionStatistics = (data, op) => {
    var _a, _b;
    let fields = op.fields;
    if (isFunction(fields) && (fields = fields()), !(null == fields ? void 0 : fields.length) || !(null == data ? void 0 : data.length)) return {};
    fields = mergeFields([], fields);
    const dataKey = "parser" === op.target ? "parserData" : "latestData", latestData = data[0][dataKey] ? data[0][dataKey] : data || [], dataFields = null === (_b = (_a = data[0]).getFields) || void 0 === _b ? void 0 : _b.call(_a);
    return dimensionStatisticsOfSimpleData(latestData, fields, dataFields);
};

export const dimensionStatisticsOfSimpleData = (latestData, fields, dataFields) => {
    const result = {};
    let fValues = [], nextFValues = [];
    return fields.forEach((f => {
        const key = f.key;
        result[key] = {};
        const dataFieldInKey = null == dataFields ? void 0 : dataFields[key], operations = f.operations, isNumberField = operations.some((op => "min" === op || "max" === op || "allValid" === op));
        let allValid = !0;
        fValues.length = 0, latestData.forEach((d => {
            d && fValues.push(d[key]);
        }));
        const len = fValues.length;
        if (isNumberField) {
            nextFValues.length = 0, fValues.forEach(((item, i) => {
                couldBeValidNumber(item) && nextFValues.push(item);
            }));
            const t = fValues;
            fValues = nextFValues, nextFValues = t, allValid = fValues.length === len;
        } else fValues = operations.some((op => "array-min" === op || "array-max" === op)) ? fValues.reduce(((res, entry) => (entry && entry.forEach((d => {
            couldBeValidNumber(d) && res.push(d);
        })), res)), []) : fValues.filter((entry => void 0 !== entry));
        operations.forEach((op => {
            if (f.customize) result[key][op] = f.customize; else {
                if (dataFieldInKey && dataFieldInKey.lockStatisticsByDomain && !isNil(dataFieldInKey.domain)) {
                    if ("values" === op) return void (result[key][op] = dataFieldInKey.domain.slice());
                } else if ("allValid" === op) return;
                result[key][op] = methods[op](fValues), "array-max" === op && (result[key].max = result[key][op]), 
                "array-min" === op && (result[key].min = result[key][op]);
            }
        })), isNumberField && (result[key].allValid = allValid);
    })), result;
};
//# sourceMappingURL=dimension-statistics.js.map
