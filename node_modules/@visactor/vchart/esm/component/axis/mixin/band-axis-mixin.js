import { isArray } from "@visactor/vutils";

import { ChartEvent } from "../../../constant/event";

export class BandAxisMixin {
    constructor() {
        this._rawDomainIndex = [];
    }
    dataToPosition(values, cfg = {}) {
        var _a, _b;
        if (0 === values.length || 0 === this._scales.length) return 0;
        const {position: position, bandScale: bandScale} = this.getPosition(values);
        return position + bandScale.bandwidth() * (null !== (_b = null !== (_a = cfg.bandPosition) && void 0 !== _a ? _a : this._spec.bandPosition) && void 0 !== _b ? _b : this._defaultBandPosition);
    }
    valueToPosition(value) {
        return this._scale.scale(value);
    }
    updateGroupScaleRange() {
        let parentScale = this._scale;
        this._scales.forEach(((scale, i) => {
            i > 0 && (scale.range([ 0, parentScale.bandwidth() ]), parentScale = scale);
        }));
    }
    getPosition(values) {
        let position = 0, bandScale = this._scale;
        if (1 === this._scales.length || 1 === values.length) position = this.valueToPosition(values[0]); else {
            const max = Math.min(values.length, this._scales.length);
            for (let i = 0; i < max; i++) position += this._scales[i].scale(values[i]);
            bandScale = this._scales[max - 1];
        }
        return {
            position: position,
            bandScale: bandScale
        };
    }
    calcScales(DEFAULT_BAND_INNER_PADDING, DEFAULT_BAND_OUTER_PADDING) {
        var _a, _b;
        const {bandPadding: bandPadding, paddingInner: paddingInner, paddingOuter: paddingOuter} = this._spec, isBandPaddingArray = isArray(bandPadding), isPaddingInnerArray = isArray(paddingInner), isPaddingOuterArray = isArray(paddingOuter);
        for (let i = 0; i < this._scales.length; i++) {
            const _padding = isBandPaddingArray ? bandPadding[i] : bandPadding, _paddingInner = isPaddingInnerArray ? paddingInner[i] : paddingInner, _paddingOuter = isPaddingOuterArray ? paddingOuter[i] : paddingOuter;
            this._scales[i].paddingInner(null !== (_a = null != _paddingInner ? _paddingInner : _padding) && void 0 !== _a ? _a : DEFAULT_BAND_INNER_PADDING, !0).paddingOuter(null !== (_b = null != _paddingOuter ? _paddingOuter : _padding) && void 0 !== _b ? _b : DEFAULT_BAND_OUTER_PADDING, !0);
        }
    }
    computeBandDomain(data) {
        if (1 === data.length) return data[0].values;
        const tempSet = new Set;
        for (let i = 0; i < data.length; i++) for (let j = 0; j < data[i].values.length; j++) tempSet.add(data[i].values[j]);
        return Array.from(tempSet);
    }
    updateScaleDomain() {
        var _a;
        if (!this.isSeriesDataEnable()) return;
        !(null === (_a = this._rawDomainIndex) || void 0 === _a ? void 0 : _a.length) && this._scales.length && this._updateRawDomain();
        const userDomain = this._spec.domain;
        for (let i = 0; i < this._scales.length; i++) if (userDomain && userDomain.length && 0 === i) this._scales[i].domain(userDomain); else {
            const data = this.collectData(i), domain = this.computeDomain(data);
            this._scales[i].domain(domain.sort(((a, b) => this._rawDomainIndex[i][a] - this._rawDomainIndex[i][b])));
        }
        this.transformScaleDomain(), this.event.emit(ChartEvent.scaleDomainUpdate, {
            model: this
        }), this.event.emit(ChartEvent.scaleUpdate, {
            model: this,
            value: "domain"
        });
    }
    _updateRawDomain() {
        this._rawDomainIndex = [];
        const userDomain = this._spec.domain;
        for (let i = 0; i < this._scales.length; i++) if (userDomain && userDomain.length && 0 === i) this._scales[i].domain(userDomain); else {
            const data = this.collectData(i, !0), domain = this.computeDomain(data);
            this._rawDomainIndex[i] = {}, domain.forEach(((d, _i) => this._rawDomainIndex[i][d] = _i));
        }
    }
    _clearRawDomain() {
        this._rawDomainIndex = [];
    }
}
//# sourceMappingURL=band-axis-mixin.js.map
