import { DataView } from "@visactor/vdataset";

import { isXAxis } from "./util/common";

import { TimeUtil } from "./util/time";

import { isArray } from "@visactor/vutils";

import { eachSeries } from "../../../util/model";

import { mergeSpec } from "../../../util/spec/merge-spec";

import { CartesianLinearAxis } from "./linear-axis";

import { ComponentTypeEnum } from "../../interface/type";

import { CompilableData } from "../../../compile/data/compilable-data";

import { Factory } from "../../../core/factory";

import { registerAxis } from "../base-axis";

export class CartesianTimeAxis extends CartesianLinearAxis {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.cartesianTimeAxis, this._zero = !1, 
        this.effect = {
            scaleUpdate: params => {
                this.computeData(null == params ? void 0 : params.value), eachSeries(this._regions, (s => {
                    isXAxis(this.getOrient()) ? s.setXAxisHelper(this.axisHelper()) : s.setYAxisHelper(this.axisHelper());
                }), {
                    userId: this._seriesUserId,
                    specIndex: this._seriesIndex
                });
            }
        };
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this._tick = mergeSpec({}, this._spec.tick, null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[0]);
    }
    _initData() {
        var _a;
        if (super._initData(), null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) {
            const layerTickData = new DataView(this._option.dataSet, {
                name: `${this.type}_${this.id}_layer_1_ticks`
            }).parse(this._scale, {
                type: "scale"
            }).transform({
                type: "ticks",
                options: Object.assign(Object.assign({}, this._tickTransformOption("cartesian")), {
                    tickCount: this._spec.layers[1].tickCount,
                    forceTickCount: this._spec.layers[1].forceTickCount,
                    tickStep: this._spec.layers[1].tickStep
                })
            }, !1);
            this._layerTickData = new CompilableData(this._option, layerTickData);
        }
    }
    computeData(updateType) {
        super.computeData(updateType), this._layerTickData && (this._layerTickData.getDataView().reRunAllTransform(), 
        this._layerTickData.updateData());
    }
    getLabelFormatMethod() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const timeUtil = TimeUtil.getInstance(), timeFormat1 = (null === (_b = null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) || void 0 === _b ? void 0 : _b.timeFormat) || "%Y%m%d", timeFormatter1 = "local" === ((null === (_d = null === (_c = this._spec.layers) || void 0 === _c ? void 0 : _c[1]) || void 0 === _d ? void 0 : _d.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat, timeFormat0 = (null === (_f = null === (_e = this._spec.layers) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.timeFormat) || "%Y%m%d", timeFormatter0 = "local" === ((null === (_h = null === (_g = this._spec.layers) || void 0 === _g ? void 0 : _g[0]) || void 0 === _h ? void 0 : _h.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat;
        return (value, datum, index, data, layer) => {
            var _a;
            let timeValue;
            return timeValue = 0 === layer ? timeFormatter0(timeFormat0, value) : timeFormatter1(timeFormat1, value), 
            (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.formatMethod) ? this._spec.label.formatMethod(timeValue, datum) : timeValue;
        };
    }
    getLabelItems(length) {
        const items = [];
        return isArray(this._tickData.getLatestData()) && items.push(this._tickData.getLatestData().map((obj => ({
            id: obj.value,
            label: obj.value,
            value: 0 === length ? 0 : this.dataToPosition([ obj.value ]) / length,
            rawValue: obj.value
        })))), this._layerTickData && isArray(this._layerTickData.getLatestData()) && items.push(this._layerTickData.getLatestData().map((obj => {
            const value = this.dataToPosition([ obj.value ]);
            return {
                id: obj.value,
                label: obj.value,
                value: value / length,
                rawValue: obj.value
            };
        }))), items;
    }
    transformScaleDomain() {}
}

CartesianTimeAxis.type = ComponentTypeEnum.cartesianTimeAxis, CartesianTimeAxis.specKey = "axes";

export const registerCartesianTimeAxis = () => {
    registerAxis(), Factory.registerComponent(CartesianTimeAxis.type, CartesianTimeAxis);
};
//# sourceMappingURL=time-axis.js.map
