var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { mergeSpec } from "../../util/spec/merge-spec";

import { ComponentTypeEnum } from "../interface/type";

import { isDiscrete, isContinuous } from "@visactor/vscale";

import { Tag } from "@visactor/vrender-components";

import { LineCrosshair, SectorCrosshair, CircleCrosshair, PolygonCrosshair } from "@visactor/vrender-components";

import { BaseCrossHair } from "./base";

import { polarToCartesian, getIntersectPoint, PointService, getAngleByPoint, isArray, isValid, isValidNumber, isNil, clamp } from "@visactor/vutils";

import { angleLabelOrientAttribute, radiusLabelOrientAttribute } from "../../util/math";

import { limitTagInBounds } from "./util";

import { getAxisLabelOffset } from "../axis/util";

import { Factory } from "../../core/factory";

import { LayoutType } from "./config";

export class PolarCrossHair extends BaseCrossHair {
    static getSpecInfo(chartSpec) {
        const crosshairSpec = chartSpec[this.specKey];
        if (isNil(crosshairSpec)) return;
        if (!isArray(crosshairSpec)) return crosshairSpec.categoryField || crosshairSpec.valueField ? [ {
            spec: crosshairSpec,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.polarCrosshair
        } ] : void 0;
        const specInfos = [];
        return crosshairSpec.forEach(((s, i) => {
            (s.categoryField || s.valueField) && specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: ComponentTypeEnum.polarCrosshair
            });
        })), specInfos;
    }
    constructor(spec, options) {
        super(spec, options), this.type = ComponentTypeEnum.polarCrosshair, this.name = ComponentTypeEnum.polarCrosshair, 
        this._currValueAngle = new Map, this._currValueRadius = new Map;
    }
    _showDefaultCrosshairBySpec() {
        const {categoryField: categoryField, valueField: valueField} = this._spec;
        if ((null == categoryField ? void 0 : categoryField.visible) && categoryField.defaultSelect) {
            const {axisIndex: axisIndex, datum: datum} = categoryField.defaultSelect;
            this._defaultCrosshair(axisIndex, datum, LayoutType.VERTICAL);
        }
        if ((null == valueField ? void 0 : valueField.visible) && valueField.defaultSelect) {
            const {axisIndex: axisIndex, datum: datum} = valueField.defaultSelect;
            this._defaultCrosshair(axisIndex, datum, LayoutType.HORIZONTAL);
        }
    }
    _defaultCrosshair(axisIndex, datum, tag) {
        const axis = this._option.getComponentsByKey("axes").find((c => c.getSpecIndex() === axisIndex));
        if (axis) {
            if (tag === LayoutType.VERTICAL) {
                this._currValueAngle.clear();
                const polarCoord = {
                    angle: axis.valueToPosition(datum),
                    radius: axis.getOuterRadius()
                }, canvasPosition = axis.coordToPoint(polarCoord);
                this._currValueAngle.set(axisIndex, this._getValueByAxis(axis, canvasPosition));
            } else {
                this._currValueRadius.clear();
                const polarCoord = {
                    angle: axis.startAngle,
                    radius: axis.valueToPosition(datum)
                }, canvasPosition = axis.coordToPoint(polarCoord);
                this._currValueRadius.set(axisIndex, this._getValueByAxis(axis, canvasPosition));
            }
            this.layoutByValue(LayoutType.ALL);
        }
    }
    hide() {
        this._radiusCrosshair && this._radiusCrosshair.hideAll(), this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll(), 
        this._angleCrosshair && this._angleCrosshair.hideAll(), this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
    }
    _findAllAxisContains(relativeX, relativeY) {
        const angleAxisMap = this._getAxisInfoByField("category"), radiusAxisMap = this._getAxisInfoByField("value");
        return {
            angleAxisMap: this._filterAxisByPoint(angleAxisMap, relativeX, relativeY),
            radiusAxisMap: this._filterAxisByPoint(radiusAxisMap, relativeX, relativeY)
        };
    }
    _getAllAxisValues(axisMap, point, currValue) {
        let discrete = !1;
        return axisMap.forEach((item => {
            isDiscrete(item.axis.getScale().type) && (discrete ? this.enable = !1 : discrete = !0);
        })), !!this.enable && (axisMap.forEach(((item, id) => {
            const axis = item.axis;
            currValue.set(id, this._getValueByAxis(axis, point));
        })), !0);
    }
    _getValueByAxis(axis, point) {
        const {x: axisStartX, y: axisStartY} = axis.getLayoutStartPoint(), {x: x, y: y} = this.getLayoutStartPoint();
        let value = axis.positionToData({
            x: point.x - (axisStartX - x),
            y: point.y - (axisStartY - y)
        });
        isContinuous(axis.getScale().type) && isValidNumber(+value) && (value = (+value).toFixed(2));
        const center = {
            x: axis.getCenter().x + this.getLayoutStartPoint().x,
            y: axis.getCenter().y + this.getLayoutStartPoint().y
        };
        return {
            v: value,
            axis: axis,
            center: center,
            innerRadius: axis.getInnerRadius(),
            radius: axis.getOuterRadius(),
            startAngle: axis.startAngle,
            endAngle: axis.endAngle,
            distance: PointService.distancePP(point, axis.getCenter()),
            coord: axis.pointToCoord(point),
            point: point
        };
    }
    _layoutCrosshair(relativeX, relativeY) {
        const {angleAxisMap: angleAxisMap, radiusAxisMap: radiusAxisMap} = this._findAllAxisContains(relativeX, relativeY);
        if (0 !== angleAxisMap.size || 0 !== radiusAxisMap.size) this._currValueAngle.clear(), 
        this._currValueRadius.clear(), angleAxisMap && this._getAllAxisValues(angleAxisMap, {
            x: relativeX,
            y: relativeY
        }, this._currValueAngle), radiusAxisMap && this._getAllAxisValues(radiusAxisMap, {
            x: relativeX,
            y: relativeY
        }, this._currValueRadius), this.layoutByValue(LayoutType.ALL); else {
            if (this.enableRemain) return;
            this.hide();
        }
    }
    layoutByValue(tag = LayoutType.ALL) {
        var _a, _b, _c, _d;
        if (!this.enable) return;
        const series = this._firstSeries();
        if (!series) return;
        let angleCrossHairInfo = {
            x: 0,
            y: 0,
            center: {
                x: 0,
                y: 0
            },
            radius: 0,
            distance: 0,
            startAngle: 0,
            endAngle: 0,
            innerRadius: 0,
            visible: !1,
            label: {
                visible: !1,
                text: "",
                offset: 0
            }
        }, radiusCrossHairInfo = {
            x: 0,
            y: 0,
            center: {
                x: 0,
                y: 0
            },
            radius: 0,
            distance: 0,
            startAngle: 0,
            endAngle: 0,
            innerRadius: 0,
            visible: !1,
            sides: series.angleAxisHelper.getScale(0).ticks().length,
            label: {
                visible: !1,
                text: "",
                offset: 0
            }
        };
        if (this._angleHair) {
            angleCrossHairInfo.visible = !!this._currValueAngle.size;
            const bandWidth = series.angleAxisHelper.getBandwidth(0);
            this._currValueAngle.forEach((_a => {
                var _b, {axis: axis, v: v, coord: coord} = _a, rest = __rest(_a, [ "axis", "v", "coord" ]);
                v = null != v ? v : "", mergeSpec(angleCrossHairInfo, rest);
                const angle = series.angleAxisHelper.dataToPosition([ v ]);
                angleCrossHairInfo.angle = angle, (null === (_b = this._angleHair.label) || void 0 === _b ? void 0 : _b.visible) && (angleCrossHairInfo.label.visible = !0, 
                angleCrossHairInfo.label.text = v, angleCrossHairInfo.label.offset = getAxisLabelOffset(axis.getSpec())), 
                angleCrossHairInfo.startAngle = angle - bandWidth / 2, angleCrossHairInfo.endAngle = angle + bandWidth / 2;
            }));
        }
        if (this._radiusHair && (radiusCrossHairInfo.visible = !!this._currValueRadius.size, 
        this._currValueRadius.forEach((_a => {
            var _b, {axis: axis, v: v, coord: coord} = _a, rest = __rest(_a, [ "axis", "v", "coord" ]);
            v = null != v ? v : "", (null === (_b = this._radiusHair.label) || void 0 === _b ? void 0 : _b.visible) && (radiusCrossHairInfo.label.visible = !0, 
            radiusCrossHairInfo.label.text = v, radiusCrossHairInfo.label.offset = getAxisLabelOffset(axis.getSpec())), 
            radiusCrossHairInfo.angle = coord.angle, radiusCrossHairInfo.axis = axis, mergeSpec(radiusCrossHairInfo, rest);
        }))), this.enableRemain && !angleCrossHairInfo.visible && isValid(this._cacheAngleCrossHairInfo)) angleCrossHairInfo = this._cacheAngleCrossHairInfo; else if ((null === (_b = null === (_a = this._angleHair) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.formatMethod) && angleCrossHairInfo.label.visible) {
            const {label: label} = angleCrossHairInfo;
            label.text = this._angleHair.label.formatMethod(label.text, "angle");
        }
        if (this.enableRemain && !radiusCrossHairInfo.visible && isValid(this._cacheRadiusCrossHairInfo)) radiusCrossHairInfo = this._cacheRadiusCrossHairInfo; else if ((null === (_d = null === (_c = this._radiusHair) || void 0 === _c ? void 0 : _c.label) || void 0 === _d ? void 0 : _d.formatMethod) && radiusCrossHairInfo.label.visible) {
            const {label: label} = radiusCrossHairInfo;
            label.text = this._radiusHair.label.formatMethod(label.text, "radius");
        }
        tag && (LayoutType.HORIZONTAL && this._layoutHorizontal(radiusCrossHairInfo), LayoutType.VERTICAL && this._layoutVertical(angleCrossHairInfo)), 
        this.enableRemain && (this._cacheAngleCrossHairInfo = Object.assign(Object.assign({}, angleCrossHairInfo), {
            _isCache: !0
        }), this._cacheRadiusCrossHairInfo = Object.assign(Object.assign({}, radiusCrossHairInfo), {
            _isCache: !0
        }));
    }
    _layoutVertical(crosshairInfo) {
        var _a;
        if (crosshairInfo._isCache && this.enableRemain) return;
        const container = this.getContainer(), {angle: angle, innerRadius: innerRadius, radius: radius, label: label, startAngle: startAngle, endAngle: endAngle, center: center, visible: visible} = crosshairInfo;
        if (visible) {
            const crosshairType = "rect" === this._angleHair.type ? "sector" : "line";
            let positionAttrs;
            if (positionAttrs = "sector" === crosshairType ? {
                center: center,
                innerRadius: innerRadius,
                radius: radius,
                startAngle: startAngle,
                endAngle: endAngle
            } : {
                start: polarToCartesian(center, innerRadius, angle),
                end: polarToCartesian(center, radius, angle)
            }, this._angleCrosshair) this._angleCrosshair.setAttributes(positionAttrs); else {
                let crosshair;
                "line" === crosshairType ? crosshair = new LineCrosshair(Object.assign(Object.assign({}, positionAttrs), {
                    lineStyle: this._angleHair.style,
                    zIndex: this.gridZIndex
                })) : "sector" === crosshairType && (crosshair = new SectorCrosshair(Object.assign(Object.assign({}, positionAttrs), {
                    sectorStyle: this._angleHair.style,
                    zIndex: this.gridZIndex
                }))), this._angleCrosshair = crosshair, container.add(crosshair);
            }
            if (label.visible) {
                const orient = angleLabelOrientAttribute(angle), labelAttrs = Object.assign(Object.assign(Object.assign(Object.assign({}, polarToCartesian(center, radius + label.offset, angle)), this._angleHair.label), label), {
                    textStyle: Object.assign(Object.assign({}, null === (_a = this._angleHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
                        textAlign: orient.align,
                        textBaseline: orient.baseline
                    }),
                    zIndex: this.labelZIndex
                });
                this._updateCrosshairLabel(this._angleLabelCrosshair, labelAttrs, (label => {
                    label.name = "crosshair-angle-label", this._angleLabelCrosshair = label;
                }));
            } else this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
        }
    }
    _layoutHorizontal(crosshairInfo) {
        var _a;
        if (crosshairInfo._isCache && this.enableRemain) return;
        const {center: center, startAngle: startAngle, endAngle: endAngle, distance: distance, sides: sides, axis: axis, label: label, point: point, radius: radius, innerRadius: innerRadius, visible: visible} = crosshairInfo, container = this.getContainer();
        if (visible) {
            const crosshairType = this._radiusHair.smooth ? "circle" : "polygon";
            let polygonRadius = distance;
            if ("polygon" === crosshairType) {
                const axisCenter = axis.getCenter(), curAngle = getAngleByPoint(axisCenter, point), stepAngle = (endAngle - startAngle) / sides, index = Math.floor((curAngle - startAngle) / stepAngle), preAngle = index * stepAngle + startAngle, nextAngle = Math.min((index + 1) * stepAngle + startAngle, endAngle), prePoint = polarToCartesian(axisCenter, distance, preAngle), nextPoint = polarToCartesian(axisCenter, distance, nextAngle), insertPoint = getIntersectPoint([ nextPoint.x, nextPoint.y ], [ prePoint.x, prePoint.y ], [ axisCenter.x, axisCenter.y ], [ point.x, point.y ]);
                insertPoint && (polygonRadius = clamp(PointService.distancePN(point, insertPoint[0], insertPoint[1]) + distance, innerRadius, radius));
            }
            const positionAttrs = {
                center: center,
                startAngle: startAngle,
                endAngle: endAngle,
                radius: polygonRadius,
                sides: sides
            };
            if (this._radiusCrosshair) this._radiusCrosshair.setAttributes(positionAttrs); else {
                let crosshair;
                crosshair = "polygon" === crosshairType ? new PolygonCrosshair(Object.assign(Object.assign({}, positionAttrs), {
                    lineStyle: this._radiusHair.style,
                    zIndex: this.gridZIndex + 1
                })) : new CircleCrosshair(Object.assign(Object.assign({}, positionAttrs), {
                    lineStyle: this._radiusHair.style,
                    zIndex: this.gridZIndex
                })), this._radiusCrosshair = crosshair, container.add(crosshair);
            }
            if (label.visible) {
                const orient = radiusLabelOrientAttribute(startAngle), labelAttrs = Object.assign(Object.assign(Object.assign(Object.assign({}, polarToCartesian(center, polygonRadius, startAngle)), this._radiusHair.label), label), {
                    textStyle: Object.assign(Object.assign({}, null === (_a = this._radiusHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
                        textAlign: orient.align,
                        textBaseline: orient.baseline
                    }),
                    zIndex: this.labelZIndex
                });
                this._updateCrosshairLabel(this._radiusLabelCrosshair, labelAttrs, (label => {
                    label.name = "crosshair-radius-label", this._radiusLabelCrosshair = label;
                }));
            } else this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll();
        }
    }
    _parseFieldInfo() {
        var _a;
        const {categoryField: categoryField, valueField: valueField} = this._spec;
        categoryField && categoryField.visible && (this._angleHair = this._parseField(categoryField, "categoryField")), 
        valueField && valueField.visible && (this._radiusHair = this._parseField(valueField, "valueField"), 
        this._radiusHair.smooth = null === (_a = null == valueField ? void 0 : valueField.line) || void 0 === _a ? void 0 : _a.smooth);
    }
    _updateCrosshairLabel(label, labelAttrs, callback) {
        const container = this.getContainer();
        label ? label.setAttributes(labelAttrs) : (label = new Tag(labelAttrs), null == container || container.add(label), 
        callback(label)), limitTagInBounds(label, this._getLimitBounds());
    }
    _getNeedClearVRenderComponents() {
        return [ this._radiusCrosshair, this._radiusLabelCrosshair, this._angleCrosshair, this._angleLabelCrosshair ];
    }
}

PolarCrossHair.specKey = "crosshair", PolarCrossHair.type = ComponentTypeEnum.polarCrosshair;

export const registerPolarCrossHair = () => {
    Factory.registerComponent(PolarCrossHair.type, PolarCrossHair);
};
//# sourceMappingURL=polar.js.map
