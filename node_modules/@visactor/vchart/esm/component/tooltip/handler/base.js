import { DEFAULT_CHART_WIDTH, DEFAULT_CHART_HEIGHT } from "../../../constant/base";

import { DEFAULT_OPTIONS } from "./constants";

import { TooltipPositionMode } from "../../../typings/tooltip/position";

import { isTrueBrowser } from "../../../util/env";

import { getTooltipPatternValue, getScale } from "./utils/common";

import { getActualTooltipPositionValue, getHorizontalPositionType, getVerticalPositionType } from "./utils/position";

import { getShowContent } from "./utils/compose";

import { getTooltipSpecForShow } from "./utils/get-spec";

import { TooltipResult } from "../interface/common";

import { isNumber, isObject, isValidNumber, isValid, throttle, isNil, polygonContainPoint, pointInRect } from "@visactor/vutils";

import { getTooltipAttributes } from "./utils/attribute";

export class BaseTooltipHandler {
    get id() {
        return this._id;
    }
    get env() {
        return this._env;
    }
    constructor(tooltipId, component) {
        this._visible = !0, this._id = "", this._attributes = null, this._isReleased = !1, 
        this.showTooltip = (activeType, data, params) => {
            var _a;
            let changePositionOnly = !!params.changePositionOnly;
            return params.changePositionOnly && (null === (_a = this._cacheActualTooltip) || void 0 === _a ? void 0 : _a.activeType) === activeType || (changePositionOnly = !1, 
            this._clearCacheOfContent()), changePositionOnly && this._cacheViewSpec && this._cacheActualTooltip ? this.changeTooltipPosition(changePositionOnly, data, params) : this.changeTooltip(!0, params, changePositionOnly, activeType, data);
        }, this._changeTooltip = (visible, params, changePositionOnly, activeType, data) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            const tooltipSpec = this._component.getSpec();
            if (this._isReleased || !tooltipSpec) return TooltipResult.failed;
            if (!visible) return this._clearAllCache(), tooltipSpec.handler ? null !== (_c = null === (_b = (_a = tooltipSpec.handler).hideTooltip) || void 0 === _b ? void 0 : _b.call(_a, params)) && void 0 !== _c ? _c : TooltipResult.success : (this._updateTooltip(!1, params), 
            TooltipResult.success);
            if (isNil(activeType) || isNil(data)) return TooltipResult.failed;
            let spec;
            if (changePositionOnly && this._cacheViewSpec ? spec = this._cacheViewSpec : (spec = getTooltipSpecForShow(activeType, tooltipSpec, params.model, params.dimensionInfo), 
            this._cacheViewSpec = spec), !1 === spec.visible) return TooltipResult.failed;
            if (spec.handler) return null !== (_f = null === (_e = (_d = spec.handler).showTooltip) || void 0 === _e ? void 0 : _e.call(_d, activeType, data, params)) && void 0 !== _f ? _f : TooltipResult.success;
            const pattern = spec[activeType];
            if (!pattern) return TooltipResult.failed;
            let actualTooltip;
            return changePositionOnly && this._cacheActualTooltip ? actualTooltip = this._cacheActualTooltip : (actualTooltip = this._getActualTooltipContent(pattern, data, params), 
            actualTooltip.title = null !== (_h = null === (_g = pattern.updateTitle) || void 0 === _g ? void 0 : _g.call(pattern, actualTooltip.title, data, params)) && void 0 !== _h ? _h : actualTooltip.title, 
            actualTooltip.content = null !== (_k = null === (_j = pattern.updateContent) || void 0 === _j ? void 0 : _j.call(pattern, actualTooltip.content, data, params)) && void 0 !== _k ? _k : actualTooltip.content), 
            isNil(null === (_l = actualTooltip.title) || void 0 === _l ? void 0 : _l.key) && isNil(null === (_m = actualTooltip.title) || void 0 === _m ? void 0 : _m.value) && !(null === (_o = actualTooltip.content) || void 0 === _o ? void 0 : _o.length) ? TooltipResult.failed : (this._cacheActualTooltip = actualTooltip, 
            this._changeTooltipPosition(!!changePositionOnly, data, params));
        }, this._changeTooltipPosition = (changePositionOnly, data, params) => {
            var _a, _b, _c;
            if (this._isReleased) return TooltipResult.failed;
            const event = params.event, spec = this._cacheViewSpec, actualTooltip = this._cacheActualTooltip;
            if (!spec || !actualTooltip) return TooltipResult.failed;
            if (spec.enterable) {
                if (!this._isPointerEscaped && this._isPointerMovingToTooltip(params)) return this._isTooltipPaused || (this._isTooltipPaused = !0, 
                this._cachePointerTimer = setTimeout((() => {
                    this._isPointerEscaped = !0;
                }), 300)), TooltipResult.success;
                this._isTooltipPaused = !1, this._isPointerEscaped = !1, clearTimeout(this._cachePointerTimer), 
                this._cachePointerPosition = this._getPointerPositionRelativeToTooltipParent(params);
            }
            const activeType = actualTooltip.activeType;
            if (spec.handler) return null !== (_c = null === (_b = (_a = spec.handler).showTooltip) || void 0 === _b ? void 0 : _b.call(_a, activeType, data, params)) && void 0 !== _c ? _c : TooltipResult.success;
            const pattern = spec[activeType];
            if (!pattern) return TooltipResult.failed;
            const position = this._getActualTooltipPosition(actualTooltip, params, this._getTooltipBoxSize(actualTooltip, changePositionOnly));
            actualTooltip.position = position, pattern.updatePosition && (actualTooltip.position = pattern.updatePosition(actualTooltip.position, data, params));
            let tooltipVisible = !1 !== (null == pattern ? void 0 : pattern.visible);
            return data && "pointerout" !== event.type && actualTooltip.visible && (actualTooltip.title || actualTooltip.content) || (tooltipVisible = !1), 
            this._updateTooltip(tooltipVisible, Object.assign(Object.assign({}, params), {
                changePositionOnly: changePositionOnly
            }), actualTooltip), TooltipResult.success;
        }, this._getActualTooltipContent = (pattern, data, params) => {
            const patternVisible = getTooltipPatternValue(pattern.visible, data, params);
            let tooltipContent = null;
            tooltipContent = getShowContent(pattern, data, params);
            return Object.assign(Object.assign({}, tooltipContent), {
                visible: !!isValid(tooltipContent) && !1 !== patternVisible,
                activeType: pattern.activeType,
                data: data
            });
        }, this._getActualTooltipPosition = (actualTooltip, params, tooltipBoxSize) => {
            var _a, _b, _c, _d, _e;
            const event = params.event, invalidPosition = {
                x: 1 / 0,
                y: 1 / 0
            }, {offsetX: offsetX, offsetY: offsetY} = this._option, tooltipSpec = this._cacheViewSpec;
            if (!tooltipSpec) return this._cacheTooltipPosition = void 0, invalidPosition;
            const {activeType: activeType, data: data} = actualTooltip, pattern = tooltipSpec[activeType], position = getTooltipPatternValue(pattern.position, data, params), positionMode = getTooltipPatternValue(pattern.positionMode, data, params), tooltipParentElement = this._getParentElement(tooltipSpec), {width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0} = null != tooltipBoxSize ? tooltipBoxSize : {}, isCanvas = "canvas" === tooltipSpec.renderMode, canvasRect = null === (_a = null == params ? void 0 : params.chart) || void 0 === _a ? void 0 : _a.getCanvasRect(), canvasWidth = null !== (_b = null == canvasRect ? void 0 : canvasRect.width) && void 0 !== _b ? _b : DEFAULT_CHART_WIDTH, canvasHeight = null !== (_c = null == canvasRect ? void 0 : canvasRect.height) && void 0 !== _c ? _c : DEFAULT_CHART_HEIGHT;
            let isFixedPosition = !1;
            const containerSize = {
                width: 0,
                height: 0
            };
            let relativePosOffset = {
                x: 0,
                y: 0
            }, tooltipParentElementRect = {
                x: 0,
                y: 0
            }, chartElementScale = 1, tooltipParentElementScale = 1;
            if (isTrueBrowser(this._env) && !tooltipSpec.confine) {
                if (containerSize.width = window.innerWidth, containerSize.height = window.innerHeight, 
                !isCanvas) {
                    tooltipParentElementRect = null !== (_d = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _d ? _d : invalidPosition;
                    const chartElement = null !== (_e = this._compiler.getCanvas()) && void 0 !== _e ? _e : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
                    relativePosOffset = {
                        x: chartElementRect.x - tooltipParentElementRect.x,
                        y: chartElementRect.y - tooltipParentElementRect.y
                    }, chartElementScale = getScale(chartElement, chartElementRect), tooltipParentElementScale = getScale(tooltipParentElement, tooltipParentElementRect);
                }
            } else containerSize.width = canvasWidth, containerSize.height = canvasHeight;
            const tooltipSizeScale = tooltipParentElementScale / chartElementScale;
            let left, top, right, bottom, x, y;
            if (isObject(position)) {
                const {left: posLeft, right: posRight, top: posTop, bottom: posBottom} = position;
                left = getActualTooltipPositionValue(posLeft, event), top = getActualTooltipPositionValue(posTop, event), 
                right = getActualTooltipPositionValue(posRight, event), bottom = getActualTooltipPositionValue(posBottom, event);
            } else if (isValid(position) && positionMode !== TooltipPositionMode.pointer && "mark" === actualTooltip.activeType) {
                isFixedPosition = !0;
                const element = params.item, model = params.model, bounds = null == element ? void 0 : element.getBounds(), startPoint = null == model ? void 0 : model.getLayoutStartPoint();
                if (bounds && startPoint) {
                    let {x1: x1, y1: y1, x2: x2, y2: y2} = bounds;
                    switch (x1 += startPoint.x, x2 += startPoint.x, y1 += startPoint.y, y2 += startPoint.y, 
                    getHorizontalPositionType(position)) {
                      case "left":
                        left = x1 - tooltipBoxWidth * tooltipSizeScale - offsetX;
                        break;

                      case "right":
                        left = x2 + offsetX;
                        break;

                      case "middle":
                        left = (x1 + x2) / 2 - tooltipBoxWidth * tooltipSizeScale / 2;
                    }
                    switch (getVerticalPositionType(position)) {
                      case "top":
                        top = y1 - tooltipBoxHeight * tooltipSizeScale - offsetY;
                        break;

                      case "bottom":
                        top = y2 + offsetY;
                        break;

                      case "middle":
                        top = (y1 + y2) / 2 - tooltipBoxHeight * tooltipSizeScale / 2;
                    }
                }
            }
            const {canvasX: canvasX, canvasY: canvasY} = event;
            if (isValidNumber(left)) x = left; else if (isValidNumber(right)) x = canvasWidth - tooltipBoxWidth * tooltipSizeScale - right; else {
                const x0 = canvasX;
                switch (getHorizontalPositionType(position, "right")) {
                  case "middle":
                    x = x0 - tooltipBoxWidth * tooltipSizeScale / 2;
                    break;

                  case "left":
                    x = x0 - tooltipBoxWidth * tooltipSizeScale - offsetX;
                    break;

                  case "right":
                    x = x0 + offsetX;
                }
            }
            if (isValidNumber(top)) y = top; else if (isValidNumber(bottom)) y = canvasHeight - tooltipBoxHeight * tooltipSizeScale - bottom; else {
                const y0 = canvasY;
                switch (getVerticalPositionType(position, "bottom")) {
                  case "middle":
                    y = y0 - tooltipBoxHeight * tooltipSizeScale / 2;
                    break;

                  case "top":
                    y = y0 - tooltipBoxHeight * tooltipSizeScale - offsetY;
                    break;

                  case "bottom":
                    y = y0 + offsetY;
                }
            }
            x *= chartElementScale, y *= chartElementScale, isTrueBrowser(this._env) && (x += relativePosOffset.x, 
            y += relativePosOffset.y), x /= tooltipParentElementScale, y /= tooltipParentElementScale;
            const {width: containerWidth, height: containerHeight} = containerSize, isLeftOut = () => x * tooltipParentElementScale + tooltipParentElementRect.x < 0, isRightOut = () => (x + tooltipBoxWidth) * tooltipParentElementScale + tooltipParentElementRect.x > containerWidth, isTopOut = () => y * tooltipParentElementScale + tooltipParentElementRect.y < 0, isBottomOut = () => (y + tooltipBoxHeight) * tooltipParentElementScale + tooltipParentElementRect.y > containerHeight, detectLeftFirst = () => {
                isLeftOut() && (isFixedPosition ? x = -tooltipParentElementRect.x / tooltipParentElementScale : "middle" === getHorizontalPositionType(position, "right") ? x += offsetX + tooltipBoxWidth / 2 : x += 2 * offsetX + tooltipBoxWidth);
            }, detectLeftLast = () => {
                isLeftOut() && (x = -tooltipParentElementRect.x / tooltipParentElementScale);
            }, detectRightFirst = () => {
                isRightOut() && (isFixedPosition ? x = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth : "middle" === getHorizontalPositionType(position, "right") ? x -= offsetX + tooltipBoxWidth / 2 : x -= 2 * offsetX + tooltipBoxWidth);
            }, detectRightLast = () => {
                isRightOut() && (x = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth);
            }, detectTopFirst = () => {
                isTopOut() && (isFixedPosition ? y = -tooltipParentElementRect.y / tooltipParentElementScale : "middle" === getVerticalPositionType(position, "bottom") ? y += offsetY + tooltipBoxHeight / 2 : y += 2 * offsetY + tooltipBoxHeight);
            }, detectTopLast = () => {
                isTopOut() && (y = 0 - tooltipParentElementRect.y / tooltipParentElementScale);
            }, detectBottomFirst = () => {
                isBottomOut() && (isFixedPosition ? y = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight : "middle" === getVerticalPositionType(position, "bottom") ? y -= offsetY + tooltipBoxHeight / 2 : y -= 2 * offsetY + tooltipBoxHeight);
            }, detectBottomLast = () => {
                isBottomOut() && (y = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight);
            };
            switch (getHorizontalPositionType(position, "right")) {
              case "middle":
                isLeftOut() ? (detectLeftFirst(), detectRightLast()) : (detectRightFirst(), detectLeftLast());
                break;

              case "left":
                detectLeftFirst(), detectRightLast();
                break;

              case "right":
                detectRightFirst(), detectLeftLast();
            }
            switch (getVerticalPositionType(position, "bottom")) {
              case "middle":
                isTopOut() ? (detectTopFirst(), detectBottomLast()) : (detectBottomFirst(), detectTopLast());
                break;

              case "top":
                detectTopFirst(), detectBottomLast();
                break;

              case "bottom":
                detectBottomFirst(), detectTopLast();
            }
            const result = {
                x: x,
                y: y
            };
            return this._cacheTooltipPosition = result, this._cacheTooltipSize = {
                width: tooltipBoxWidth,
                height: tooltipBoxHeight
            }, result;
        }, this._component = component, this._chartOption = component.getOption(), this._env = this._chartOption.mode, 
        this._chartContainer = this._chartOption.globalInstance.getContainer(), this._compiler = component.getCompiler(), 
        this._id = tooltipId, this._initFromSpec();
    }
    hideTooltip(params) {
        return this.changeTooltip(!1, params);
    }
    release() {
        var _a, _b, _c;
        this._clearAllCache();
        const spec = null !== (_a = this._component.getSpec()) && void 0 !== _a ? _a : {};
        spec.handler ? null === (_c = (_b = spec.handler).release) || void 0 === _c || _c.call(_b) : (this._removeTooltip(), 
        this._isReleased = !0);
    }
    _clearAllCache() {
        this._clearCacheOfContent(), this._clearCacheOfPosition();
    }
    _clearCacheOfContent() {
        this._cacheViewSpec = void 0, this._cacheActualTooltip = void 0;
    }
    _clearCacheOfPosition() {
        this._isTooltipPaused = !1, this._isPointerEscaped = !1, clearTimeout(this._cachePointerTimer), 
        this._cachePointerTimer = -1, this._cachePointerPosition = void 0, this._cacheTooltipPosition = void 0, 
        this._cacheTooltipSize = void 0;
    }
    _throttle(callback) {
        const tooltipSpec = this._component.getSpec();
        let wait;
        return wait = isNumber(tooltipSpec.throttleInterval) ? tooltipSpec.throttleInterval : "html" === tooltipSpec.renderMode && tooltipSpec.transitionDuration ? 50 : 10, 
        throttle(callback, wait);
    }
    _getDefaultOption() {
        var _a, _b;
        const {offset: offset} = this._component.getSpec();
        return Object.assign(Object.assign({}, DEFAULT_OPTIONS), {
            offsetX: null !== (_a = null == offset ? void 0 : offset.x) && void 0 !== _a ? _a : DEFAULT_OPTIONS.offsetX,
            offsetY: null !== (_b = null == offset ? void 0 : offset.y) && void 0 !== _b ? _b : DEFAULT_OPTIONS.offsetY
        });
    }
    _getTooltipBoxSize(actualTooltip, changePositionOnly) {
        var _a, _b, _c, _d, _e, _f;
        if (!changePositionOnly || isNil(this._attributes)) {
            const chartTheme = null !== (_b = null === (_a = this._chartOption) || void 0 === _a ? void 0 : _a.getTheme()) && void 0 !== _b ? _b : {};
            this._attributes = getTooltipAttributes(actualTooltip, this._component.getSpec(), chartTheme);
        }
        return {
            width: null === (_d = null === (_c = this._attributes) || void 0 === _c ? void 0 : _c.panel) || void 0 === _d ? void 0 : _d.width,
            height: null === (_f = null === (_e = this._attributes) || void 0 === _e ? void 0 : _e.panel) || void 0 === _f ? void 0 : _f.height
        };
    }
    _getPointerPositionRelativeToTooltipParent(params) {
        var _a, _b;
        let {canvasX: x, canvasY: y} = params.event;
        const invalidPosition = {
            x: 1 / 0,
            y: 1 / 0
        }, tooltipSpec = this._cacheViewSpec, isCanvas = "canvas" === tooltipSpec.renderMode, tooltipParentElement = this._getParentElement(tooltipSpec);
        let relativePosOffset = {
            x: 0,
            y: 0
        }, tooltipParentElementRect = {
            x: 0,
            y: 0
        }, chartElementScale = 1, tooltipParentElementScale = 1;
        if (isTrueBrowser(this._env) && !tooltipSpec.confine && !isCanvas) {
            tooltipParentElementRect = null !== (_a = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _a ? _a : invalidPosition;
            const chartElement = null !== (_b = this._compiler.getCanvas()) && void 0 !== _b ? _b : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
            relativePosOffset = {
                x: chartElementRect.x - tooltipParentElementRect.x,
                y: chartElementRect.y - tooltipParentElementRect.y
            }, chartElementScale = getScale(chartElement, chartElementRect), tooltipParentElementScale = getScale(tooltipParentElement, tooltipParentElementRect);
        }
        return x *= chartElementScale, y *= chartElementScale, isTrueBrowser(this._env) && (x += relativePosOffset.x, 
        y += relativePosOffset.y), x /= tooltipParentElementScale, y /= tooltipParentElementScale, 
        {
            x: x,
            y: y
        };
    }
    _isPointerMovingToTooltip(params) {
        if (!this._cacheTooltipPosition || !this._cacheTooltipSize || !this._cachePointerPosition) return !1;
        const {width: tooltipWidth, height: tooltipHeight} = this._cacheTooltipSize, {x: tooltipX = 0, y: tooltipY} = this._cacheTooltipPosition, pos = this._getPointerPositionRelativeToTooltipParent(params);
        if (pointInRect(pos, {
            x1: tooltipX,
            y1: tooltipY,
            x2: tooltipX + tooltipWidth,
            y2: tooltipY + tooltipHeight
        }, !1)) return !0;
        const a = {
            x: tooltipX,
            y: tooltipY
        }, b = {
            x: a.x + tooltipWidth,
            y: a.y
        }, c = {
            x: a.x,
            y: a.y + tooltipHeight
        }, d = {
            x: b.x,
            y: c.y
        }, oldPos = this._cachePointerPosition;
        return polygonContainPoint([ oldPos, a, b ], pos.x, pos.y) || polygonContainPoint([ oldPos, c, d ], pos.x, pos.y) || polygonContainPoint([ oldPos, a, d ], pos.x, pos.y) || polygonContainPoint([ oldPos, b, c ], pos.x, pos.y);
    }
    _getParentElement(spec) {
        return spec.parentElement;
    }
    getTooltipContainer() {
        return this._container;
    }
    _initFromSpec() {
        this._option = this._getDefaultOption(), this.changeTooltip = this._throttle(this._changeTooltip), 
        this.changeTooltipPosition = this._throttle(this._changeTooltipPosition);
    }
    reInit() {
        this._initFromSpec();
    }
}
//# sourceMappingURL=base.js.map
