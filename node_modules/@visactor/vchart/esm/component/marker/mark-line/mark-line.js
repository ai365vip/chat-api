import { DataView } from "@visactor/vdataset";

import { ComponentTypeEnum } from "../../interface/type";

import { markerAggregation } from "../../../data/transforms/aggregation";

import { computeClipRange, coordinateLayout, positionLayout, transformLabelAttributes, xyLayout } from "../utils";

import { registerDataSetInstanceTransform } from "../../../data/register";

import { MarkLine as MarkLineComponent } from "@visactor/vrender-components";

import { isEmpty, isValid, isArray } from "@visactor/vutils";

import { transformToGraphic } from "../../../util/style";

import { BaseMarker } from "../base-marker";

import { markerRegression } from "../../../data/transforms/regression";

import { LayoutZIndex } from "../../../constant";

import { getInsertPoints, getTextOffset } from "./util";

import { Factory } from "../../../core/factory";

import { isPercent } from "../../../util";

export class MarkLine extends BaseMarker {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.markLine, this.name = ComponentTypeEnum.markLine, 
        this.specKey = "markLine", this.layoutZIndex = LayoutZIndex.MarkLine;
    }
    static getSpecInfo(chartSpec) {
        const markLineSpec = chartSpec[this.specKey];
        if (isEmpty(markLineSpec)) return;
        if (!isArray(markLineSpec) && !1 !== markLineSpec.visible) return [ {
            spec: markLineSpec,
            specPath: [ this.specKey ],
            type: ComponentTypeEnum.markLine
        } ];
        const specInfos = [];
        return markLineSpec.forEach(((m, i) => {
            !1 !== m.visible && specInfos.push({
                spec: m,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: ComponentTypeEnum.markLine
            });
        })), specInfos;
    }
    _createMarkerComponent() {
        var _a, _b, _c;
        const {label: label = {}, startSymbol: startSymbol = {}, endSymbol: endSymbol = {}} = this._spec, markLineAttrs = {
            zIndex: this.layoutZIndex,
            interactive: null !== (_a = this._spec.interactive) && void 0 !== _a && _a,
            points: [ {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            } ],
            lineStyle: null === (_b = this._spec.line) || void 0 === _b ? void 0 : _b.style,
            clipInRange: null !== (_c = this._spec.clip) && void 0 !== _c && _c,
            label: transformLabelAttributes(label)
        };
        startSymbol.visible ? markLineAttrs.startSymbol = Object.assign(Object.assign({}, startSymbol), {
            visible: !0,
            style: transformToGraphic(startSymbol.style)
        }) : markLineAttrs.startSymbol = {
            visible: !1
        }, endSymbol.visible ? markLineAttrs.endSymbol = Object.assign(Object.assign({}, endSymbol), {
            visible: !0,
            style: transformToGraphic(endSymbol.style)
        }) : markLineAttrs.endSymbol = {
            visible: !1
        };
        return new MarkLineComponent(markLineAttrs);
    }
    _markerLayout() {
        var _a, _b, _c, _d, _e, _f, _g;
        const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, isValidCoordinates = isValid(spec.coordinates), isValidProcess = isValid(spec.process), isValidProcessX = isValidProcess && isValid(spec.process.x), isValidProcessY = isValidProcess && isValid(spec.process.y), isCoordinateLayout = isValidCoordinates && (!isValidProcess || "process" in spec && "xy" in spec.process), isPositionLayout = isValid(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
        let points = [];
        if (this._isXYLayout || isValidCoordinates && isValidProcessX || isValidCoordinates && isValidProcessY) {
            const xyPoints = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
            points = 1 === xyPoints.length ? xyPoints[0] : xyPoints.map((point => point[0]));
        } else isCoordinateLayout ? points = coordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
        const seriesData = this._relativeSeries.getViewData().latestData, dataPoints = data.latestData[0].latestData || data.latestData;
        let limitRect;
        if (spec.clip || (null === (_b = spec.label) || void 0 === _b ? void 0 : _b.confine)) {
            const {minX: minX, maxX: maxX, minY: minY, maxY: maxY} = computeClipRange([ startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion() ]);
            limitRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        const markerComponentAttr = null !== (_d = null === (_c = this._markerComponent) || void 0 === _c ? void 0 : _c.attribute) && void 0 !== _d ? _d : {}, labelAttrs = Object.assign(Object.assign({}, markerComponentAttr.label), {
            text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_e = markerComponentAttr.label) || void 0 === _e ? void 0 : _e.text
        });
        if ("type-step" === this._spec.type) {
            const {multiSegment: multiSegment, mainSegmentIndex: mainSegmentIndex} = this._spec.line || {}, {connectDirection: connectDirection, expandDistance: expandDistance = 0} = this._spec;
            let expandDistanceValue;
            if (isPercent(expandDistance)) {
                const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint();
                if ("bottom" === connectDirection || "top" === connectDirection) {
                    const regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height));
                    expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionHeight / 100;
                } else {
                    const regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width));
                    expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionWidth / 100;
                }
            } else expandDistanceValue = expandDistance;
            const joinPoints = getInsertPoints(points[0], points[1], connectDirection, expandDistanceValue);
            let labelPositionAttrs;
            labelPositionAttrs = multiSegment && isValid(mainSegmentIndex) ? {
                position: "middle",
                autoRotate: !1,
                refX: 0,
                refY: 0
            } : Object.assign(Object.assign({
                position: "start",
                autoRotate: !1
            }, getTextOffset(points[0], points[1], connectDirection, expandDistanceValue)), {
                refX: 0,
                refY: 0
            }), null === (_f = this._markerComponent) || void 0 === _f || _f.setAttributes({
                points: multiSegment ? [ [ joinPoints[0], joinPoints[1] ], [ joinPoints[1], joinPoints[2] ], [ joinPoints[2], joinPoints[3] ] ] : joinPoints,
                label: Object.assign(Object.assign(Object.assign({}, labelAttrs), labelPositionAttrs), {
                    textStyle: Object.assign(Object.assign({}, markerComponentAttr.label.textStyle), {
                        textAlign: "center",
                        textBaseline: "middle"
                    })
                }),
                limitRect: limitRect,
                multiSegment: multiSegment,
                mainSegmentIndex: mainSegmentIndex,
                dx: this._layoutOffsetX,
                dy: this._layoutOffsetY
            });
        } else null === (_g = this._markerComponent) || void 0 === _g || _g.setAttributes({
            points: points,
            label: labelAttrs,
            limitRect: limitRect,
            dx: this._layoutOffsetX,
            dy: this._layoutOffsetY
        });
    }
    _initDataView() {
        const spec = this._spec, relativeSeries = this._relativeSeries, isXProcess = "x" in spec, isYProcess = "y" in spec, isX1Process = "x1" in spec, isY1Process = "y1" in spec, isCoordinateProcess = "coordinates" in spec, doXProcess = isXProcess && !isYProcess && !isY1Process, doXYY1Process = isXProcess && isYProcess && isY1Process, doYProcess = isYProcess && !isXProcess && !isX1Process, doYXX1Process = isYProcess && isXProcess && isX1Process, doXYProcess = isXProcess && isYProcess && isX1Process && isY1Process;
        if (this._markerData = relativeSeries.getViewData(), !(doXProcess || doYProcess || doXYY1Process || doYXX1Process || doXYProcess || isCoordinateProcess)) return;
        let options;
        registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), 
        registerDataSetInstanceTransform(this._option.dataSet, "markerRegression", markerRegression), 
        this._isXYLayout = doXProcess || doXYY1Process || doYProcess || doYXX1Process || doXYProcess;
        let processData = relativeSeries.getViewData(), needAggr = !0, needRegr = !1;
        if (doXYProcess) {
            const {x: x, x1: x1, y: y, y1: y1} = spec;
            options = [ this._processSpecXY(x, y), this._processSpecXY(x1, y1) ];
        } else if (doXProcess) options = [ this._processSpecX(spec.x) ]; else if (doYProcess) options = [ this._processSpecY(spec.y) ]; else if (doXYY1Process) {
            const {x: x, y: y, y1: y1} = spec;
            options = [ this._processSpecXY(x, y), this._processSpecXY(x, y1) ];
        } else if (doYXX1Process) {
            const {x: x, x1: x1, y: y} = spec;
            options = [ this._processSpecXY(x, y), this._processSpecXY(x1, y) ];
        } else if (isCoordinateProcess) {
            if (options = this._processSpecCoo(spec), needAggr = !1, processData = new DataView(this._option.dataSet, {
                name: `${this.type}_${this.id}_data`
            }).parse([ relativeSeries.getViewData() ], {
                type: "dataview"
            }).transform({
                type: "markerAggregation",
                options: options
            }), spec.process && "x" in spec.process && (options = [ this._processSpecX(spec.process.x) ], 
            needAggr = !0), spec.process && "y" in spec.process && (options = [ this._processSpecY(spec.process.y) ], 
            needAggr = !0), spec.process && "xy" in spec.process) {
                const {xField: xField, yField: yField} = relativeSeries.getSpec();
                options = {
                    fieldX: xField,
                    fieldY: yField
                }, needRegr = !0;
            }
        } else needAggr = !1;
        const data = new DataView(this._option.dataSet);
        data.parse([ processData ], {
            type: "dataview"
        }), needAggr && data.transform({
            type: "markerAggregation",
            options: options
        }), needRegr && data.transform({
            type: "markerRegression",
            options: options
        }), data.target.on("change", (() => {
            this._markerLayout();
        })), this._markerData = data;
    }
}

MarkLine.type = ComponentTypeEnum.markLine, MarkLine.specKey = "markLine";

export const registerMarkLine = () => {
    Factory.registerComponent(MarkLine.type, MarkLine);
};
//# sourceMappingURL=mark-line.js.map
