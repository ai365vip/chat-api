import { debounce, isEmpty, isNil, isArray, get } from "@visactor/vutils";

import { DataView } from "@visactor/vdataset";

import { ComponentTypeEnum } from "../../interface/type";

import { registerDataSetInstanceTransform } from "../../../data/register";

import { eachSeries } from "../../../util/model";

import { getFieldAlias } from "../../../util/data";

import { isDataDomainSpec } from "../../../util/type";

import { continuousLegendDataMake, continuousLegendFilter } from "../../../data/transforms/legend-data/continuous/continuous";

import { ContinuousLegendMap, getContinuousLegendAttributes, isContinuousLegend } from "./util";

import { BaseLegend } from "../base-legend";

import { ChartEvent } from "../../../constant";

import { Factory } from "../../../core/factory";

import { TransformLevel } from "../../../data/initialize";

const SINGLE_SEQUENCE = [ "#C4E7FF", "#98CAFF", "#75ACFF", "#518FF9", "#2775DC", "#005CBE", "#00429F", "#00287E" ], SIZE = [ 2, 10 ];

export class ContinuousLegend extends BaseLegend {
    static getSpecInfo(chartSpec) {
        const legendSpec = chartSpec[this.specKey];
        if (!legendSpec) return;
        if (!isArray(legendSpec)) return isContinuousLegend(legendSpec.type) ? [ {
            spec: legendSpec,
            specIndex: 0,
            specPath: [ this.specKey ],
            type: "color" === legendSpec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend
        } ] : void 0;
        const specInfos = [];
        return legendSpec.forEach(((s, i) => {
            isContinuousLegend(s.type) && specInfos.push({
                spec: s,
                specIndex: i,
                specPath: [ this.specKey, i ],
                type: "color" === s.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend
            });
        })), specInfos;
    }
    constructor(spec, options) {
        super(spec, options), this.type = ComponentTypeEnum.colorLegend, this.name = ComponentTypeEnum.colorLegend;
        const legendName = "color" === this._spec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend;
        this.type = legendName, this.name = legendName;
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._field = this._spec.field, this._legendType = this._spec.type;
    }
    init(option) {
        super.init(option), eachSeries(this._regions, (s => {
            s.addViewDataFilter({
                type: "continuousLegendFilter",
                options: {
                    selected: () => this._selectedData,
                    field: () => this._field,
                    data: () => this._legendData.getLatestData()
                },
                level: TransformLevel.legendFilter
            });
        }), {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
        });
    }
    _getScaleInGlobal() {
        const globalScale = this._option.globalScale;
        let scaleKey = this._spec.scale;
        return scaleKey || (scaleKey = this._legendType), globalScale.getScale(scaleKey);
    }
    _initLegendData() {
        registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendFilter", continuousLegendFilter), 
        registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendDataMake", continuousLegendDataMake);
        const legendData = new DataView(this._option.dataSet, {
            name: `${this.type}_${this.id}_data`
        });
        return legendData.transform({
            type: "continuousLegendDataMake",
            options: {
                series: () => this._regions.reduce(((pre, r) => (pre.push(...r.getSeries()), pre)), []),
                field: () => this._field,
                scale: this._getScaleInGlobal.bind(this)
            }
        }), legendData;
    }
    _initSelectedData() {
        this._spec.defaultSelected ? this._selectedData = this._spec.defaultSelected.slice() : this._selectedData = this._legendData.getLatestData();
    }
    _addDefaultTitleText(attrs) {
        var _a, _b, _c, _d;
        if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && isNil(attrs.title.text) && isNil(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
            const field = this._field;
            if (field) {
                const series = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
                if (!series) return;
                return void (attrs.title.text = getFieldAlias(series.getRawData(), field));
            }
            let scaleKey = this._spec.scale;
            scaleKey || (scaleKey = this._legendType);
            const scaleSpec = this._option.globalScale.getScaleSpec(scaleKey);
            if (!isDataDomainSpec(null == scaleSpec ? void 0 : scaleSpec.domain)) return;
            const dataInfo = scaleSpec.domain[0];
            if (0 === dataInfo.fields.length) return;
            attrs.title.text = getFieldAlias(this._option.dataSet.getDataView(dataInfo.dataId), dataInfo.fields[0]);
        } else ;
    }
    _getLegendAttributes(rect) {
        var _a, _b;
        const layout = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", align = "horizontal" === layout ? "bottom" : this.layoutOrient;
        let visualMappingRange = [];
        const scale = this._getScaleInGlobal();
        scale && "linear" === scale.type && (visualMappingRange = scale.range()), isEmpty(visualMappingRange) && (visualMappingRange = "color" === this._legendType ? SINGLE_SEQUENCE : SIZE);
        let min = null !== (_a = this._legendData.getLatestData()[0]) && void 0 !== _a ? _a : 0, max = null !== (_b = this._legendData.getLatestData()[1]) && void 0 !== _b ? _b : 1;
        this._legendData.getLatestData()[0] === this._legendData.getLatestData()[1] && (min = Math.min(0, this._legendData.getLatestData()[0]), 
        max = 0 === this._legendData.getLatestData()[0] ? 1 : Math.max(0, this._legendData.getLatestData()[0]));
        const attrs = Object.assign({
            layout: layout,
            align: align,
            zIndex: this.layoutZIndex,
            min: min,
            max: max,
            value: this._spec.defaultSelected,
            ["color" === this._legendType ? "colors" : "sizeRange"]: visualMappingRange
        }, getContinuousLegendAttributes(this._spec));
        return this._addDefaultTitleText(attrs), attrs;
    }
    _getLegendConstructor() {
        return ContinuousLegendMap[this._legendType];
    }
    _initEvent() {
        if (this._legendComponent) {
            const doFilter = !1 !== this._spec.filter;
            this._legendComponent.addEventListener("change", debounce((e => {
                const selectedData = get(e, "detail.value");
                doFilter && this.setSelectedData(selectedData), this.event.emit(ChartEvent.legendFilter, {
                    model: this,
                    value: selectedData,
                    event: e
                });
            }), 30));
        }
    }
}

ContinuousLegend.specKey = "legends", ContinuousLegend.type = ComponentTypeEnum.continuousLegend;

export const registerContinuousLegend = () => {
    Factory.registerComponent(ContinuousLegend.type, ContinuousLegend);
};
//# sourceMappingURL=legend.js.map
