import { registerLabelMark } from "../../mark/label";

import { ComponentTypeEnum } from "../interface/type";

import { AttributeLevel, LayoutZIndex, STACK_FIELD_TOTAL, STACK_FIELD_TOTAL_TOP } from "../../constant";

import { MarkTypeEnum } from "../../mark/interface";

import { mergeSpec } from "../../util/spec/merge-spec";

import { registerLabel as registerVGrammarLabel } from "@visactor/vgrammar-core";

import { textAttribute } from "./util";

import { BaseLabelComponent } from "./base-label";

import { Factory } from "../../core/factory";

import { registerComponentMark } from "../../mark/component";

export class TotalLabel extends BaseLabelComponent {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.totalLabel, this.name = ComponentTypeEnum.totalLabel, 
        this.specKey = "totalLabel", this.layoutZIndex = LayoutZIndex.Label;
    }
    static getSpecInfo(chartSpec, chartSpecInfo) {
        var _a;
        const specInfo = [];
        return null === (_a = null == chartSpecInfo ? void 0 : chartSpecInfo.region) || void 0 === _a || _a.forEach(((regionInfo, i) => {
            var _a;
            null === (_a = regionInfo.seriesIndexes) || void 0 === _a || _a.forEach((seriesIndex => {
                const {spec: spec} = chartSpecInfo.series[seriesIndex], labelSpec = spec[this.specKey];
                (null == labelSpec ? void 0 : labelSpec.visible) && specInfo.push({
                    spec: labelSpec,
                    type: ComponentTypeEnum.totalLabel,
                    specPath: [ "series", seriesIndex, this.specKey ],
                    specIndex: i
                });
            }));
        })), specInfo;
    }
    init(option) {
        super.init(option), this._initTextMark(), this._initLabelComponent();
    }
    _initTextMark() {
        var _a;
        const series = this._getSeries();
        if (null === (_a = series.getSpec().totalLabel) || void 0 === _a ? void 0 : _a.visible) {
            const mark = series.getMarksInType([ MarkTypeEnum.rect, MarkTypeEnum.symbol ])[0], textMark = this._createMark({
                type: MarkTypeEnum.label,
                name: `${mark.name}-total-label`
            });
            this._baseMark = mark, this._textMark = textMark, this._initTextMarkStyle();
        }
    }
    _initTextMarkStyle() {
        super.initMarkStyleWithSpec(this._textMark, this._spec), this.setMarkStyle(this._textMark, {
            text: datum => datum[STACK_FIELD_TOTAL]
        }, "normal", AttributeLevel.Default);
    }
    _initLabelComponent() {
        const series = this._getSeries(), component = this._createMark({
            type: MarkTypeEnum.component,
            name: `${series.name}-total-label-component`
        }, {
            componentType: "label",
            noSeparateStyle: !0,
            support3d: this._spec.support3d
        });
        component && this._marks.addMark(component);
    }
    updateLayoutAttribute() {
        super.updateLayoutAttribute();
        const series = this._getSeries();
        this._marks.forEach(((componentMark, index) => {
            componentMark.getProduct().target(this._baseMark.getProduct()).configure({
                interactive: !1
            }).labelStyle((() => {
                if (this._baseMark) {
                    const {offset: offset, animation: animation, overlap: overlap} = this._spec, interactive = this._interactiveConfig(this._spec);
                    return mergeSpec({
                        textStyle: {
                            pickable: !0 === this._spec.interactive
                        },
                        position: totalLabelPosition(series, this._baseMark.type),
                        x: 0,
                        y: 0
                    }, Object.assign({
                        offset: offset,
                        animation: animation,
                        overlap: overlap,
                        dataFilter: data => data.filter((d => d.data[STACK_FIELD_TOTAL_TOP]))
                    }, interactive));
                }
            })).encode((datum => textAttribute({
                baseMark: this._baseMark,
                labelMark: this._textMark,
                series: series,
                labelSpec: series.getSpec().totalLabel
            }, datum, this._spec.formatMethod))).size((() => this._regions[0].getLayoutRect()));
        }));
    }
    compileMarks() {
        this.getMarks().forEach((m => {
            var _a;
            const group = this._regions[0].getGroupMark().getProduct();
            m.compile({
                group: group
            }), null === (_a = m.getProduct()) || void 0 === _a || _a.configure({
                context: {
                    model: this
                }
            });
        }));
    }
    getVRenderComponents() {
        const labels = [];
        return this.getMarks().forEach((m => {
            const graphicItem = m.getProduct().getGroupGraphicItem();
            graphicItem && labels.push(graphicItem);
        })), labels;
    }
    _getSeries() {
        return this._option.getSeriesInIndex([ this.getSpecPath()[1] ])[0];
    }
}

TotalLabel.type = ComponentTypeEnum.totalLabel, TotalLabel.specKey = "totalLabel";

export function totalLabelPosition(series, type) {
    let position;
    if ("rect" === type) position = "horizontal" === series.direction ? "right" : "top"; else position = "top";
    return position;
}

export const registerTotalLabel = () => {
    registerVGrammarLabel(), registerLabelMark(), registerComponentMark(), Factory.registerComponent(TotalLabel.type, TotalLabel, !0);
};
//# sourceMappingURL=total-label.js.map
