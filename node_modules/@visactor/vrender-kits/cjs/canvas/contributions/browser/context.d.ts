import type { IPointLike, TextMeasure, ITextMeasureSpec } from '@visactor/vutils';
import { Matrix } from '@visactor/vutils';
import type { ICamera, ICanvas, ICommonStyleParams, IConicalGradientData, IContext2d, ISetCommonStyleParams, ISetStrokeStyleParams, IStrokeStyleParams, ITextStyleParams, mat4, EnvType, vec3 } from '@visactor/vrender-core';
export declare class BrowserContext2d implements IContext2d {
    static env: EnvType;
    drawPromise?: Promise<any>;
    mathTextMeasure: TextMeasure<ITextMeasureSpec>;
    canvas: ICanvas;
    camera?: ICamera;
    modelMatrix?: mat4;
    nativeContext: CanvasRenderingContext2D | any;
    _inuse: boolean;
    stack: Matrix[];
    disableFill?: boolean;
    disableStroke?: boolean;
    disableBeginPath?: boolean;
    protected matrix: Matrix;
    protected applyedMatrix?: Matrix;
    fontFamily: string;
    fontSize: number;
    set fillStyle(d: string | CanvasGradient | CanvasPattern);
    get fillStyle(): string | CanvasGradient | CanvasPattern;
    set font(d: string);
    get font(): string;
    set globalAlpha(d: number);
    get globalAlpha(): number;
    set lineCap(d: CanvasLineCap);
    get lineCap(): CanvasLineCap;
    set lineDashOffset(d: number);
    get lineDashOffset(): number;
    set lineJoin(d: CanvasLineJoin);
    get lineJoin(): CanvasLineJoin;
    set lineWidth(d: number);
    get lineWidth(): number;
    set miterLimit(d: number);
    get miterLimit(): number;
    set shadowBlur(d: number);
    get shadowBlur(): number;
    set shadowColor(d: string);
    get shadowColor(): string;
    set shadowOffsetX(d: number);
    get shadowOffsetX(): number;
    set shadowOffsetY(d: number);
    get shadowOffsetY(): number;
    set strokeStyle(d: string | CanvasGradient | CanvasPattern);
    get strokeStyle(): string | CanvasGradient | CanvasPattern;
    set textAlign(d: CanvasTextAlign);
    get textAlign(): CanvasTextAlign;
    set textBaseline(d: CanvasTextBaseline);
    get textBaseline(): CanvasTextBaseline;
    get inuse(): boolean;
    set inuse(use: boolean);
    dpr: number;
    constructor(canvas: ICanvas, dpr: number);
    reset(): void;
    getCanvas(): ICanvas;
    getContext(): any;
    setTransformForCurrent(force?: boolean): void;
    get currentMatrix(): Matrix;
    cloneMatrix(m: Matrix): import("@visactor/vutils").IMatrix;
    clear(): void;
    restore(): void;
    highPerformanceRestore(): void;
    rotate(rad: number, setTransform?: boolean): void;
    save(): void;
    highPerformanceSave(): void;
    scale(sx: number, sy: number, setTransform?: boolean): void;
    setScale(sx: number, sy: number, setTransform?: boolean): void;
    scalePoint(sx: number, sy: number, px: number, py: number, setTransform?: boolean): void;
    setTransform(a: number, b: number, c: number, d: number, e: number, f: number, setTransform?: boolean, dpr?: number): void;
    setTransformFromMatrix(matrix: Matrix, setTransform?: boolean, dpr?: number): void;
    resetTransform(setTransform?: boolean, dpr?: number): void;
    transform(a: number, b: number, c: number, d: number, e: number, f: number, setTransform?: boolean): void;
    transformFromMatrix(matrix: Matrix, setTransform?: boolean): void;
    translate(x: number, y: number, setTransform?: boolean): void;
    rotateDegrees(deg: number, setTransform?: boolean): void;
    rotateAbout(rad: number, x: number, y: number, setTransform?: boolean): void;
    rotateDegreesAbout(deg: number, x: number, y: number, setTransform?: boolean): void;
    beginPath(): void;
    clip(fillRule?: CanvasFillRule): void;
    clip(path: Path2D, fillRule?: CanvasFillRule): void;
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean, z?: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, z?: number): void;
    closePath(): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    lineTo(x: number, y: number, z: number): void;
    moveTo(x: number, y: number, z: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, z: number): void;
    rect(x: number, y: number, w: number, h: number, z: number): void;
    createImageData(imageDataOrSw: number | ImageData, sh?: number): ImageData;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): any;
    createPattern(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition: string): CanvasPattern;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
    createConicGradient(x: number, y: number, startAngle: number, endAngle: number): IConicalGradientData;
    fill(path?: Path2D, fillRule?: CanvasFillRule): void;
    fillRect(x: number, y: number, width: number, height: number): void;
    clearRect(x: number, y: number, w: number, h: number): void;
    project(x: number, y: number, z: number): IPointLike;
    view(x: number, y: number, z: number): vec3;
    fillText(text: string, x: number, y: number, z: number): void;
    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;
    getLineDash(): number[];
    isPointInPath(x: number, y: number): any;
    isPointInStroke(x: number, y: number): any;
    measureText(text: string, method?: 'native' | 'simple' | 'quick'): {
        width: number;
    };
    putImageData(imagedata: ImageData, dx: number, dy: number): void;
    setLineDash(segments: number[]): void;
    stroke(path?: Path2D): void;
    strokeRect(x: number, y: number, width: number, height: number): void;
    strokeText(text: string, x: number, y: number, z: number): void;
    drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number): void;
    drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number, dstW: number, dstH: number): void;
    drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, srcX: number, srcY: number, srcW: number, srcH: number, dstX: number, dstY: number, dstW: number, dstH: number): void;
    protected fillAttributes: {
        opacity: number;
        fillOpacity: number;
        shadowBlur: number;
        shadowColor: string;
        shadowOffsetX: number;
        shadowOffsetY: number;
        fill: import("@visactor/vrender-core").IFillType;
    };
    protected strokeAttributes: {
        opacity: number;
        outerBorder: Partial<import("@visactor/vrender-core").IBorderStyle>;
        innerBorder: Partial<import("@visactor/vrender-core").IBorderStyle>;
        strokeOpacity: number;
        lineDash: number[];
        lineDashOffset: number;
        lineWidth: number;
        lineCap: CanvasLineCap;
        lineJoin: CanvasLineJoin;
        miterLimit: number;
        strokeBoundsBuffer: number;
        stroke: import("@visactor/vrender-core").IStrokeType | import("@visactor/vrender-core").IStrokeType[];
    };
    protected textAttributes: {
        opacity: number;
        text: string | number | number[] | string[];
        maxLineWidth: number;
        textAlign: import("@visactor/vrender-core").TextAlignType;
        textBaseline: import("@visactor/vrender-core").TextBaselineType;
        fontSize: number;
        fontFamily: string;
        fontWeight: string | number;
        ellipsis: string | boolean;
        fontVariant: string;
        fontStyle: string;
        lineHeight: string | number;
        underline: number;
        lineThrough: number;
        scaleIn3d: boolean;
        direction: "horizontal" | "vertical";
        verticalMode: number;
        wordBreak: "break-word" | "break-all";
        ignoreBuf: boolean;
        heightLimit: number;
        lineClamp: number;
        wrap: boolean;
        whiteSpace: "normal" | "no-wrap";
        suffixPosition: "start" | "end" | "middle";
        disableAutoClipedPoptip: boolean;
    };
    setCommonStyle(params: ISetCommonStyleParams, attribute: ICommonStyleParams, offsetX: number, offsetY: number, defaultParams?: ICommonStyleParams | Partial<ICommonStyleParams>[]): void;
    protected _setCommonStyle(params: ISetCommonStyleParams, attribute: ICommonStyleParams, offsetX: number, offsetY: number, defaultParams?: ICommonStyleParams): void;
    setShadowBlendStyle(params: ISetCommonStyleParams, attribute: ICommonStyleParams, defaultParams?: ICommonStyleParams | Partial<ICommonStyleParams>[]): void;
    protected _clearShadowStyle: boolean;
    protected _clearFilterStyle: boolean;
    protected _clearGlobalCompositeOperationStyle: boolean;
    protected _setShadowBlendStyle(params: ISetCommonStyleParams, attribute: ICommonStyleParams, defaultParams?: ICommonStyleParams): void;
    setStrokeStyle(params: ISetStrokeStyleParams, attribute: IStrokeStyleParams, offsetX: number, offsetY: number, defaultParams?: IStrokeStyleParams | IStrokeStyleParams[]): void;
    protected _setStrokeStyle(params: ISetStrokeStyleParams, attribute: IStrokeStyleParams, offsetX: number, offsetY: number, defaultParams?: IStrokeStyleParams): void;
    setTextStyleWithoutAlignBaseline(params: Partial<ITextStyleParams>, defaultParams?: ITextStyleParams, z?: number): void;
    setTextStyle(params: Partial<ITextStyleParams>, defaultParams?: ITextStyleParams, z?: number): void;
    draw(): void;
    clearMatrix(setTransform?: boolean, dpr?: number): void;
    onlyTranslate(dpr?: number): boolean;
    release(...params: any): void;
}
