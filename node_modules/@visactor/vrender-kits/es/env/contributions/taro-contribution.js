var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

import { injectable, BaseEnvContribution } from "@visactor/vrender-core";

function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
    canvasIdLists.forEach(((id, i) => {
        const ctx = taro.createCanvasContext(id);
        ctx.canvas = {
            width: domref.width * dpr,
            height: domref.height * dpr
        }, ctx.createRadialGradient || (ctx.createRadialGradient = (...cc) => ctx.createCircularGradient(...cc)), 
        !ctx.getImageData && taro.canvasGetImageData && (ctx.getImageData = (x, y, width, height) => new Promise(((resolve, reject) => {
            try {
                taro.canvasGetImageData({
                    canvasId: id,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    success(res) {
                        resolve(res);
                    }
                });
            } catch (err) {
                reject(err);
            }
        })));
        const canvas = {
            id: id,
            width: domref.width * dpr,
            height: domref.height * dpr,
            offsetWidth: domref.width,
            offsetHeight: domref.height,
            getContext: () => ctx,
            getBoundingClientRect: () => ({
                height: domref.height,
                width: domref.width
            })
        };
        return canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), 
        canvas;
    }));
}

let TaroEnvContribution = class extends BaseEnvContribution {
    constructor() {
        super(), this.type = "taro", this.supportEvent = !0, this.canvasMap = new Map, this.freeCanvasList = [], 
        this.canvasIdx = 0, this.supportsTouchEvents = !0;
        try {
            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
        } catch (err) {
            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
        }
        this.applyStyles = !0;
    }
    getDynamicCanvasCount() {
        return this.freeCanvasList.length;
    }
    getStaticCanvasCount() {
        return 9999;
    }
    mapToCanvasPoint(event) {
        var _a;
        return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), 
        event;
    }
    configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.taro, params.pixelRatio), 
        this.taro = params.taro, this.pixelRatio = params.pixelRatio);
    }
    loadImage(url) {
        return Promise.resolve({
            data: url,
            loadState: "success"
        });
    }
    loadSvg(svgStr) {
        const _window = window || globalThis;
        if (_window.DOMParser) {
            const svg = (new _window.DOMParser).parseFromString(svgStr, "image/svg+xml").children[0], data = (new XMLSerializer).serializeToString(svg), url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
            return Promise.resolve({
                data: url,
                loadState: "success"
            });
        }
        if (_window.Blob) {
            const data = new _window.Blob([ svgStr ], {
                type: "image/svg+xml"
            }), url = _window.URL.createObjectURL(data);
            return Promise.resolve({
                data: url,
                loadState: "success"
            });
        }
        return Promise.reject();
    }
    createCanvas(params) {
        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
    }
    createOffscreenCanvas(params) {}
    releaseCanvas(canvas) {}
    getDevicePixelRatio() {
        return this.pixelRatio;
    }
    getRequestAnimationFrame() {
        return requestAnimationFrame;
    }
    getCancelAnimationFrame() {
        return cancelAnimationFrame;
    }
    addEventListener(type, listener, options) {
        return null;
    }
    removeEventListener(type, listener, options) {
        return null;
    }
    dispatchEvent(event) {
        return null;
    }
    getElementById(str) {
        return this.canvasMap.get(str);
    }
    getRootElement() {
        return null;
    }
    getDocument() {
        return null;
    }
    release(...params) {}
};

TaroEnvContribution = __decorate([ injectable(), __metadata("design:paramtypes", []) ], TaroEnvContribution);

export { TaroEnvContribution };
//# sourceMappingURL=taro-contribution.js.map