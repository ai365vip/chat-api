var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

import { ContributionProvider, inject, injectable, named, DefaultPickService, DrawContribution, PickItemInterceptor, canvasAllocate } from "@visactor/vrender-core";

import { CanvasPickerContribution } from "./contributions/constants";

let DefaultCanvasPickerService = class extends DefaultPickService {
    constructor(contributions, drawContribution, pickItemInterceptorContributions) {
        super(pickItemInterceptorContributions), this.contributions = contributions, this.drawContribution = drawContribution, 
        this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.global.hooks.onSetEnv.tap("canvas-picker-service", ((_, env, global) => {
            this.configure(global, env);
        })), this.configure(this.global, this.global.env), this.pickerMap = new Map, this.init();
    }
    init() {
        this.contributions.getContributions().forEach((item => {
            this.pickerMap.set(item.numberType, item);
        })), super._init();
    }
    configure(global, env) {
        this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
    }
    pickItem(graphic, point, parentMatrix, params) {
        if (!1 === graphic.attribute.pickable) return null;
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
            const drawContribution = this.InterceptorContributions[i];
            if (drawContribution.beforePickItem) {
                const ret = drawContribution.beforePickItem(graphic, this, point, params, {
                    parentMatrix: parentMatrix
                });
                if (ret) return ret;
            }
        }
        const picker = this.pickerMap.get(graphic.numberType);
        if (!picker) return null;
        const g = picker.contains(graphic, point, params) ? graphic : null, data = {
            graphic: g
        };
        if (g) return data;
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
            const drawContribution = this.InterceptorContributions[i];
            if (drawContribution.afterPickItem) {
                const ret = drawContribution.afterPickItem(graphic, this, point, params, {
                    parentMatrix: parentMatrix
                });
                if (ret) return ret;
            }
        }
        return data;
    }
};

DefaultCanvasPickerService = __decorate([ injectable(), __param(0, inject(ContributionProvider)), __param(0, named(CanvasPickerContribution)), __param(1, inject(DrawContribution)), __param(2, inject(ContributionProvider)), __param(2, named(PickItemInterceptor)), __metadata("design:paramtypes", [ Object, Object, Object ]) ], DefaultCanvasPickerService);

export { DefaultCanvasPickerService };