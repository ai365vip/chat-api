var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

import { inject, injectable, Generator, BaseWindowHandlerContribution, VGlobal, ContainerModule, WindowHandlerContribution } from "@visactor/vrender-core";

import { WxCanvas } from "../../canvas/contributions/wx";

class MiniAppEventManager {
    constructor() {
        this.cache = {};
    }
    addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
            listener: []
        }, this.cache[type].listener.push(func));
    }
    removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        const index = this.cache[type].listener.findIndex((f => f === func));
        index >= 0 && this.cache[type].listener.splice(index, 1);
    }
    cleanEvent() {
        this.cache = {};
    }
}

let WxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
    get container() {
        return null;
    }
    constructor(global) {
        super(), this.global = global, this.type = "wx", this.eventManager = new MiniAppEventManager;
    }
    getTitle() {
        return this.canvas.id.toString();
    }
    getWH() {
        return {
            width: this.canvas.width / (this.canvas.dpr || 1),
            height: this.canvas.height / (this.canvas.dpr || 1)
        };
    }
    getXY() {
        return {
            x: 0,
            y: 0
        };
    }
    createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
    }
    createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
        }), options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
        };
        this.canvas = new WxCanvas(options);
    }
    createWindowByCanvas(params) {
        let canvas;
        if ("string" == typeof params.canvas) {
            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        let width = params.width, height = params.height;
        if (null == width || null == height || !params.canvasControled) {
            const data = canvas.getBoundingClientRect();
            width = data.width, height = data.height;
        }
        let dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new WxCanvas({
            width: width,
            height: height,
            dpr: dpr,
            nativeCanvas: canvas,
            canvasControled: params.canvasControled
        });
    }
    releaseWindow() {}
    resizeWindow(width, height) {}
    setDpr(dpr) {
        this.canvas.dpr = dpr;
    }
    getContext() {
        return this.canvas.getContext();
    }
    getNativeHandler() {
        return this.canvas;
    }
    getDpr() {
        return this.canvas.dpr;
    }
    addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
    }
    removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
    }
    dispatchEvent(event) {
        var _a, _b, _c, _d;
        const {type: type} = event;
        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, 
        event.changedTouches[0].offsetX = null !== (_a = event.changedTouches[0].x) && void 0 !== _a ? _a : event.changedTouches[0].pageX, 
        event.changedTouches[0].clientX = null !== (_b = event.changedTouches[0].x) && void 0 !== _b ? _b : event.changedTouches[0].pageX, 
        event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = null !== (_c = event.changedTouches[0].y) && void 0 !== _c ? _c : event.changedTouches[0].pageY, 
        event.changedTouches[0].clientY = null !== (_d = event.changedTouches[0].y) && void 0 !== _d ? _d : event.changedTouches[0].pageY), 
        event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f => {
            f(event);
        })), !0);
    }
    getStyle() {
        return {};
    }
    setStyle(style) {}
    getBoundingClientRect() {
        const wh = this.getWH();
        return {
            x: 0,
            y: 0,
            width: wh.width,
            height: wh.height,
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
    }
    clearViewBox(vb, color) {
        const context = this.getContext(), dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), 
        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, 
        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
    }
};

WxWindowHandlerContribution.env = "wx", WxWindowHandlerContribution = __decorate([ injectable(), __param(0, inject(VGlobal)), __metadata("design:paramtypes", [ Object ]) ], WxWindowHandlerContribution);

export { WxWindowHandlerContribution };

export const wxWindowModule = new ContainerModule((bind => {
    bind(WxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(WxWindowHandlerContribution))).whenTargetNamed(WxWindowHandlerContribution.env);
}));
//# sourceMappingURL=wx-contribution.js.map
