import { GlyphMeta } from "../view/glyph-meta";

export class Factory {
    static registerPlotMarks(key, mark) {
        Factory._plotMarks[key] = mark;
    }
    static createPlotMark(type, id) {
        if (!Factory._plotMarks[type]) return null;
        return new (0, Factory._plotMarks[type])(id);
    }
    static registerMark(key, mark) {
        Factory._marks[key] = mark;
    }
    static createMark(type, view, group) {
        if (!Factory._marks[type]) return null;
        return new (0, Factory._marks[type])(view, type, group);
    }
    static hasMark(type) {
        return !!Factory._marks[type];
    }
    static registerComponent(key, component) {
        Factory._components[key] = component;
    }
    static createComponent(componentType, view, group, mode) {
        const Ctor = Factory._components[componentType];
        return Ctor ? new Ctor(view, group, mode) : null;
    }
    static hasComponent(componentType) {
        return !!Factory._components[componentType];
    }
    static registerGraphicComponent(key, creator) {
        Factory._graphicComponents[key] = creator;
    }
    static createGraphicComponent(componentType, attrs, options) {
        const compCreator = Factory._graphicComponents[componentType];
        return compCreator ? compCreator(attrs, options) : null;
    }
    static registerTransform(type, transform, isBuiltIn) {
        Factory._transforms[type] = Object.assign(transform, {
            type: type,
            isBuiltIn: !!isBuiltIn
        });
    }
    static getTransform(type) {
        return Factory._transforms[type];
    }
    static unregisterRuntimeTransforms() {
        Object.keys(Factory._transforms).forEach((type => {
            Factory._transforms[type] && !Factory._transforms[type].isBuiltIn && (Factory._transforms[type] = null);
        }));
    }
    static registerGrammar(type, grammarClass, specKey) {
        Factory._grammars[type] = {
            grammarClass: grammarClass,
            specKey: null != specKey ? specKey : type
        };
    }
    static createGrammar(type, view, grammarType) {
        var _a;
        const Ctor = null === (_a = Factory._grammars[type]) || void 0 === _a ? void 0 : _a.grammarClass;
        return Ctor ? new Ctor(view, grammarType) : null;
    }
    static getGrammars() {
        return this._grammars;
    }
    static getGlyph(glyphType) {
        return Factory._glyphs[glyphType];
    }
    static createInteraction(interactionType, view, options) {
        const Ctor = Factory._interactions[interactionType];
        return Ctor ? new Ctor(view, options) : null;
    }
}

Factory._plotMarks = {}, Factory._marks = {}, Factory._components = {}, Factory._graphicComponents = {}, 
Factory._transforms = {}, Factory._grammars = {}, Factory._glyphs = {}, Factory._animations = {}, 
Factory._interactions = {}, Factory._graphics = {}, Factory.registerGlyph = (glyphType, marks, encoders, defaultEncoder, progressiveChannels) => (Factory._glyphs[glyphType] = new GlyphMeta(marks, encoders, defaultEncoder, progressiveChannels), 
Factory._glyphs[glyphType]), Factory.registerAnimationType = (animationType, animation) => {
    Factory._animations[animationType] = animation;
}, Factory.getAnimationType = animationType => Factory._animations[animationType], 
Factory.registerInteraction = (interactionType, interaction) => {
    Factory._interactions[interactionType] = interaction;
}, Factory.registerGraphic = (graphicType, creator) => {
    Factory._graphics[graphicType] = creator;
}, Factory.getGraphicType = graphicType => Factory._graphics[graphicType], Factory.createGraphic = (graphicType, attributes) => {
    const creator = Factory._graphics[graphicType];
    return creator ? creator(attributes) : null;
};
//# sourceMappingURL=factory.js.map