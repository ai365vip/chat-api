import type { IArc, IArc3d, IArea, ICircle, IGlyph, IGraphic, IGroup, IImage, ILine, IPath, IPolygon, IPyramid3d, IRect, IRect3d, IRichText, ISymbol, IText } from '@visactor/vrender-core';
import type { DiffState } from '../graph/enums';
import type { IMark, IGlyphMark } from './grammar';
import type { BaseEncodeSpec, IMarkConfig, MarkFunctionType, MarkKeySpec, MarkType } from './mark';
export interface ElementGraphicMap {
    circle: ICircle;
    arc: IArc;
    area: IArea;
    image: IImage;
    line: ILine;
    path: IPath;
    rule: ILine;
    shape: IPath;
    symbol: ISymbol;
    text: IText;
    richtext: IRichText;
    polygon: IPolygon;
    cell: ISymbol;
    interval: IGraphic;
    rect: IRect;
    rect3d: IRect3d;
    arc3d: IArc3d;
    pyramid3d: IPyramid3d;
    group: IGroup;
    glyph: IGlyph;
    linkPath: IGlyph;
    treePath: IGlyph;
    wave: IGlyph;
    ripplePoint: IGlyph;
    barBoxplot: IGlyph;
    boxPlot: IGlyph;
    component: IGroup;
    axis: IGroup;
    legend: IGroup;
    corsshair: IGroup;
    slider: IGroup;
    datazoom: IGroup;
    label: IGroup;
    player: IGroup;
}
export type GetGraphicByType<T> = T extends keyof ElementGraphicMap ? ElementGraphicMap[T] : IGraphic;
export interface MarkElementItem {
    key: string;
    datum: any;
    view: any;
    nextAttrs?: any;
}
export interface IElement {
    mark: IMark;
    isReserved: boolean;
    diffState: DiffState;
    key: string;
    groupKey?: string;
    data?: any[];
    items: MarkElementItem[];
    initGraphicItem: (attrs?: any) => void;
    updateGraphicItem: (config: IMarkConfig) => void;
    getDatum: () => any;
    getBounds: () => any;
    getGraphicItem: () => IGraphic;
    removeGraphicItem: () => void;
    resetGraphicItem: () => void;
    getGraphicAttribute: (channel: string, prev?: boolean) => any;
    setGraphicAttribute: (channel: string, value: any, final?: boolean) => void;
    setGraphicAttributes: (attributes: {
        [channel: string]: any;
    }, final?: boolean) => void;
    getItemAttribute: (channel?: string) => any;
    setItemAttributes: (attributes: {
        [channel: string]: any;
    } | any[]) => void;
    updateData: (groupKey: string, data: any[], keyGenerator: MarkKeySpec, view: any) => void;
    state: (markState: MarkFunctionType<string | string[]>, parameters?: any) => void;
    encodeItems: (items: MarkElementItem[], encoders: BaseEncodeSpec, isReentered?: boolean, parameters?: any) => void;
    encodeGraphic: (attributes?: any) => void;
    transformElementItems: (items: MarkElementItem[], markType: MarkType, computePoints?: boolean) => Record<string, any>;
    remove: () => void;
    release: () => void;
    getFinalGraphicAttributes: () => {
        [key: string]: any;
    };
    getPrevGraphicAttributes: () => {
        [key: string]: any;
    };
    getNextGraphicAttributes: () => {
        [key: string]: any;
    };
    clearChangedGraphicAttributes: () => void;
    clearGraphicAttributes: () => void;
    getStates: () => string[];
    hasState: (state: string) => boolean;
    clearStates: (noAnimation?: boolean) => void;
    addState: (state: string | string[], attrs?: any) => boolean;
    removeState: (state: string | string[]) => boolean;
    useStates: (states: string[], noAnimation?: boolean) => boolean;
}
export interface IGlyphElement<P = any> extends IElement {
    mark: IGlyphMark;
    getGlyphGraphicItems: () => {
        [markName: string]: any;
    };
    getGraphicAttribute: (channel: string, prev?: boolean, markName?: any) => any;
    setGraphicAttribute: (channel: string, value: any, final?: boolean, markName?: any) => void;
    setGraphicAttributes: (attributes: {
        [channel: string]: any;
    }, final?: boolean, markName?: any) => void;
    getFinalGraphicAttributes: (markName?: string) => {
        [key: string]: any;
    };
    getPrevGraphicAttributes: (markName?: string) => {
        [key: string]: any;
    };
    getNextGraphicAttributes: (markName?: string) => {
        [key: string]: any;
    };
    encodeCustom: (nextAttrs?: any) => {
        [markName: string]: any;
    };
}
