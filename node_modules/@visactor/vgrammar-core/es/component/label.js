import { array, isNil, isString, merge } from "@visactor/vutils";

import { DataLabel } from "@visactor/vrender-components";

import { ComponentEnum, GrammarMarkType } from "../graph/enums";

import { Component } from "../view/component";

import { invokeEncoder } from "../graph/mark/encode";

import { invokeFunctionType } from "../parse/util";

import { Factory } from "../core/factory";

export const generateLabelAttributes = (marks, groupSize, encoder, labelStyle, parameters, theme = {}) => {
    var _a;
    const labelTheme = null === (_a = theme.components) || void 0 === _a ? void 0 : _a.dataLabel, dataLabels = marks.map(((mark, index) => {
        var _a, _b, _c, _d, _e;
        const labelParameters = Object.assign(Object.assign({}, parameters), {
            labelIndex: index
        }), addition = null !== (_a = invokeFunctionType(labelStyle, labelParameters, mark)) && void 0 !== _a ? _a : {}, {components: components = {}} = theme;
        let currentTheme = {};
        switch (mark.markType) {
          case GrammarMarkType.line:
          case GrammarMarkType.area:
            currentTheme = "line" === addition.type ? components.lineLabel : "area" === addition.type ? components.areaLabel : components.lineDataLabel;
            break;

          case GrammarMarkType.rect:
          case GrammarMarkType.rect3d:
          case GrammarMarkType.interval:
            currentTheme = components.rectLabel;
            break;

          case GrammarMarkType.symbol:
          case GrammarMarkType.circle:
          case GrammarMarkType.cell:
            currentTheme = components.symbolLabel;
            break;

          case GrammarMarkType.arc:
          case GrammarMarkType.arc3d:
            currentTheme = components.arcLabel;
            break;

          case GrammarMarkType.polygon:
          case GrammarMarkType.path:
          default:
            currentTheme = components.pointLabel;
        }
        const data = null !== (_b = addition.data) && void 0 !== _b ? _b : [], themeDatum = null !== (_d = null === (_c = null == currentTheme ? void 0 : currentTheme.data) || void 0 === _c ? void 0 : _c[0]) && void 0 !== _d ? _d : {};
        data && data.length > 0 ? data.forEach(((d, index) => {
            if (mark.elements[index]) {
                const attributes = invokeEncoder(encoder, d, mark.elements[index], labelParameters);
                merge(d, themeDatum, attributes);
            }
        })) : mark.elements.forEach((element => {
            if ("willRelease" !== element.getGraphicItem().releaseStatus) if (mark.isCollectionMark()) {
                element.getDatum().forEach((entry => {
                    const attributes = invokeEncoder(encoder, entry, element, labelParameters);
                    data.push(merge({}, themeDatum, attributes));
                }));
            } else {
                const attributes = invokeEncoder(encoder, element.getDatum(), element, labelParameters), datum = merge({}, themeDatum, attributes);
                data.push(datum);
            }
        }));
        const graphicItemName = null === (_e = mark.graphicItem) || void 0 === _e ? void 0 : _e.name;
        return merge({}, currentTheme, {
            data: data,
            baseMarkGroupName: graphicItemName,
            getBaseMarks: () => mark.elements.map((element => element.getGraphicItem()))
        }, null != addition ? addition : {});
    })).filter((label => !isNil(label)));
    return merge({}, labelTheme, {
        size: groupSize,
        dataLabels: dataLabels
    });
};

export class Label extends Component {
    constructor(view, group) {
        super(view, ComponentEnum.label, group), this.spec.componentType = ComponentEnum.label;
    }
    parseAddition(spec) {
        return super.parseAddition(spec), this.labelStyle(spec.labelStyle), this.size(spec.size), 
        this.target(spec.target), this;
    }
    labelStyle(style) {
        return this.setFunctionSpec(style, "labelStyle");
    }
    size(size) {
        return this.setFunctionSpec(size, "size");
    }
    target(mark) {
        if (this.spec.target) {
            const prevMarks = array(this.spec.target).map((m => isString(m) ? this.view.getMarkById(m) : m));
            this.detach(prevMarks);
        }
        if (this.spec.target = mark, mark) {
            const nextMarks = array(mark).map((m => isString(m) ? this.view.getMarkById(m) : m));
            this.attach(nextMarks);
        }
        return this.commit(), this;
    }
    _updateComponentEncoders() {
        const encoders = Object.assign({
            update: {}
        }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce(((res, state) => {
            const encoder = encoders[state];
            return encoder && (res[state] = {
                callback: (datum, element, parameters) => {
                    var _a, _b, _c, _d;
                    const marks = array(this.spec.target).map((m => isString(m) ? this.view.getMarkById(m) : m)), groupGraphicItem = null === (_b = null === (_a = this.group) || void 0 === _a ? void 0 : _a.getGroupGraphicItem) || void 0 === _b ? void 0 : _b.call(_a);
                    let size = invokeFunctionType(this.spec.size, parameters);
                    size || (size = groupGraphicItem ? {
                        width: null !== (_c = groupGraphicItem.attribute.width) && void 0 !== _c ? _c : groupGraphicItem.AABBBounds.width(),
                        height: null !== (_d = groupGraphicItem.attribute.height) && void 0 !== _d ? _d : groupGraphicItem.AABBBounds.height()
                    } : {
                        width: 1 / 0,
                        height: 1 / 0
                    });
                    const theme = this.spec.skipTheme ? null : this.view.getCurrentTheme();
                    return generateLabelAttributes(marks, size, encoder, this.spec.labelStyle, parameters, theme);
                }
            }), res;
        }), {});
        this._encoders = componentEncoders;
    }
}

Label.componentType = ComponentEnum.label;

export const registerLabel = () => {
    Factory.registerGraphicComponent(ComponentEnum.label, (attrs => new DataLabel(attrs))), 
    Factory.registerComponent(ComponentEnum.label, Label);
};
//# sourceMappingURL=label.js.map