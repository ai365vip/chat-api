{"version":3,"sources":["../src/view/grammar-base.ts"],"names":[],"mappings":"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","file":"grammar-base.js","sourcesContent":["import { array, EventEmitter, isNil, isString, isValid } from '@visactor/vutils';\nimport type { GrammarType, IGrammarBase, IView, IGrammarTask, BaseEventHandler } from '../types';\nimport { parseOptions } from '../parse/option';\nimport { parseFunctionType } from '../parse/util';\nimport type { Nil } from '../types/base';\nimport { HOOK_EVENT } from '../graph/enums';\n\nlet grammarBaseId = -1;\n\nexport abstract class GrammarBase extends EventEmitter implements IGrammarBase {\n  readonly grammarType: GrammarType;\n\n  readonly uid: number;\n  protected _id: string;\n  protected _name: string;\n\n  protected spec: any = {};\n\n  view: IView;\n  rank: number;\n\n  // FIXME: adapt current implementation of dataflow, refactor after dataflow design is finished\n  grammarSource: IGrammarBase;\n  references: Map<IGrammarBase, number> = new Map();\n  targets: IGrammarBase[] = [];\n  transforms: IGrammarTask[] = [];\n\n  constructor(view: IView) {\n    super();\n    this.view = view;\n    this.uid = ++grammarBaseId;\n  }\n\n  parse(spec: any): this {\n    this.id(spec.id);\n    this.name(spec.name);\n    this.depend(spec.dependency);\n    return this;\n  }\n\n  depend(grammars: IGrammarBase[] | IGrammarBase | string[] | string) {\n    if (this.spec?.dependency) {\n      const lastGrammars = array(this.spec.dependency).map(grammar => {\n        return isString(grammar) ? this.view.getGrammarById(grammar) : grammar;\n      });\n      this.detach(lastGrammars);\n    }\n    this.spec.dependency = grammars;\n    const currentGrammars = array(grammars).map(grammar => {\n      return isString(grammar) ? this.view.getGrammarById(grammar) : grammar;\n    });\n    this.attach(currentGrammars);\n\n    this.commit();\n    return this;\n  }\n\n  addEventListener(type: string, handler: BaseEventHandler, options?: any) {\n    let callback = handler;\n    if (!(options && options.trap === false)) {\n      callback = handler;\n      (callback as any).raw = handler;\n    }\n    if (options && options.target) {\n      (callback as any).target = options.target;\n    }\n    this.on(type, callback);\n    return this;\n  }\n\n  removeEventListener(type: string, handler?: BaseEventHandler) {\n    if (handler) {\n      this.off(type, handler);\n    } else {\n      this.off(type);\n    }\n    return this;\n  }\n\n  emit<T extends EventEmitter.EventNames<string | symbol>>(\n    event: T,\n    ...args: EventEmitter.EventArgs<string | symbol, T>\n  ): boolean {\n    this.view?.emit?.(event, ...args);\n    return super.emit(event, ...args);\n  }\n\n  emitGrammarEvent<T extends EventEmitter.EventNames<string | symbol>>(\n    event: T,\n    ...args: EventEmitter.EventArgs<string | symbol, T>\n  ): boolean {\n    return super.emit(event, ...args);\n  }\n\n  abstract evaluate(upstream: any, parameters: any): this | Promise<this>;\n  abstract output(): any;\n  evaluateSync?: (upstream: any, parameters: any) => this;\n\n  async evaluateTransform(transforms: IGrammarTask[], upstream: any, parameters: any) {\n    if (!transforms || !transforms.length) {\n      return upstream;\n    }\n    let currentUpstreamData = upstream;\n    let i = 0;\n    const n = transforms.length;\n\n    while (i < n) {\n      const task = transforms[i];\n\n      this.emit(HOOK_EVENT.BEFORE_TRANSFORM, task.type);\n      currentUpstreamData = task.transform(\n        task.isRawOptions ? task.options : parseOptions(task.options, parameters),\n        currentUpstreamData,\n        parameters,\n        this.view\n      );\n      if ((currentUpstreamData as any)?.then) {\n        currentUpstreamData = await currentUpstreamData;\n      }\n      i++;\n      this.emit(HOOK_EVENT.AFTER_TRANSFORM, task.type);\n    }\n\n    return currentUpstreamData;\n  }\n\n  evaluateTransformSync(transforms: IGrammarTask[], upstream: any, parameters: any) {\n    if (!transforms || !transforms.length) {\n      return upstream;\n    }\n    let currentUpstreamData = upstream;\n    let i = 0;\n    const n = transforms.length;\n\n    while (i < n) {\n      const task = transforms[i];\n\n      this.emit(HOOK_EVENT.BEFORE_TRANSFORM, task.type);\n      currentUpstreamData = task.transform(\n        task.isRawOptions ? task.options : parseOptions(task.options, parameters),\n        currentUpstreamData,\n        parameters,\n        this.view\n      );\n      i++;\n      this.emit(HOOK_EVENT.AFTER_TRANSFORM, task.type);\n    }\n\n    return currentUpstreamData;\n  }\n\n  set(value: any): boolean {\n    // do nothing\n    return false;\n  }\n\n  id(): string;\n  id(id: string): this;\n  id(id?: string) {\n    if (arguments.length) {\n      this.view.grammars.unrecord(this);\n      this._id = id;\n      this.view.grammars.record(this);\n      return this;\n    }\n    return this._id;\n  }\n\n  name(): string;\n  name(name: string): this;\n  name(name?: string) {\n    if (arguments.length) {\n      this._name = name;\n      return this;\n    }\n    return this._name;\n  }\n\n  attach(reference: IGrammarBase | IGrammarBase[], count: number = 1) {\n    array(reference)\n      .filter(ref => !isNil(ref))\n      .forEach(ref => {\n        if (isNil(reference)) {\n          return;\n        }\n        if (!ref.targets.includes(this)) {\n          ref.targets.push(this);\n        }\n        this.references.set(ref, (this.references.get(ref) ?? 0) + count);\n      });\n    return this;\n  }\n\n  detach(reference: IGrammarBase | IGrammarBase[], count: number = 1) {\n    array(reference)\n      .filter(ref => !isNil(ref))\n      .forEach(ref => {\n        const refCount = this.references.get(ref) - count;\n        if (refCount > 0) {\n          this.references.set(ref, refCount - 1);\n        } else {\n          this.references.delete(ref);\n          if (ref.targets.includes(this)) {\n            ref.targets = ref.targets.filter(target => target !== this);\n          }\n        }\n      });\n    return this;\n  }\n\n  detachAll() {\n    this.references.forEach((count, ref) => {\n      this.detach(ref, count);\n    });\n  }\n\n  link(source: IGrammarBase) {\n    this.grammarSource = source;\n  }\n\n  run() {\n    const upstream = this.grammarSource?.output();\n    const parameters = this.parameters();\n    return this.evaluate(upstream, parameters);\n  }\n\n  runSync() {\n    const upstream = this.grammarSource?.output();\n    const parameters = this.parameters();\n\n    if (this.evaluateSync) {\n      return this.evaluateSync(upstream, parameters);\n    }\n    return this.evaluate(upstream, parameters);\n  }\n\n  commit() {\n    this.view.commit(this);\n  }\n\n  parameters() {\n    const params: any = {};\n    this.references.forEach((count, ref) => {\n      // upstream reference with no valid id will not be recorded in parameters\n      if (isValid(ref.id())) {\n        params[ref.id() as string] = ref.output();\n      }\n    });\n    return params;\n  }\n\n  getSpec() {\n    return this.spec;\n  }\n\n  reuse(grammar: IGrammarBase) {\n    return this;\n  }\n\n  clear() {\n    this.spec = null;\n    this.view = null;\n  }\n\n  release() {\n    this.clear();\n  }\n\n  protected setFunctionSpec<T>(spec: T | Nil, specField: string) {\n    if (!isNil(this.spec[specField])) {\n      this.detach(parseFunctionType(this.spec[specField], this.view));\n    }\n    this.spec[specField] = spec;\n    this.attach(parseFunctionType(spec, this.view));\n    this.commit();\n    return this;\n  }\n}\n"]}