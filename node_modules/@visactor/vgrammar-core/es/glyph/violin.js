import { isValidNumber } from "@visactor/vutils";

import { Factory } from "../core/factory";

import { registerGlyphGraphic, registerPolygonGraphic, registerRectGraphic, registerRuleGraphic, registerSymbolGraphic } from "../graph/mark/graphic";

import { isHorizontal } from "@visactor/vgrammar-util";

const defaultDensitySize = 30, computeViolinPoints = (density, densitySize, scale, config) => {
    if (!density || 0 === density.length) return [];
    const maxDensity = density.reduce(((max, d) => Math.max(max, d[1])), 0);
    if (config && isHorizontal(config.direction)) {
        return [ ...density.map((d => ({
            y: 1 / maxDensity * -densitySize * d[1],
            x: scale.scale(d[0])
        }))), ...density.map((d => ({
            y: densitySize * (1 / maxDensity) * d[1],
            x: scale.scale(d[0])
        }))).reverse() ];
    }
    return [ ...density.map((d => ({
        x: 1 / maxDensity * -densitySize * d[1],
        y: scale.scale(d[0])
    }))), ...density.map((d => ({
        x: densitySize * (1 / maxDensity) * d[1],
        y: scale.scale(d[0])
    }))).reverse() ];
}, encodeViolin = (encodeValues, datum, element, config) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const attributes = {
        violin: {},
        shaft: {},
        box: {},
        median: {}
    }, x = null !== (_a = encodeValues.x) && void 0 !== _a ? _a : element.getGraphicAttribute("x", !1), y = null !== (_b = encodeValues.y) && void 0 !== _b ? _b : element.getGraphicAttribute("y", !1), width = null !== (_c = encodeValues.width) && void 0 !== _c ? _c : element.getGraphicAttribute("width", !1), height = null !== (_d = encodeValues.height) && void 0 !== _d ? _d : element.getGraphicAttribute("height", !1), boxWidth = null !== (_e = encodeValues.boxWidth) && void 0 !== _e ? _e : element.getGraphicAttribute("boxWidth", !1), boxHeight = null !== (_f = encodeValues.boxHeight) && void 0 !== _f ? _f : element.getGraphicAttribute("boxHeight", !1), densitySize = null !== (_h = null !== (_g = encodeValues.densitySize) && void 0 !== _g ? _g : element.getGraphicAttribute("densitySize", !1)) && void 0 !== _h ? _h : 30, densityScale = element.mark.getScalesByChannel().density, densityField = element.mark.getFieldsByChannel().density;
    if (densityField && densityScale) {
        const points = computeViolinPoints(datum[densityField], densitySize, densityScale, config);
        Object.assign(attributes.violin, {
            points: points
        });
    }
    return config && isHorizontal(config.direction) ? isValidNumber(boxHeight) ? Object.assign(attributes.box, {
        y: y - boxHeight / 2,
        y1: y + boxHeight / 2
    }) : Object.assign(attributes.box, {
        y: y - height / 2,
        y1: y + height / 2
    }) : isValidNumber(boxWidth) ? Object.assign(attributes.box, {
        x: x - boxWidth / 2,
        x1: x + boxWidth / 2
    }) : Object.assign(attributes.box, {
        x: x - width / 2,
        x1: x + width / 2
    }), attributes;
};

export const registerViolinGlyph = () => {
    Factory.registerGlyph("violin", {
        violin: "polygon",
        shaft: "rule",
        box: "rect",
        median: "symbol"
    }).registerFunctionEncoder(encodeViolin).registerChannelEncoder("x", ((channel, encodeValue, encodeValues, datum, element, config) => config && isHorizontal(config.direction) ? null : {
        shaft: {
            x: encodeValue,
            x1: encodeValue
        }
    })).registerChannelEncoder("y", ((channel, encodeValue, encodeValues, datum, element, config) => config && isHorizontal(config.direction) ? {
        shaft: {
            y: encodeValue,
            y1: encodeValue
        }
    } : null)).registerChannelEncoder("q1", ((channel, encodeValue, encodeValues, datum, element, config) => config && isHorizontal(config.direction) ? {
        box: {
            x: encodeValue
        }
    } : {
        box: {
            y: encodeValue
        }
    })).registerChannelEncoder("q3", ((channel, encodeValue, encodeValues, datum, element, config) => config && isHorizontal(config.direction) ? {
        box: {
            x1: encodeValue
        }
    } : {
        box: {
            y1: encodeValue
        }
    })).registerChannelEncoder("min", ((channel, encodeValue, encodeValues, datum, element, config) => config && isHorizontal(config.direction) ? {
        shaft: {
            x: encodeValue
        }
    } : {
        shaft: {
            y: encodeValue
        }
    })).registerChannelEncoder("max", ((channel, encodeValue, encodeValues, datum, element, config) => config && isHorizontal(config.direction) ? {
        shaft: {
            x1: encodeValue
        }
    } : {
        shaft: {
            y1: encodeValue
        }
    })).registerChannelEncoder("median", ((channel, encodeValue, encodeValues, datum, element, config) => config && isHorizontal(config.direction) ? {
        median: {
            x: encodeValue,
            x1: encodeValue,
            visible: !0
        }
    } : {
        median: {
            y: encodeValue,
            y1: encodeValue,
            visible: !0
        }
    })).registerChannelEncoder("angle", ((channel, encodeValue, encodeValues, datum, element, config) => {
        var _a;
        const defaultAnchor = config && isHorizontal(config.direction) ? [ (encodeValues.min + encodeValues.max) / 2, encodeValues.y ] : [ encodeValues.x, (encodeValues.min + encodeValues.max) / 2 ], anchor = null !== (_a = encodeValues.anchor) && void 0 !== _a ? _a : defaultAnchor;
        return {
            shaft: {
                angle: encodeValue,
                anchor: anchor
            },
            box: {
                angle: encodeValue,
                anchor: anchor
            },
            median: {
                angle: encodeValue,
                anchor: anchor
            }
        };
    })).registerChannelEncoder("medianFill", ((channel, encodeValue, encodeValues, datum, element, config) => ({
        median: {
            fill: encodeValue
        }
    }))).registerChannelEncoder("violinFill", ((channel, encodeValue, encodeValues, datum, element, config) => ({
        violin: {
            fill: encodeValue
        }
    }))).registerChannelEncoder("violinStroke", ((channel, encodeValue, encodeValues, datum, element, config) => ({
        violin: {
            stroke: encodeValue
        }
    }))).registerChannelEncoder("density", ((channel, encodeValue, encodeValues, datum, element, config) => ({
        violin: {
            points: encodeValue
        }
    }))).registerDefaultEncoder((() => ({
        violin: {
            fill: "#ff807f",
            stroke: "#ff0000"
        },
        shaft: {
            stroke: "#000000"
        },
        box: {
            fill: "#000000"
        },
        median: {
            fill: "#FFFFFF",
            visible: !1
        }
    }))), registerGlyphGraphic(), registerPolygonGraphic(), registerRuleGraphic(), registerRectGraphic(), 
    registerSymbolGraphic();
};
//# sourceMappingURL=violin.js.map