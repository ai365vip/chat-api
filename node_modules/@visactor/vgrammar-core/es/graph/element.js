import { array, has, isBoolean, isNil, isFunction, isString, isArray, get, isEmpty, isEqual as isObjEqual } from "@visactor/vutils";

import { isEqual } from "@visactor/vgrammar-util";

import { BridgeElementKey } from "./constants";

import { DiffState, HOOK_EVENT, GrammarMarkType, BuiltInEncodeNames } from "./enums";

import { invokeEncoderToItems } from "./mark/encode";

import { removeGraphicItem } from "./util/graphic";

import { transformAttributes } from "./attributes/transform";

import { getLargeRectsPoints, getLargeSymbolsPoints, getLinePoints, isValidPointsChannel, isPointsMarkType } from "./attributes/helpers";

import { getLineSegmentConfigs, getLinePointsFromSegments, parseCollectionMarkAttributes } from "./attributes/line";

import { CustomPath2D } from "@visactor/vrender-core";

import { invokeFunctionType, parseField } from "../parse/util";

export class Element {
    constructor(mark) {
        this.data = null, this.states = [], this.diffState = DiffState.enter, this.isReserved = !1, 
        this.runtimeStatesEncoder = null, this.items = [], this.getStateAttrs = (stateName, nextStates) => {
            var _a, _b, _c;
            const isRuntimeState = !isNil(null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateName]), encoder = isRuntimeState ? this.runtimeStatesEncoder[stateName] : null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[stateName];
            if (!encoder) return {};
            if (isFunction(encoder)) return encoder(this.getDatum(), this, stateName, nextStates);
            if (!isRuntimeState && (null === (_c = this.graphicItem.states) || void 0 === _c ? void 0 : _c[stateName])) return this.graphicItem.states[stateName];
            const stateItems = this.items.map((item => Object.assign({}, item, {
                nextAttrs: {}
            })));
            invokeEncoderToItems(this, stateItems, encoder, this.mark.parameters());
            const graphicAttributes = this.transformElementItems(stateItems, this.mark.markType);
            return this.graphicItem.states ? this.graphicItem.states[stateName] || (this.graphicItem.states[stateName] = graphicAttributes) : this.graphicItem.states = {
                [stateName]: graphicAttributes
            }, graphicAttributes;
        }, this.mark = mark;
    }
    initGraphicItem(attributes = {}) {
        if (this.graphicItem) return;
        const attrTransforms = this.mark.getAttributeTransforms();
        this.graphicItem = this.mark.addGraphicItem(attrTransforms ? transformAttributes(attrTransforms, attributes, this) : attributes, this.groupKey), 
        this.graphicItem && (this.graphicItem[BridgeElementKey] = this, attrTransforms && (this.graphicItem.onBeforeAttributeUpdate = attributes => {
            if (!this.mark) return attributes;
            return transformAttributes(attrTransforms, attributes, this);
        }), this.clearGraphicAttributes(), this.mark.needAnimate() && (this.setPrevGraphicAttributes(null), 
        this.setNextGraphicAttributes(attributes), this.setFinalGraphicAttributes(attributes)));
    }
    updateGraphicItem(config) {
        if (!this.graphicItem) return;
        isNil(config.clip) || this.graphicItem.setAttribute("clip", config.clip), isNil(config.interactive) || this.graphicItem.setAttribute("pickable", config.interactive), 
        isNil(config.zIndex) || this.graphicItem.setAttribute("zIndex", config.zIndex), 
        this.diffState === DiffState.exit ? this.graphicItem.releaseStatus = "willRelease" : this.graphicItem.releaseStatus = void 0;
        const stateAnimation = this.mark.animate.getAnimationConfigs("state");
        0 !== stateAnimation.length && (this.graphicItem.stateAnimateConfig = stateAnimation[0].originConfig);
    }
    getGraphicItem() {
        return this.graphicItem;
    }
    removeGraphicItem() {
        var _a, _b;
        this.graphicItem && (null === (_b = null === (_a = this.graphicItem.animates) || void 0 === _a ? void 0 : _a.forEach) || void 0 === _b || _b.call(_a, (animate => animate.stop()))), 
        this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem[BridgeElementKey] = null, 
        this.graphicItem = null);
    }
    resetGraphicItem() {
        this.graphicItem && (this.graphicItem = null);
    }
    getBounds() {
        var _a;
        return null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.AABBBounds;
    }
    getStates() {
        return this.states;
    }
    updateData(groupKey, data, key) {
        var _a;
        this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_UPDATE_DATA, {
            groupKey: groupKey,
            data: data,
            key: key
        }, this), this.data = data;
        const keyGetter = parseField(key);
        return this.items = data.map((datum => ({
            datum: datum,
            key: keyGetter(datum),
            view: this.mark.view,
            nextAttrs: {}
        }))), this.groupKey = groupKey, this.key = this.mark.isCollectionMark() ? groupKey : null === (_a = this.items) || void 0 === _a ? void 0 : _a[0].key, 
        this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_UPDATE_DATA, {
            groupKey: groupKey,
            data: data,
            key: key
        }, this), this.items;
    }
    state(markState, parameters) {
        var _a;
        const isCollectionMark = this.mark.isCollectionMark(), prevStateValues = this.states, newStateValues = array(invokeFunctionType(markState, parameters, this.getDatum(), this)), stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
        stateSort && stateSort.sort(stateSort);
        const isStateChanged = newStateValues.length !== prevStateValues.length || newStateValues.some(((newState, index) => newState !== prevStateValues[index]));
        this.states = newStateValues, !isCollectionMark && isStateChanged && this.diffState === DiffState.unChange && (this.diffState = DiffState.update);
    }
    encodeGraphic(attrs) {
        this.coordinateTransformEncode(this.items);
        const graphicAttributes = this.transformElementItems(this.items, this.mark.markType);
        attrs && (this.mark.isCollectionMark() && delete attrs.defined, Object.assign(graphicAttributes, attrs)), 
        this.graphicItem ? (this.graphicItem.clearStates(), this.graphicItem.states = {}, 
        this.graphicItem.stateProxy = null, this.applyGraphicAttributes(graphicAttributes)) : this.initGraphicItem(graphicAttributes), 
        this.diffState !== DiffState.enter && this.diffState !== DiffState.update || !this.states.length || this.useStates(this.states), 
        this.mark.markType === GrammarMarkType.shape && (this.graphicItem.datum = this.items[0].datum), 
        this.items.forEach((item => {
            item.nextAttrs = {};
        })), this._setCustomizedShape();
    }
    _setCustomizedShape() {
        var _a;
        if (!this.graphicItem) return;
        const setCustomizedShape = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.setCustomizedShape;
        setCustomizedShape && (this.graphicItem.pathProxy = attrs => setCustomizedShape(this.data, attrs, new CustomPath2D));
    }
    encodeItems(items, encoders, isReentered = !1, parameters) {
        const isCollectionMark = this.mark.isCollectionMark(), updateEncoder = encoders[BuiltInEncodeNames.update], enterEncoder = encoders[BuiltInEncodeNames.enter], exitEncoder = encoders[BuiltInEncodeNames.exit], onlyFullEncodeFirst = this.mark.isLargeMode() || isCollectionMark && !this.mark.getSpec().enableSegments;
        this.diffState === DiffState.enter ? (enterEncoder && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), 
        updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.update ? ((isCollectionMark && enterEncoder || isReentered) && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), 
        updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.exit && exitEncoder && (isReentered && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), 
        invokeEncoderToItems(this, items, exitEncoder, parameters, onlyFullEncodeFirst));
    }
    coordinateTransformEncode(items) {
        if (!this.mark.coord || "arc" === this.mark.markType || !0 === this.mark.disableCoordinateTransform) return;
        const coord = this.mark.coord.output();
        items.forEach((item => {
            const nextAttrs = item.nextAttrs, convertedPoint = coord.convert(nextAttrs);
            Object.assign(nextAttrs, convertedPoint);
        }));
    }
    clearStates(hasAnimation) {
        const stateAnimationEnable = isBoolean(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
        this.states = [], this.graphicItem && this.graphicItem.clearStates(stateAnimationEnable), 
        this.runtimeStatesEncoder && (this.runtimeStatesEncoder = {});
    }
    _updateRuntimeStates(state, attrs) {
        this.runtimeStatesEncoder || (this.runtimeStatesEncoder = {}), this.runtimeStatesEncoder[state] = attrs;
    }
    hasState(state) {
        return this.states && state && this.states.includes(state);
    }
    addState(state, attrs) {
        var _a;
        if (!this.graphicItem) return !1;
        if (attrs && isString(state) && !isObjEqual(attrs, null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[state])) {
            const nextStates = this.states.slice();
            return nextStates.includes(state) ? this.graphicItem.clearStates() : nextStates.push(state), 
            this._updateRuntimeStates(state, attrs), this.useStates(nextStates), !0;
        }
        const encode = this.mark.getSpec().encode, nextStates = array(state).reduce(((nextStates, stateName) => (stateName && !nextStates.includes(stateName) && (null == encode ? void 0 : encode[stateName]) && nextStates.push(stateName), 
        nextStates)), this.states.slice());
        return nextStates.length !== this.states.length && (this.useStates(nextStates), 
        !0);
    }
    removeState(state) {
        if (!this.graphicItem) return !1;
        const states = array(state);
        if (!states.length) return !1;
        const nextStates = this.states.filter((state => !states.includes(state)));
        return nextStates.length !== this.states.length && (this.runtimeStatesEncoder && states.forEach((state => {
            this.runtimeStatesEncoder[state] = null;
        })), this.useStates(nextStates), !0);
    }
    useStates(states, hasAnimation) {
        var _a;
        if (!this.graphicItem) return !1;
        this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, {
            states: states
        }, this);
        const stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
        stateSort && states.sort(stateSort), this.states = states;
        const stateAnimationEnable = isBoolean(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
        return this.graphicItem.stateProxy = this.getStateAttrs, this.graphicItem.useStates(this.states, stateAnimationEnable), 
        this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, {
            states: states
        }, this), !0;
    }
    diffAttributes(graphicAttributes) {
        const diffResult = {}, finalGraphicAttributes = this.getFinalGraphicAttributes();
        for (const key in graphicAttributes) isEqual(key, finalGraphicAttributes, graphicAttributes) && has(finalGraphicAttributes, key) || (diffResult[key] = graphicAttributes[key]);
        return diffResult;
    }
    transformElementItems(items, markType, computePoints) {
        var _a, _b, _c, _d;
        const item = items[0];
        if (!item.nextAttrs || 0 === Object.keys(item.nextAttrs).length) return {};
        let nextAttrs = item.nextAttrs;
        if (isPointsMarkType(markType) && items && items.length && isNil(null === (_a = item.nextAttrs) || void 0 === _a ? void 0 : _a.points) && (!0 === computePoints || isValidPointsChannel(Object.keys(item.nextAttrs), this.mark.markType))) {
            const lastPoints = this.getGraphicAttribute("points", !1), lastSegments = this.getGraphicAttribute("segments", !1), enableSegments = this.mark.getSpec().enableSegments, itemNextAttrs = items.map((item => item.nextAttrs)), isProgressive = this.mark.isProgressive();
            if (nextAttrs = parseCollectionMarkAttributes(nextAttrs), markType === GrammarMarkType.line || markType === GrammarMarkType.area) {
                const linePoints = getLinePoints(items, !0, lastPoints, markType === GrammarMarkType.area);
                if (enableSegments && !isProgressive) {
                    const points = linePoints && 0 !== linePoints.length ? linePoints : getLinePointsFromSegments(lastSegments), segments = getLineSegmentConfigs(itemNextAttrs, points, this);
                    segments ? (nextAttrs.segments = segments, nextAttrs.points = null) : (nextAttrs.segments = null, 
                    nextAttrs.points = points);
                } else isProgressive ? nextAttrs.segments = (null !== (_d = null === (_c = null === (_b = this.graphicItem) || void 0 === _b ? void 0 : _b.attribute) || void 0 === _c ? void 0 : _c.segments) && void 0 !== _d ? _d : []).concat([ {
                    points: linePoints
                } ]) : (nextAttrs.points = linePoints, nextAttrs.segments = null);
            } else markType === GrammarMarkType.largeRects ? nextAttrs.points = getLargeRectsPoints(items, !0, lastPoints) : markType === GrammarMarkType.largeSymbols && (nextAttrs.points = getLargeSymbolsPoints(items, !0, lastPoints));
        }
        return nextAttrs;
    }
    applyGraphicAttributes(graphicAttributes) {
        var _a, _b;
        if (!isEmpty(graphicAttributes)) if (this.mark.needAnimate()) {
            const nextGraphicAttributes = this.diffAttributes(graphicAttributes), prevGraphicAttributes = null !== (_a = this.getPrevGraphicAttributes()) && void 0 !== _a ? _a : {}, finalGraphicAttributes = null !== (_b = this.getFinalGraphicAttributes()) && void 0 !== _b ? _b : {};
            Object.keys(nextGraphicAttributes).forEach((channel => {
                prevGraphicAttributes[channel] = this.getGraphicAttribute(channel), finalGraphicAttributes[channel] = nextGraphicAttributes[channel];
            })), this.setNextGraphicAttributes(nextGraphicAttributes), this.setPrevGraphicAttributes(prevGraphicAttributes), 
            this.setFinalGraphicAttributes(finalGraphicAttributes);
            const animateGraphicAttributes = this.mark.animate.getElementAnimators(this).reduce(((attributes, animator) => Object.assign(attributes, animator.getEndAttributes())), {}), currentGraphicAttributes = Object.assign({}, animateGraphicAttributes, finalGraphicAttributes);
            this.graphicItem.setAttributes(currentGraphicAttributes);
        } else this.graphicItem.setAttributes(graphicAttributes);
    }
    getGraphicAttribute(channel, prev = !1) {
        var _a;
        if (!this.graphicItem) return;
        if (prev) {
            let value;
            const prevGraphicAttributes = this.getPrevGraphicAttributes();
            if (!isNil(value = get(prevGraphicAttributes, channel))) return value;
        }
        const trans = this.mark.getAttributeTransforms();
        let getKey = [ channel ];
        if (trans && trans.length) {
            const channelTransform = trans.find((entry => entry.storedAttrs && entry.channels.includes(channel)));
            channelTransform && (getKey = [ channelTransform.storedAttrs, channel ]);
        }
        return get(null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.attribute, getKey);
    }
    setGraphicAttribute(channel, value, final = !0) {
        if (!this.graphicItem) return;
        const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
        final && finalGraphicAttributes && (finalGraphicAttributes[channel] = value), prevGraphicAttributes && !has(prevGraphicAttributes, channel) && (prevGraphicAttributes[channel] = this.graphicItem.attribute[channel]), 
        this.graphicItem.setAttribute(channel, value);
    }
    setGraphicAttributes(attributes, final = !0) {
        if (!this.graphicItem) return;
        const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
        Object.keys(attributes).forEach((key => {
            finalGraphicAttributes && final && (finalGraphicAttributes[key] = attributes[key]), 
            prevGraphicAttributes && !has(prevGraphicAttributes, key) && (prevGraphicAttributes[key] = this.graphicItem.attribute[key]);
        })), this.graphicItem.setAttributes(attributes);
    }
    getFinalGraphicAttributes() {
        return this.graphicItem.finalAttrs;
    }
    setFinalGraphicAttributes(attributes) {
        this.graphicItem.finalAttrs = attributes;
    }
    getPrevGraphicAttributes() {
        return this.graphicItem.prevAttrs;
    }
    setPrevGraphicAttributes(attributes) {
        this.graphicItem.prevAttrs = attributes;
    }
    getNextGraphicAttributes() {
        return this.graphicItem.nextAttrs;
    }
    setNextGraphicAttributes(attributes) {
        this.graphicItem.nextAttrs = attributes;
    }
    clearChangedGraphicAttributes() {
        this.graphicItem && (this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null));
    }
    clearGraphicAttributes() {
        this.graphicItem && (this.graphicItem.prevAttrs && this.setPrevGraphicAttributes(null), 
        this.graphicItem.nextAttrs && this.setNextGraphicAttributes(null), this.graphicItem.finalAttrs && this.setFinalGraphicAttributes(null));
    }
    remove() {
        this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem = null);
    }
    release() {
        this.removeGraphicItem(), this.mark = null, this.data = null, this.items = null;
    }
    getItemAttribute(channel) {
        var _a, _b;
        if (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length) return this.mark.isCollectionMark() ? isNil(channel) ? this.items.map((item => item.nextAttrs)) : this.items.map((item => {
            var _a;
            return null === (_a = item.nextAttrs) || void 0 === _a ? void 0 : _a[channel];
        })) : isNil(channel) ? this.items[0].nextAttrs : null === (_b = this.items[0].nextAttrs) || void 0 === _b ? void 0 : _b[channel];
    }
    setItemAttributes(attributes) {
        var _a;
        (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length) && (this.mark.isCollectionMark() ? isArray(attributes) && this.items.forEach(((item, index) => {
            Object.assign(item.nextAttrs, attributes[index]);
        })) : Object.assign(this.items[0].nextAttrs, attributes));
    }
    getItem() {
        var _a, _b;
        return this.mark.isCollectionMark() ? null !== (_a = this.items) && void 0 !== _a ? _a : [] : null === (_b = this.items) || void 0 === _b ? void 0 : _b[0];
    }
    getDatum() {
        var _a, _b;
        return this.mark.isCollectionMark() ? null !== (_a = this.data) && void 0 !== _a ? _a : [] : null === (_b = this.data) || void 0 === _b ? void 0 : _b[0];
    }
}
//# sourceMappingURL=element.js.map