import { isFunction } from "@visactor/vutils";

import { SIGNAL_VIEW_HEIGHT, SIGNAL_PADDING, SIGNAL_VIEW_WIDTH } from "./../../view/constants";

import { GrammarMarkType } from "../enums";

import { doGridLayout } from "./grid";

import { doRelativeLayout } from "./relative";

export const defaultDoLayout = (layoutMarks, options, view) => {
    null == layoutMarks || layoutMarks.forEach((mark => {
        var _a;
        if (mark.markType !== GrammarMarkType.group) return;
        const layoutChildren = mark.layoutChildren, layoutSpec = mark.getSpec().layout, bounds = null !== (_a = mark.layoutBounds) && void 0 !== _a ? _a : mark.getBounds();
        if (bounds) {
            if (isFunction(layoutSpec)) layoutSpec.call(null, mark, layoutChildren, bounds, options); else if (isFunction(layoutSpec.callback)) layoutSpec.callback.call(null, mark, layoutChildren, bounds, options); else if ("relative" === layoutSpec.display) if (layoutSpec.updateViewSignals) {
                const oldViewBox = view.getViewBox();
                oldViewBox && bounds.intersect(oldViewBox);
                const viewBounds = doRelativeLayout(mark, layoutChildren, bounds, options), viewWidth = viewBounds.width(), viewHeight = viewBounds.height(), padding = {
                    top: viewBounds.y1,
                    right: view.width() - viewBounds.x2,
                    left: viewBounds.x1,
                    bottom: view.height() - viewBounds.y2
                };
                view.updateSignal(SIGNAL_VIEW_WIDTH, viewWidth), view.updateSignal(SIGNAL_VIEW_HEIGHT, viewHeight), 
                view.updateSignal(SIGNAL_PADDING, padding);
            } else doRelativeLayout(mark, layoutChildren, bounds, options); else "grid" === layoutSpec.display && doGridLayout(mark, layoutChildren, bounds, options);
            defaultDoLayout(layoutChildren, options, view);
        }
    }));
};
//# sourceMappingURL=layout.js.map
