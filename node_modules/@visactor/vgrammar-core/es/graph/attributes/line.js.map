{"version":3,"sources":["../src/graph/attributes/line.ts"],"names":[],"mappings":"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","file":"line.js","sourcesContent":["import type { IColor, IColorStop } from '@visactor/vrender-core';\nimport { isNil, isString } from '@visactor/vutils';\nimport { transformAttributes } from './transform';\nimport { GrammarMarkType } from '../enums';\nimport type { IElement } from '../../types';\n\nconst isStopsEqual = (prev: IColorStop[], next: IColorStop[]) => {\n  if (prev === next) {\n    return true;\n  }\n  const prevLength = (prev && prev.length) ?? 0;\n  const nextLength = (next && next.length) ?? 0;\n\n  if (prevLength !== nextLength || prevLength === 0) {\n    return false;\n  }\n\n  return prev.every((prevEntry, prevIndex) => {\n    return (\n      (!prevEntry && !next[prevIndex]) ||\n      (prevEntry &&\n        next[prevIndex] &&\n        prevEntry.color === next[prevIndex].color &&\n        prevEntry.offset === next[prevIndex].offset)\n    );\n  });\n};\n\nconst isColorAttrEqual = (prev: IColor, next: IColor) => {\n  if (prev === next) {\n    return true;\n  }\n\n  if (typeof prev !== typeof next) {\n    return false;\n  }\n\n  if (isString(prev)) {\n    return false;\n  }\n\n  if (prev.gradient !== (next as any).gradient) {\n    return false;\n  }\n\n  const prevKeys = Object.keys(prev);\n  const nextKeys = Object.keys(next);\n\n  if (prevKeys.length !== nextKeys.length) {\n    return false;\n  }\n\n  return prevKeys.every(key => {\n    if (key === 'stops') {\n      return isStopsEqual(prev[key], next[key]);\n    }\n\n    return prev[key] === next[key];\n  });\n};\n\nconst isLineDashEqual = (prev: number[], next: number[]) => {\n  if (prev.length !== next.length) {\n    return false;\n  }\n\n  if (prev.join('-') === next.join('-')) {\n    return true;\n  }\n\n  return false;\n};\n\nconst isSegmentAttrEqual = (prev: any, next: any, key: string) => {\n  if (isNil(prev) && isNil(next)) {\n    return true;\n  }\n\n  if (isNil(prev)) {\n    return false;\n  }\n\n  if (isNil(next)) {\n    return false;\n  }\n\n  if (key === 'lineDash') {\n    return isLineDashEqual(prev, next);\n  }\n\n  if (key === 'stroke' || key === 'fill') {\n    return isColorAttrEqual(prev, next);\n  }\n\n  return prev === next;\n};\n\nconst fillAttrs = ['fill', 'fillOpacity', 'background', 'texture', 'texturePadding', 'textureSize', 'textureColor'];\nconst strokeAttrs = [\n  'stroke',\n  'strokeOpacity',\n  'lineDash',\n  'lineDashOffset',\n  'lineCap',\n  'lineJoin',\n  'lineWidth',\n  'miterLimit'\n];\nconst areaAttrs = fillAttrs.concat(strokeAttrs);\n\n/**\n * 生成用于渲染的点数组\n * @param {*} item\n * @returns {IPointLike[]}\n */\nexport function getLineSegmentConfigs(items: any[], points: any[], element?: IElement) {\n  if (!items || items.length <= 1) {\n    return null;\n  }\n\n  const checkAttributes = element?.mark?.markType === 'area' ? areaAttrs : strokeAttrs;\n\n  const segments: any[] = [];\n  let prevSegmentAttrs: any = null;\n\n  items.forEach((item, index) => {\n    if (\n      !prevSegmentAttrs ||\n      !checkAttributes.every(key => {\n        return isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key);\n      })\n    ) {\n      if (segments.length) {\n        segments[segments.length - 1].endIndex = index;\n      }\n\n      prevSegmentAttrs = item;\n      segments.push({\n        attrs: prevSegmentAttrs,\n        startIndex: index\n      });\n    }\n  });\n\n  if (segments.length >= 2) {\n    return segments.map(entry => {\n      const res = transformAttributes(GrammarMarkType.line, parseCollectionMarkAttributes(entry.attrs), element) as any;\n\n      res.points = points.slice(entry.startIndex, isNil(entry.endIndex) ? points.length : entry.endIndex);\n      return res;\n    });\n  }\n\n  return null;\n}\n\nexport function getLinePointsFromSegments(segments: any[]) {\n  if (!segments) {\n    return null;\n  }\n  return segments.reduce((points, segment) => {\n    return points.concat(segment.points);\n  }, []);\n}\n\nexport function parseCollectionMarkAttributes(itemNextAttrs: any) {\n  const result = {};\n\n  if (!itemNextAttrs) {\n    return result;\n  }\n\n  Object.keys(itemNextAttrs).forEach(key => {\n    if (\n      key === 'x' ||\n      key === 'y' ||\n      key === 'x1' ||\n      key === 'y1' ||\n      key === 'defined' ||\n      key === 'size' ||\n      key === 'width' ||\n      key === 'height' ||\n      key === 'context'\n    ) {\n      return;\n    }\n    result[key] = itemNextAttrs[key];\n  });\n\n  return result;\n}\n"]}