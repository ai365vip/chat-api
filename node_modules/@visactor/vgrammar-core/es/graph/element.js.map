{"version":3,"sources":["../src/graph/element.ts"],"names":[],"mappings":"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","file":"element.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\n// eslint-disable-next-line no-duplicate-imports\nimport {\n  array,\n  has,\n  isBoolean,\n  isNil,\n  isFunction,\n  isString,\n  isArray,\n  get,\n  isEmpty,\n  isEqual as isObjEqual\n} from '@visactor/vutils';\nimport { isEqual } from '@visactor/vgrammar-util';\nimport type { IBaseCoordinate } from '@visactor/vgrammar-coordinate';\nimport { BridgeElementKey } from './constants';\nimport { DiffState, HOOK_EVENT, GrammarMarkType, BuiltInEncodeNames } from './enums';\nimport { invokeEncoderToItems } from './mark/encode';\nimport { removeGraphicItem } from './util/graphic';\nimport { transformAttributes } from './attributes/transform';\nimport {\n  getLargeRectsPoints,\n  getLargeSymbolsPoints,\n  getLinePoints,\n  isValidPointsChannel,\n  isPointsMarkType\n} from './attributes/helpers';\nimport { getLineSegmentConfigs, getLinePointsFromSegments, parseCollectionMarkAttributes } from './attributes/line';\nimport type {\n  BaseEncodeSpec,\n  BaseSingleEncodeSpec,\n  IElement,\n  IMark,\n  IMarkConfig,\n  MarkElementItem,\n  MarkFunctionType,\n  MarkKeySpec,\n  MarkSpec,\n  MarkType,\n  StateProxyEncodeSpec\n} from '../types';\nimport type { IGraphic, ILine, IGraphicAttribute } from '@visactor/vrender-core';\n// eslint-disable-next-line no-duplicate-imports\nimport { CustomPath2D } from '@visactor/vrender-core';\nimport { invokeFunctionType, parseField } from '../parse/util';\n\nexport class Element implements IElement {\n  mark: IMark;\n\n  key: string;\n  groupKey?: string;\n  data: any[] = null;\n\n  states: string[] = [];\n\n  diffState: DiffState = DiffState.enter;\n  // Element should be reserved as long as it need to animate\n  isReserved: boolean = false;\n\n  runtimeStatesEncoder: BaseEncodeSpec = null;\n\n  protected graphicItem: IGraphic;\n\n  // hack before vRender refactoring\n  items: MarkElementItem[] = [];\n\n  constructor(mark: IMark) {\n    this.mark = mark;\n  }\n\n  initGraphicItem(attributes: any = {}) {\n    if (this.graphicItem) {\n      return;\n    }\n    // 统一读取mark中是否可交互的配置\n    const attrTransforms = this.mark.getAttributeTransforms();\n\n    this.graphicItem = this.mark.addGraphicItem(\n      attrTransforms ? transformAttributes(attrTransforms, attributes, this) : attributes,\n      this.groupKey\n    );\n\n    if (!this.graphicItem) {\n      return;\n    }\n    // 统一读取mark中是否可交互的配置\n    this.graphicItem[BridgeElementKey] = this;\n    if (attrTransforms) {\n      this.graphicItem.onBeforeAttributeUpdate = (attributes: any) => {\n        // mark might be released\n        if (!this.mark) {\n          return attributes;\n        }\n        const graphicAttributes = transformAttributes(attrTransforms, attributes, this);\n        return graphicAttributes;\n      };\n    }\n\n    // transform initial attributes\n    this.clearGraphicAttributes();\n    if (this.mark.needAnimate()) {\n      this.setPrevGraphicAttributes(null);\n      this.setNextGraphicAttributes(attributes);\n      this.setFinalGraphicAttributes(attributes);\n    }\n  }\n\n  updateGraphicItem(config: IMarkConfig) {\n    if (!this.graphicItem) {\n      return;\n    }\n\n    if (!isNil(config.clip)) {\n      this.graphicItem.setAttribute('clip', config.clip);\n    }\n    if (!isNil(config.interactive)) {\n      this.graphicItem.setAttribute('pickable', config.interactive);\n    }\n    if (!isNil(config.zIndex)) {\n      this.graphicItem.setAttribute('zIndex', config.zIndex);\n    }\n    if (this.diffState === DiffState.exit) {\n      (this.graphicItem as any).releaseStatus = 'willRelease';\n    } else {\n      (this.graphicItem as any).releaseStatus = undefined;\n    }\n\n    const stateAnimation = this.mark.animate.getAnimationConfigs('state');\n    if (stateAnimation.length !== 0) {\n      (this.graphicItem as any).stateAnimateConfig = stateAnimation[0].originConfig;\n    }\n  }\n\n  getGraphicItem() {\n    return this.graphicItem;\n  }\n\n  removeGraphicItem() {\n    // stop all animation when releasing including normal animation & morphing animation\n    if (this.graphicItem) {\n      this.graphicItem.animates?.forEach?.(animate => animate.stop());\n    }\n\n    if (this.graphicItem) {\n      removeGraphicItem(this.graphicItem);\n      this.graphicItem[BridgeElementKey] = null;\n      this.graphicItem = null;\n    }\n  }\n\n  resetGraphicItem() {\n    if (this.graphicItem) {\n      this.graphicItem = null;\n    }\n  }\n\n  getBounds() {\n    // FIXME: 没有更新 bounds 时拿到的 bound 可能为 null\n    return this.graphicItem?.AABBBounds;\n  }\n\n  getStates() {\n    return this.states;\n  }\n\n  updateData(groupKey: string | null, data: any[], key: MarkKeySpec) {\n    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_UPDATE_DATA, { groupKey, data, key }, this);\n    this.data = data;\n    const keyGetter = parseField(key);\n    this.items = data.map(datum => {\n      const key = keyGetter(datum);\n      const item = {\n        datum,\n        key,\n        view: this.mark.view,\n        nextAttrs: {}\n      };\n\n      return item;\n    });\n\n    this.groupKey = groupKey;\n    this.key = this.mark.isCollectionMark() ? groupKey : this.items?.[0].key;\n\n    this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_UPDATE_DATA, { groupKey, data, key }, this);\n    return this.items;\n  }\n\n  state(markState: MarkFunctionType<string | string[]>, parameters?: any) {\n    const isCollectionMark = this.mark.isCollectionMark();\n\n    const prevStateValues = this.states;\n    const newStateValues = array(invokeFunctionType(markState, parameters, this.getDatum(), this));\n    const stateSort = this.mark.getSpec()?.stateSort;\n\n    if (stateSort) {\n      stateSort.sort(stateSort);\n    }\n\n    const isStateChanged =\n      newStateValues.length !== prevStateValues.length ||\n      newStateValues.some((newState: string, index: number) => newState !== prevStateValues[index]);\n    this.states = newStateValues;\n\n    // early logic didn't handle collection mark, only update signal mark state for now\n    if (!isCollectionMark && isStateChanged && this.diffState === DiffState.unChange) {\n      this.diffState = DiffState.update;\n    }\n  }\n\n  encodeGraphic(attrs?: any) {\n    this.coordinateTransformEncode(this.items);\n\n    const graphicAttributes = this.transformElementItems(this.items, this.mark.markType);\n\n    if (attrs) {\n      if (this.mark.isCollectionMark()) {\n        // todo `defined` should not be a channel in line/area\n        delete attrs.defined;\n      }\n\n      Object.assign(graphicAttributes, attrs);\n    }\n\n    if (!this.graphicItem) {\n      this.initGraphicItem(graphicAttributes);\n    } else {\n      this.graphicItem.clearStates();\n      // 更新数据流后，states计算不缓存\n      this.graphicItem.states = {};\n      this.graphicItem.stateProxy = null;\n\n      this.applyGraphicAttributes(graphicAttributes);\n    }\n\n    if ((this.diffState === DiffState.enter || this.diffState === DiffState.update) && this.states.length) {\n      this.useStates(this.states);\n    }\n\n    if (this.mark.markType === GrammarMarkType.shape) {\n      // FIXME: shape需要拿到原始数据进行编码，暂时把数据绑定到graphicItem上，看后续graphicItem是否需要支持数据绑定\n      (this.graphicItem as any).datum = this.items[0].datum;\n    }\n\n    // clear item attributes\n    this.items.forEach(item => {\n      item.nextAttrs = {};\n    });\n    this._setCustomizedShape();\n  }\n\n  private _setCustomizedShape() {\n    if (!this.graphicItem) {\n      return;\n    }\n    const setCustomizedShape = this.mark.getSpec()?.setCustomizedShape;\n\n    if (!setCustomizedShape) {\n      return;\n    }\n\n    this.graphicItem.pathProxy = (attrs: Partial<IGraphicAttribute>) => {\n      return setCustomizedShape(this.data, attrs, new CustomPath2D());\n    };\n  }\n\n  encodeItems(items: MarkElementItem[], encoders: BaseEncodeSpec, isReentered: boolean = false, parameters?: any) {\n    const isCollectionMark = this.mark.isCollectionMark();\n    // marshall encoder functions\n    const updateEncoder = encoders[BuiltInEncodeNames.update];\n    const enterEncoder = encoders[BuiltInEncodeNames.enter];\n    const exitEncoder = encoders[BuiltInEncodeNames.exit];\n    const onlyFullEncodeFirst = this.mark.isLargeMode() || (isCollectionMark && !this.mark.getSpec().enableSegments);\n\n    if (this.diffState === DiffState.enter) {\n      if (enterEncoder) {\n        invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst);\n      }\n      if (updateEncoder) {\n        invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst);\n      }\n    } else if (this.diffState === DiffState.update) {\n      // if mark is reentered or mark is collection type, evaluate enter encode\n      if ((isCollectionMark && enterEncoder) || isReentered) {\n        invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst);\n      }\n      if (updateEncoder) {\n        invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst);\n      }\n    } else if (this.diffState === DiffState.exit && exitEncoder) {\n      // if mark is reentered, evaluate enter encode\n      if (isReentered) {\n        invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst);\n      }\n      invokeEncoderToItems(this, items, exitEncoder, parameters, onlyFullEncodeFirst);\n    }\n  }\n\n  protected coordinateTransformEncode(items: MarkElementItem[]) {\n    if (!this.mark.coord || this.mark.markType === 'arc' || this.mark.disableCoordinateTransform === true) {\n      return;\n    }\n    const coord = this.mark.coord.output() as IBaseCoordinate;\n\n    items.forEach(item => {\n      const nextAttrs = item.nextAttrs;\n      const convertedPoint: IPointLike = coord.convert(nextAttrs);\n      Object.assign(nextAttrs, convertedPoint);\n    });\n  }\n\n  clearStates(hasAnimation?: boolean) {\n    const stateAnimationEnable = isBoolean(hasAnimation)\n      ? hasAnimation\n      : this.mark.animate.getAnimationConfigs('state').length !== 0;\n\n    this.states = [];\n\n    if (this.graphicItem) {\n      this.graphicItem.clearStates(stateAnimationEnable);\n    }\n\n    if (this.runtimeStatesEncoder) {\n      this.runtimeStatesEncoder = {};\n    }\n  }\n\n  private _updateRuntimeStates(state: string, attrs: any) {\n    if (!this.runtimeStatesEncoder) {\n      this.runtimeStatesEncoder = {};\n    }\n\n    this.runtimeStatesEncoder[state] = attrs;\n  }\n\n  hasState(state: string) {\n    return this.states && state && this.states.includes(state);\n  }\n\n  addState(state: string | string[], attrs?: BaseSingleEncodeSpec) {\n    if (!this.graphicItem) {\n      return false;\n    }\n\n    const isRuntimeStateUpdate = attrs && isString(state) && !isObjEqual(attrs, this.runtimeStatesEncoder?.[state]);\n    if (isRuntimeStateUpdate) {\n      const nextStates = this.states.slice();\n      if (!nextStates.includes(state)) {\n        nextStates.push(state);\n      } else {\n        this.graphicItem.clearStates();\n      }\n      this._updateRuntimeStates(state, attrs);\n\n      this.useStates(nextStates);\n      return true;\n    }\n\n    const encode = (this.mark.getSpec() as MarkSpec).encode;\n    const states = array(state);\n    const nextStates = states.reduce((nextStates: string[], stateName: string) => {\n      if (stateName && !nextStates.includes(stateName) && encode?.[stateName]) {\n        nextStates.push(stateName);\n      }\n      return nextStates;\n    }, this.states.slice());\n\n    if (nextStates.length !== this.states.length) {\n      this.useStates(nextStates);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  removeState(state: string | string[]) {\n    if (!this.graphicItem) {\n      return false;\n    }\n\n    const states = array(state);\n\n    if (!states.length) {\n      return false;\n    }\n\n    const nextStates = this.states.filter(state => !states.includes(state));\n    if (nextStates.length === this.states.length) {\n      return false;\n    }\n\n    if (this.runtimeStatesEncoder) {\n      states.forEach(state => {\n        this.runtimeStatesEncoder[state] = null;\n      });\n    }\n    this.useStates(nextStates);\n\n    return true;\n  }\n\n  protected getStateAttrs = (stateName: string, nextStates: string[]) => {\n    const isRuntimeState = !isNil(this.runtimeStatesEncoder?.[stateName]);\n    const encoder = isRuntimeState\n      ? this.runtimeStatesEncoder[stateName]\n      : (this.mark.getSpec() as MarkSpec).encode?.[stateName];\n\n    if (!encoder) {\n      return {};\n    }\n\n    if (isFunction(encoder)) {\n      return (encoder as StateProxyEncodeSpec)(this.getDatum(), this, stateName, nextStates);\n    }\n\n    if (!isRuntimeState && this.graphicItem.states?.[stateName]) {\n      return this.graphicItem.states[stateName];\n    }\n\n    const stateItems = this.items.map(item => Object.assign({}, item, { nextAttrs: {} }));\n    // collection图元，暂时不支持在state更新中，支持更新points更新\n    invokeEncoderToItems(this, stateItems, encoder, (this.mark as any).parameters());\n\n    const graphicAttributes = this.transformElementItems(stateItems, this.mark.markType);\n\n    if (!this.graphicItem.states) {\n      this.graphicItem.states = { [stateName]: graphicAttributes };\n    } else if (!this.graphicItem.states[stateName]) {\n      this.graphicItem.states[stateName] = graphicAttributes;\n    }\n\n    return graphicAttributes;\n  };\n\n  useStates(states: string[], hasAnimation?: boolean) {\n    if (!this.graphicItem) {\n      return false;\n    }\n    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, { states }, this);\n\n    const stateSort = this.mark.getSpec()?.stateSort;\n\n    if (stateSort) {\n      states.sort(stateSort);\n    }\n    this.states = states;\n\n    const stateAnimationEnable = isBoolean(hasAnimation)\n      ? hasAnimation\n      : this.mark.animate.getAnimationConfigs('state').length !== 0;\n\n    this.graphicItem.stateProxy = this.getStateAttrs;\n    this.graphicItem.useStates(this.states, stateAnimationEnable);\n\n    this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, { states }, this);\n\n    return true;\n  }\n\n  protected diffAttributes(graphicAttributes: { [channel: string]: any }) {\n    const diffResult = {};\n    const finalGraphicAttributes = this.getFinalGraphicAttributes();\n    for (const key in graphicAttributes) {\n      if (!isEqual(key, finalGraphicAttributes, graphicAttributes) || !has(finalGraphicAttributes, key)) {\n        diffResult[key] = graphicAttributes[key];\n      }\n    }\n    return diffResult;\n  }\n\n  /**\n   * tranform the attribute to graphic attribute\n   * @param items\n   * @param markType   In ordinary, markType is equal to mark.markType, but in glyph, markType is different from mark.markType\n   * @param markName\n   * @param computePoints\n   * @returns\n   */\n  transformElementItems(items: MarkElementItem[], markType: MarkType, computePoints?: boolean): Record<string, any> {\n    const item = items[0];\n\n    if (!item.nextAttrs || Object.keys(item.nextAttrs).length === 0) {\n      return {};\n    }\n\n    let nextAttrs = item.nextAttrs;\n\n    if (\n      isPointsMarkType(markType) &&\n      items &&\n      items.length &&\n      isNil(item.nextAttrs?.points) &&\n      (computePoints === true || isValidPointsChannel(Object.keys(item.nextAttrs), this.mark.markType))\n    ) {\n      const lastPoints = this.getGraphicAttribute('points', false);\n      const lastSegments = this.getGraphicAttribute('segments', false);\n      const enableSegments = this.mark.getSpec().enableSegments;\n      const itemNextAttrs = items.map(item => item.nextAttrs);\n      const isProgressive = this.mark.isProgressive();\n      nextAttrs = parseCollectionMarkAttributes(nextAttrs);\n\n      if (markType === GrammarMarkType.line || markType === GrammarMarkType.area) {\n        const linePoints = getLinePoints(items, true, lastPoints, markType === GrammarMarkType.area);\n\n        // chartspace新增了配置，用于开启线段解析；渐进渲染状态不支持线段样式\n        if (enableSegments && !isProgressive) {\n          const points = !linePoints || linePoints.length === 0 ? getLinePointsFromSegments(lastSegments) : linePoints;\n          const segments = getLineSegmentConfigs(itemNextAttrs, points, this);\n\n          if (segments) {\n            nextAttrs.segments = segments;\n            nextAttrs.points = null;\n          } else {\n            nextAttrs.segments = null;\n            nextAttrs.points = points;\n          }\n        } else if (isProgressive) {\n          nextAttrs.segments = ((this.graphicItem as ILine)?.attribute?.segments ?? []).concat([\n            { points: linePoints }\n          ]);\n        } else {\n          nextAttrs.points = linePoints;\n          nextAttrs.segments = null;\n        }\n      } else if (markType === GrammarMarkType.largeRects) {\n        nextAttrs.points = getLargeRectsPoints(items, true, lastPoints);\n      } else if (markType === GrammarMarkType.largeSymbols) {\n        nextAttrs.points = getLargeSymbolsPoints(items, true, lastPoints);\n      }\n    }\n\n    return nextAttrs;\n  }\n\n  protected applyGraphicAttributes(graphicAttributes: any) {\n    if (isEmpty(graphicAttributes)) {\n      return;\n    }\n\n    if (this.mark.needAnimate()) {\n      // If mark need animate, diff attributes.\n      const nextGraphicAttributes = this.diffAttributes(graphicAttributes);\n      const prevGraphicAttributes = this.getPrevGraphicAttributes() ?? {};\n      const finalGraphicAttributes = this.getFinalGraphicAttributes() ?? {};\n\n      Object.keys(nextGraphicAttributes).forEach(channel => {\n        prevGraphicAttributes[channel] = this.getGraphicAttribute(channel);\n        finalGraphicAttributes[channel] = nextGraphicAttributes[channel];\n      });\n      this.setNextGraphicAttributes(nextGraphicAttributes);\n      this.setPrevGraphicAttributes(prevGraphicAttributes);\n      this.setFinalGraphicAttributes(finalGraphicAttributes);\n\n      const currentAnimators = this.mark.animate.getElementAnimators(this);\n      const animateGraphicAttributes = currentAnimators.reduce((attributes, animator) => {\n        return Object.assign(attributes, animator.getEndAttributes());\n      }, {});\n      const currentGraphicAttributes = Object.assign({}, animateGraphicAttributes, finalGraphicAttributes);\n\n      // Apply next attributes to current graphic item immediately.\n      // Scene graph tree should be handled like no animation exists in dataflow procedure.\n      this.graphicItem.setAttributes(currentGraphicAttributes);\n    } else {\n      // Otherwise, directly apply all attributes.\n      this.graphicItem.setAttributes(graphicAttributes);\n    }\n  }\n\n  getGraphicAttribute(channel: string, prev: boolean = false) {\n    if (!this.graphicItem) {\n      return undefined;\n    }\n\n    if (prev) {\n      let value: any;\n      const prevGraphicAttributes = this.getPrevGraphicAttributes();\n      if (!isNil((value = get(prevGraphicAttributes, channel)))) {\n        return value;\n      }\n    }\n\n    // get attribute before transformed\n    const trans = this.mark.getAttributeTransforms();\n    let getKey: string[] = [channel];\n    if (trans && trans.length) {\n      const channelTransform = trans.find(entry => {\n        return entry.storedAttrs && entry.channels.includes(channel);\n      });\n\n      if (channelTransform) {\n        getKey = [channelTransform.storedAttrs, channel];\n      }\n    }\n    return get(this.graphicItem?.attribute, getKey);\n  }\n\n  setGraphicAttribute(channel: string, value: any, final: boolean = true) {\n    if (!this.graphicItem) {\n      return;\n    }\n    const finalGraphicAttributes = this.getFinalGraphicAttributes();\n    const prevGraphicAttributes = this.getPrevGraphicAttributes();\n\n    if (final && finalGraphicAttributes) {\n      finalGraphicAttributes[channel] = value;\n    }\n    if (prevGraphicAttributes && !has(prevGraphicAttributes, channel)) {\n      prevGraphicAttributes[channel] = this.graphicItem.attribute[channel];\n    }\n\n    this.graphicItem.setAttribute(channel, value);\n  }\n\n  setGraphicAttributes(attributes: { [channel: string]: any }, final: boolean = true) {\n    if (!this.graphicItem) {\n      return;\n    }\n    const finalGraphicAttributes = this.getFinalGraphicAttributes();\n    const prevGraphicAttributes = this.getPrevGraphicAttributes();\n\n    Object.keys(attributes).forEach(key => {\n      if (finalGraphicAttributes && final) {\n        finalGraphicAttributes[key] = attributes[key];\n      }\n      if (prevGraphicAttributes && !has(prevGraphicAttributes, key)) {\n        prevGraphicAttributes[key] = this.graphicItem.attribute[key];\n      }\n    });\n\n    this.graphicItem.setAttributes(attributes);\n  }\n\n  /**\n   * 获取 vRender 已变更的视觉通道属性，只应当由 VGrammar 中 调用\n   * @returns 视觉通道键值对\n   */\n  getFinalGraphicAttributes() {\n    return (this.graphicItem as any).finalAttrs;\n  }\n\n  protected setFinalGraphicAttributes(attributes: { [channel: string]: any }) {\n    (this.graphicItem as any).finalAttrs = attributes;\n  }\n\n  /**\n   * 获取 vRender 变更前的视觉通道属性，只应当由 VGrammar 调用\n   * @returns 视觉通道键值对\n   */\n  getPrevGraphicAttributes() {\n    return (this.graphicItem as any).prevAttrs;\n  }\n\n  protected setPrevGraphicAttributes(attributes: { [channel: string]: any }) {\n    (this.graphicItem as any).prevAttrs = attributes;\n  }\n\n  /**\n   * 获取 vRender 在单次 dataflow 中变更的视觉通道属性，只应当由 VGrammar 调用\n   * @returns 视觉通道键值对\n   */\n  getNextGraphicAttributes() {\n    return (this.graphicItem as any).nextAttrs;\n  }\n\n  protected setNextGraphicAttributes(attributes: { [channel: string]: any }) {\n    (this.graphicItem as any).nextAttrs = attributes;\n  }\n\n  clearChangedGraphicAttributes() {\n    if (this.graphicItem) {\n      this.setPrevGraphicAttributes(null);\n      this.setNextGraphicAttributes(null);\n    }\n  }\n\n  clearGraphicAttributes() {\n    if (this.graphicItem) {\n      (this.graphicItem as any).prevAttrs && this.setPrevGraphicAttributes(null);\n      (this.graphicItem as any).nextAttrs && this.setNextGraphicAttributes(null);\n      (this.graphicItem as any).finalAttrs && this.setFinalGraphicAttributes(null);\n    }\n  }\n\n  remove() {\n    if (this.graphicItem) {\n      removeGraphicItem(this.graphicItem);\n      this.graphicItem = null;\n    }\n  }\n\n  release() {\n    this.removeGraphicItem();\n    this.mark = null;\n    this.data = null;\n    this.items = null;\n  }\n  /**\n   * hack support for transform & encode logic. DO NOT USE.\n   */\n  getItemAttribute(channel?: string) {\n    if (!this.items?.length) {\n      return;\n    }\n\n    if (this.mark.isCollectionMark()) {\n      return isNil(channel)\n        ? this.items.map(item => item.nextAttrs)\n        : this.items.map(item => item.nextAttrs?.[channel]);\n    }\n\n    return isNil(channel) ? this.items[0].nextAttrs : this.items[0].nextAttrs?.[channel];\n  }\n  setItemAttributes(attributes: { [channel: string]: any } | any[]) {\n    if (!this.items?.length) {\n      return;\n    }\n\n    if (this.mark.isCollectionMark()) {\n      if (isArray(attributes)) {\n        this.items.forEach((item, index) => {\n          Object.assign(item.nextAttrs, attributes[index]);\n        });\n      }\n    } else {\n      Object.assign(this.items[0].nextAttrs, attributes);\n    }\n  }\n  /**\n   * hack support for transform & encode logic. DO NOT USE.\n   */\n  getItem() {\n    return this.mark.isCollectionMark() ? this.items ?? [] : this.items?.[0];\n  }\n  getDatum() {\n    return this.mark.isCollectionMark() ? this.data ?? [] : this.data?.[0];\n  }\n}\n"]}