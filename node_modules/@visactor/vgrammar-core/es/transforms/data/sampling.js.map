{"version":3,"sources":["../src/transforms/data/sampling.ts"],"names":[],"mappings":"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","file":"sampling.js","sourcesContent":["import { maxInArray, minInArray } from '@visactor/vutils';\nimport type { SampleTransformOptions } from '../../types';\nimport { average, sum } from '../util/util';\n\nconst samplerMap = {\n  min: minInArray,\n  max: maxInArray,\n  average: average,\n  sum: sum\n};\n\nfunction lttb(size: number, array: any[], isGroup: boolean, yfield: string) {\n  const frameSize = Math.floor(array.length / size);\n  const newIndices = [];\n  const len = array.length;\n\n  let currentIndex = 0;\n  let sampledIndex = 0;\n  let maxArea;\n  let area;\n  let nextIndex;\n\n  // First frame use the first data.\n  newIndices[sampledIndex++] = currentIndex;\n\n  for (let i = 1; i < len - 1; i += frameSize) {\n    const nextFrameStart = Math.min(i + frameSize, len - 1);\n    const nextFrameEnd = Math.min(i + frameSize * 2, len);\n\n    const avgX = (nextFrameEnd + nextFrameStart) / 2;\n    let avgY = 0;\n\n    for (let idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n      const value = array[idx][yfield];\n      if (Number.isNaN(value)) {\n        continue;\n      }\n      avgY += value;\n    }\n    avgY /= nextFrameEnd - nextFrameStart;\n\n    const frameStart = i;\n    const frameEnd = Math.min(i + frameSize, len);\n\n    const pointAX = i - 1;\n    const pointAY = array[currentIndex][yfield];\n\n    maxArea = -1;\n\n    nextIndex = frameStart;\n    // Find a point from current frame that construct a triangel with largest area with previous selected point\n    // And the average of next frame.\n    for (let idx = frameStart; idx < frameEnd; idx++) {\n      const value = array[idx][yfield];\n      if (Number.isNaN(yfield)) {\n        continue;\n      }\n      // Calculate triangle area over three buckets\n      area = Math.abs((pointAX - avgX) * (value - pointAY) - (pointAX - idx) * (avgY - pointAY));\n      if (area > maxArea) {\n        maxArea = area;\n        nextIndex = idx; // Next a is this b\n      }\n    }\n\n    newIndices[sampledIndex++] = nextIndex;\n\n    currentIndex = nextIndex; // This a is the next a (chosen b)\n  }\n\n  // First frame use the last data.\n  if (newIndices[sampledIndex - 1] !== len - 1) {\n    newIndices[sampledIndex++] = len - 1;\n  }\n\n  // output newly added tuples\n  const newRawIndices = newIndices.map(i => (isGroup ? array[i].i : i));\n  return newRawIndices;\n}\n\nfunction sample(size: number, array: any[], isGroup: boolean, mode: 'min' | 'max' | 'average' | 'sum', yfield: string) {\n  let frameSize = Math.floor(array.length / size);\n  const newIndices = [];\n  const len = array.length;\n  let sampledIndex = 0;\n  let frameValues = [];\n\n  newIndices.push(sampledIndex);\n  array[sampledIndex][yfield] = array[sampledIndex][yfield];\n\n  for (let i = 1; i < len - 1; i += frameSize) {\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n    frameValues = [];\n    for (let k = 0; k < frameSize; k++) {\n      frameValues.push(array[i + k][yfield]);\n    }\n    const value = samplerMap[mode](frameValues);\n    sampledIndex = Math.min(Math.round(i + frameValues.length / 2) || 0, len - 1);\n    array[sampledIndex][yfield] = value;\n    newIndices.push(sampledIndex);\n  }\n  const newRawIndices = newIndices.map(i => (isGroup ? array[i].i : i));\n  return newRawIndices;\n}\n\nfunction sampleMin(size: number, array: any[], isGroup: boolean, yfield: string) {\n  return sample(size, array, isGroup, 'min', yfield);\n}\n\nfunction sampleMax(size: number, array: any[], isGroup: boolean, yfield: string) {\n  return sample(size, array, isGroup, 'max', yfield);\n}\n\nfunction sampleAverage(size: number, array: any[], isGroup: boolean, yfield: string) {\n  return sample(size, array, isGroup, 'average', yfield);\n}\n\nfunction sampleSum(size: number, array: any[], isGroup: boolean, yfield: string) {\n  return sample(size, array, isGroup, 'sum', yfield);\n}\n\n/**\n * Samples tuples passing through this operator.\n * mode: 'lttb' - Uses lttb sampling to maintain a trend-maintained sample.\n * mode: 'min' | 'max' | 'average' | 'sum' - Uses aggregation methods to location sample points.\n * @constructor\n * @param {object} options - The parameters for this operator.\n * @param {number} [options.size=1000] - The maximum number of samples.\n * @param {string} [options.yfield] - The yfield string of data.\n * @param {string} [options.groupBy] - The groupBy string of data.\n */\n\nexport const transform = (options: SampleTransformOptions, upstreamData: any[]) => {\n  let size = options.size;\n  const factor = options.factor || 1;\n\n  if (Array.isArray(size)) {\n    size = Math.floor(size[1] - size[0]);\n  }\n\n  size *= factor;\n\n  // size<=0的特殊情况不采样，返回空\n  if (size <= 0) {\n    return [];\n  }\n\n  // 数据<size的情况，不进行采样，保留所有数据\n  if (upstreamData.length <= size) {\n    return upstreamData;\n  }\n\n  const skipfirst = options.skipfirst;\n  // 如果是ChartSpace的第一次数据流(evaluateAsync)，不需要采样，返回一条数据供布局使用\n  // 这里需要依据this.value.length判断是不是第一次数据流，\n  // 以避免点击图例，updateChartData等操作清空所有label\n  if (skipfirst) {\n    return upstreamData.slice(0, 1);\n  }\n\n  const { mode, yfield: y, groupBy } = options;\n  const yfield = y ?? 'y';\n\n  // 采样方法\n  let sampler = lttb;\n  if (mode === 'min') {\n    sampler = sampleMin;\n  } else if (mode === 'max') {\n    sampler = sampleMax;\n  } else if (mode === 'average') {\n    sampler = sampleAverage;\n  } else if (mode === 'sum') {\n    sampler = sampleSum;\n  }\n\n  // 处理数据source，source为采样前的原始数据\n  if (upstreamData.length) {\n    // 如果有groupBy，数据分组\n    const groups = {};\n    if (groupBy) {\n      for (let i = 0, n = upstreamData.length; i < n; i++) {\n        const datum = upstreamData[i];\n        const groupId = datum[groupBy];\n        if (groups[groupId]) {\n          groups[groupId].push({ [yfield]: datum[yfield], i });\n        } else {\n          groups[groupId] = [];\n          groups[groupId].push({ [yfield]: datum[yfield], i });\n        }\n      }\n\n      // 分组采样\n      let rawIndice: any[] = [];\n\n      Object.keys(groups).forEach(groupName => {\n        const group = groups[groupName];\n        if (group.length <= size) {\n          const indices = group.map((datum: any) => {\n            return datum.i;\n          });\n          rawIndice = rawIndice.concat(indices);\n        } else {\n          const indices = sampler(size, group, true, yfield);\n          rawIndice = rawIndice.concat(indices);\n          group.forEach((datum: any) => (upstreamData[datum.i][yfield] = datum[yfield]));\n        }\n      });\n\n      // 采样后，按照原始顺序排序\n      rawIndice.sort((a, b) => a - b);\n\n      return rawIndice.map((index: number) => upstreamData[index]);\n    }\n    return sampler(size, upstreamData, false, yfield).map(index => upstreamData[index]);\n  }\n\n  return [];\n};\n"]}