{"version":3,"sources":["../src/types/grammar.ts"],"names":[],"mappings":"","file":"grammar.js","sourcesContent":["import type { EventEmitter, IBounds, IPointLike } from '@visactor/vutils';\nimport type { IGraphic, IGroup } from '@visactor/vrender-core';\nimport type { IBaseScale, ScaleFishEyeOptions, TickData } from '@visactor/vscale';\nimport type { ITransform, TransformSpec } from './transform';\nimport type { DataFormatSpec, IDataFilter } from './data';\nimport type { ParameterFunctionType, SignalFunctionType } from './signal';\nimport type { IAnimate } from './animate';\nimport type { IGlyphMeta } from './glyph';\nimport type { GrammarTypeEnum } from '../graph/enums';\nimport type { Nil } from './base';\nimport type { CoordinateFunctionType } from './coordinate';\nimport type { IElement } from './element';\nimport type {\n  MarkFunctionType,\n  MarkAnimationSpec,\n  MarkType,\n  MarkLayoutSpec,\n  MarkLayoutCallback,\n  MarkSortSpec,\n  MarkKeySpec,\n  IMarkConfig,\n  ChannelEncodeType,\n  AttributeTransform,\n  BaseSingleEncodeSpec\n} from './mark';\nimport type { ScaleConfigureSpec, ScaleData, ScaleFunctionType, GrammarScaleType, MultiScaleData } from './scale';\nimport type { IView } from './view';\nimport type { BaseEventHandler } from './event';\nimport type { ICartesianCoordinate, IPolarCoordinate } from '@visactor/vgrammar-coordinate';\n\nexport type BuiltInGrammarType = keyof typeof GrammarTypeEnum;\nexport type GrammarType = BuiltInGrammarType | string;\n\n/** 语法元素内置运行的任务 */\nexport interface IGrammarTask extends ITransform {\n  /**\n   * 参数依赖\n   * 只做一级解析\n   */\n  options?: Record<string, any | IGrammarBase> | (IGrammarBase | any)[];\n  /**\n   * 依赖的语法元素\n   */\n  references?: IGrammarBase[];\n  /**\n   * 是否只支持简单的options配置，不支持在options引用语法元素\n   */\n  isRawOptions?: boolean;\n}\n\nexport interface GrammarSpec {\n  id?: string;\n  dependency?: IGrammarBase[] | IGrammarBase | string[] | string;\n}\n\nexport interface IGrammarBase {\n  readonly grammarType: GrammarType;\n  readonly view: IView;\n  readonly uid: number;\n  /**\n   * 执行的上游节点\n   */\n  grammarSource: IGrammarBase;\n  /**\n   * 影响的下游节点\n   */\n  targets: IGrammarBase[];\n  /**\n   * 依赖的上游节点，由于不同 spec 配置项中可能引用同一个节点，需要进行计数\n   */\n  references: Map<IGrammarBase, number>;\n\n  depend: (grammar: IGrammarBase[] | IGrammarBase | string[] | string) => this;\n\n  addEventListener: (type: string, handler: BaseEventHandler, options?: any) => this;\n  removeEventListener: (type: string, handler: BaseEventHandler) => this;\n\n  // extended from EventEmitter\n  emit: <T extends EventEmitter.EventNames<string | symbol>>(\n    event: T,\n    ...args: EventEmitter.EventArgs<string | symbol, T>\n  ) => boolean;\n  emitGrammarEvent: <T extends EventEmitter.EventNames<string | symbol>>(\n    event: T,\n    ...args: EventEmitter.EventArgs<string | symbol, T>\n  ) => boolean;\n\n  tasks?: IGrammarTask[];\n  // value?: any;\n  /** FIXME: operator执行顺序，改造后，dataflow执行元素，应该抽象出来 */\n  rank?: number;\n  // todo\n  set: (value: any) => boolean;\n  id: (() => string) & ((id: string) => this);\n  name: (() => string) & ((name: string) => this);\n  attach: (reference: IGrammarBase | IGrammarBase[], count?: number) => this;\n  detach: (reference: IGrammarBase | IGrammarBase[], count?: number) => this;\n  detachAll: () => void;\n  commit: () => void;\n  output: () => any;\n  parse: (spec: any) => this;\n  parameters: () => { [key: string]: any };\n  evaluateSync?: (upstream: any, parameters: any) => this;\n  getSpec: () => any;\n  reuse: (grammar: IGrammarBase) => this;\n  /** clear references */\n  clear: () => void;\n  /** release all memory storage */\n  release: () => void;\n}\n\nexport interface IData extends IGrammarBase {\n  values: (values: any | Nil, format?: ParameterFunctionType<DataFormatSpec>, load?: boolean) => this;\n  url: (\n    url: ParameterFunctionType<string> | Nil,\n    format?: ParameterFunctionType<DataFormatSpec>,\n    load?: boolean\n  ) => this;\n  source: (\n    source: string | string[] | IData | IData[],\n    format?: ParameterFunctionType<DataFormatSpec>,\n    load?: boolean\n  ) => this;\n  transform: (transform: TransformSpec[] | Nil) => this;\n\n  // only used in VGrammar\n  addDataFilter: (filter: IDataFilter | IDataFilter[]) => this;\n  removeDataFilter: (filter: IDataFilter | IDataFilter[]) => this;\n\n  // data util methods\n  field: (field: string) => any[];\n  getValue: () => any[];\n  getInput: () => any[];\n  getDataIDKey: () => string;\n}\n\n/** 语法元素,TODO */\nexport interface ISignal<T> extends IGrammarBase {\n  value: (value: T | Nil) => this;\n  update: (update: SignalFunctionType<T> | Nil) => this;\n\n  getValue: () => T;\n}\n\n/** 语法元素,TODO */\nexport interface IScale extends IGrammarBase {\n  domain: (domain: ScaleFunctionType<any[]> | ScaleData | MultiScaleData | Nil) => this;\n  range: (range: ScaleFunctionType<any[]> | ScaleData | MultiScaleData | Nil) => this;\n  configure: (config: ScaleConfigureSpec | Nil) => this;\n  tickCount: (tickCount: ScaleFunctionType<number> | Nil) => this;\n\n  // only used in VGrammar\n  getRangeFactor: () => [number, number] | Nil;\n  setRangeFactor: (range?: [number, number]) => this;\n  getFishEye: () => ScaleFishEyeOptions | Nil;\n  setFishEye: (option?: ScaleFishEyeOptions) => this;\n\n  // scale util methods\n  getScaleType: () => GrammarScaleType;\n  getScale: () => IBaseScale;\n  ticks: (count?: number) => TickData[];\n  getCoordinateAxisPoints: (baseValue?: number) => [IPointLike, IPointLike];\n  getCoordinate: () => IPolarCoordinate | ICartesianCoordinate;\n  getCoordinateAxisPosition: () => 'top' | 'bottom' | 'left' | 'right' | 'inside' | 'outside' | 'start' | 'end';\n}\n\nexport interface ICoordinate extends IGrammarBase {\n  start: (start: CoordinateFunctionType<[number, number]> | Nil) => this;\n  end: (end: CoordinateFunctionType<[number, number]> | Nil) => this;\n  origin: (origin: CoordinateFunctionType<[number, number]> | Nil) => this;\n\n  translate: (offset: CoordinateFunctionType<[number, number]> | Nil) => this;\n  rotate: (angle: CoordinateFunctionType<number> | Nil) => this;\n  scale: (ratio: CoordinateFunctionType<[number, number]> | Nil) => this;\n  transpose: (isTransposed: CoordinateFunctionType<boolean> | Nil) => this;\n\n  // coordinate util methods\n}\n\n/** 语法元素,TODO */\n\n/** group mark */\nexport interface IGroupMark extends IMark {\n  children: (IMark | IGroupMark | IGlyphMark)[];\n\n  layoutChildren?: (IMark | IGroupMark | IGlyphMark)[];\n\n  appendChild: (mark: IMark | IGroupMark | IGlyphMark) => this;\n  removeChild: (mark: IMark | IGroupMark | IGlyphMark) => this;\n  includesChild: (mark: IMark, descendant?: boolean) => boolean;\n\n  updateLayoutChildren: () => this;\n}\n\nexport interface IGlyphMark extends IMark {\n  glyphType: string;\n  getGlyphMeta: () => IGlyphMeta;\n  configureGlyph: (config: any) => this;\n  getGlyphConfig: () => any;\n}\n\nexport interface IComponent extends IMark {\n  componentType: string;\n  configureComponent: (config: any) => this;\n}\n\nexport interface IProgressiveGrammar {\n  /** 是否启动了增量渲染模式 */\n  isProgressive: () => boolean;\n  /** 是否正在执行增量渲染 */\n  isDoingProgressive: () => boolean;\n  /** 清除增量渲染相关状态 */\n  clearProgressive: () => void;\n  /** 从第一帧开始增量计算 */\n  restartProgressive: () => void;\n  /** 分片执行 */\n  evaluateProgressive: () => void;\n}\n\nexport interface IMark extends IGrammarBase, IProgressiveGrammar {\n  group?: IGroupMark;\n\n  markType: MarkType;\n  coord: ICoordinate;\n  /**\n   * disable coordinate transform when need\n   */\n  disableCoordinateTransform?: boolean;\n  elements: IElement[];\n  elementMap: Map<string, IElement>;\n  graphicIndex: number;\n  graphicItem?: IGroup;\n  animate?: IAnimate;\n\n  join: (\n    data: IData | string | Nil,\n    key?: MarkKeySpec,\n    sort?: MarkSortSpec,\n    groupBy?: MarkKeySpec,\n    groupSort?: MarkSortSpec\n  ) => this;\n  coordinate: (coordinate: ICoordinate | string | Nil) => this;\n  state: (state: MarkFunctionType<string | string[]> | Nil) => this;\n  encode: ((encoders: BaseSingleEncodeSpec, clear?: boolean) => this) &\n    ((channel: string, value: ChannelEncodeType, clear?: boolean) => this);\n  encodeState: ((state: string, channel: string, value: ChannelEncodeType, clear?: boolean) => this) &\n    ((state: string, encoders: BaseSingleEncodeSpec, clear?: boolean) => this);\n  animation: (animationConfig: MarkAnimationSpec | Nil) => this;\n  animationState: (animationState: MarkFunctionType<string> | Nil) => this;\n  layout: (layout: MarkLayoutSpec | MarkLayoutCallback | Nil) => this;\n  configure: (config: IMarkConfig | Nil) => this;\n  context: (context: any) => this;\n  transform: (transform: TransformSpec[] | Nil) => this;\n\n  needAnimate: () => boolean;\n  getBounds: () => IBounds;\n  isCollectionMark: () => boolean;\n  getAllElements: () => IElement[];\n  getContext: () => any;\n\n  // position: () => this;\n  // color: () => this;\n  // shape: () => this;\n\n  // mark 执行流程相关接口\n\n  isUpdated: boolean;\n  getGroupGraphicItem: () => any;\n  cleanExitElements: () => void;\n  addGraphicItem: (attrs: any, groupKey?: string) => IGraphic;\n  getMorphConfig: () => { morph: boolean; morphKey: string | undefined; morphElementKey: string | undefined };\n  prepareRelease: () => void;\n\n  layoutBounds?: IBounds;\n  relativePosition?: { top?: number; bottom?: number; left?: number; right?: number };\n  needLayout: () => boolean;\n  handleLayoutEnd: () => void;\n  handleRenderEnd: () => void;\n  isLargeMode: () => boolean;\n  getAttributeTransforms: () => AttributeTransform[];\n\n  getScalesByChannel: () => Record<string, IBaseScale> | undefined;\n  getFieldsByChannel: () => Record<string, string> | undefined;\n  getScales: () => Record<string, IBaseScale> | undefined;\n}\n\nexport interface IGrammarBaseConstructor<T extends string = any> {\n  new (view: IView, grammarType: T): IGrammarBase;\n}\n\nexport interface ProgressiveContext {\n  currentIndex: number;\n  totalStep: number;\n  step: number;\n  data: any[];\n  groupKeys?: string[];\n  groupedData?: Map<string, any[]>;\n}\n"]}