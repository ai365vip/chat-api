{"version":3,"sources":["../src/types/transform.ts"],"names":[],"mappings":"","file":"transform.js","sourcesContent":["import type { FieldGetterFunction, LayoutViewBox } from '@visactor/vgrammar-util';\nimport type { SignalFunction, SignalReference } from './signal';\nimport type { IView } from './view';\nimport type { IData } from './grammar';\nimport type { SortConfigSpec } from './data';\n\nexport type TransformSpecValue =\n  | {\n      /** transform will depend a signal grammar instance as params */\n      signal?: string;\n      /** transform will depend a scale grammar instance as params, this should only be used in the transform of mark */\n      scale?: string;\n      /** transform will depend a data grammar instance as params, this should only be used in the transform of mark */\n      data?: string;\n      /** transform will depend a customized grammar instance as params, this should only be used in the transform of mark */\n      customized?: string;\n    }\n  | any;\n\nexport type TransformFunctionCallback<T> = (parameters: any) => T;\n\nexport type TransformFunctionType<T> = T | SignalReference<T> | SignalFunction<TransformFunctionCallback<T>, T>;\n\nexport type ConvertTransformOptionToSpec<TransformOptionType> = {\n  [Key in keyof TransformOptionType]?: TransformFunctionType<TransformOptionType[Key]>;\n};\n\nexport interface BinTransformOption {\n  field: string;\n  extent: [number, number];\n  step?: number;\n  bins?: number;\n  as?: [string, string];\n}\n\nexport interface ContourTransformOption {\n  field: string;\n  row: number;\n  column: number;\n  thresholds?: number[];\n  levels?: number;\n  asThreshold?: string;\n  asPoints?: string;\n}\n\nexport interface FilterTransformOption {\n  callback: (entry: any, params: any) => boolean;\n}\n\nexport interface FunnelTransformOption {\n  /** the field to of measure */\n  field: string;\n  /** the filed of transform ration(the value of next level/ the value of current level)**/\n  asTransformRatio?: string;\n  /**  the filed of reach ration(the value of current level/ the value of prev level)）*/\n  asReachRatio?: string;\n  /** the field of height ratio **/\n  asHeightRatio?: string;\n  /** the field of value ration(this value of current level / this value of first level ) */\n  asValueRatio?: string;\n  /** the field of last value ratio(the value of last level / this value of first level) */\n  asLastValueRatio?: string;\n  /** the field of next value ratio(the value of next level / this value of first level) */\n  asNextValueRatio?: string;\n  /** the field of current value */\n  asCurrentValue?: string;\n  /** the field of last value **/\n  asLastValue?: string;\n  /** the field of next value **/\n  asNextValue?: string;\n  /** whether or not the last level of the funnel is  a cone */\n  isCone?: boolean;\n  /** whether or not the height will be encode to value**/\n  heightVisual?: boolean;\n\n  /** the range of value */\n  range?: { min: number; max: number };\n}\n\nexport interface JoinTransformOption {\n  from?: any[];\n  key: string;\n  fields: string[];\n  values?: string[];\n  as?: string[];\n  default?: any;\n}\n\nexport interface KDETransformOption {\n  dimension?: '1d' | '2d';\n  field: string | string[];\n  bandwidth?: number;\n  extent?: [number, number] | [{ x: number; y: number }, { x: number; y: number }];\n  bins?: number | number[];\n  as?: string[];\n}\n\nexport interface MapTransformOption {\n  callback: (entry: any, params?: any) => any;\n  as?: string;\n  all?: boolean;\n}\n\nexport interface PickTransformOption {\n  as?: string[];\n  fields: string[] | FieldGetterFunction[];\n}\n\nexport interface PieTransformOption {\n  field: string;\n  startAngle?: number;\n  endAngle?: number;\n  asStartAngle?: string;\n  asEndAngle?: string;\n  asMiddleAngle?: string;\n  asRadian?: string;\n  asRatio?: string;\n  asQuadrant?: string;\n  asK?: string;\n}\n\nexport interface RangeTransformOptions {\n  start: number;\n  stop: number;\n  step?: number;\n  as?: string;\n}\n\nexport interface SortTransformOptions {\n  sort: SortConfigSpec | ((a: any, b: any) => number);\n}\n\nexport interface FoldTransformOptions {\n  fields: string[];\n  asKey?: string;\n  asValue?: string;\n  retains?: string[];\n}\n\nexport interface UnfoldTransformOptions {\n  groupBy?: string[] | string;\n  keyField: string;\n  valueField: string;\n  aggregateType?: 'sum' | 'min' | 'max' | 'count' | 'mean';\n}\n\nexport interface StackTransformOptions {\n  // TODO: provide more order option referring to d3-shape\n  order?: 'positive' | 'negative';\n  offset?: 'none' | 'diverging' | 'silhouette' | 'wiggle';\n  stackField: string;\n  dimensionField: string;\n  asStack?: string;\n  asPrevStack?: string;\n  asPercent?: string;\n  asPercentStack?: string;\n  asPrevPercentStack?: string;\n  asSum?: string;\n}\n\nexport interface DodgeTransformOptions {\n  /**\n   * the gap for two graphic elements\n   */\n  innerGap?: number | string;\n  /**\n   * only used for rect / interval mark\n   */\n  maxWidth?: number;\n  minWidth?: number;\n  /** the gap between two category */\n  categoryGap?: number | string;\n  /**\n   * specify the field to dodge, if this field is not specified, we'll use the `groupKey` of Element to dodge\n   */\n  dodgeBy?: string | string[];\n  /**\n   * specify the channel to dodge, if this field is not specified, we'll use the channel which is associated to a band scale\n   */\n  dodgeChannel?: 'x' | 'y';\n}\n\nexport interface JitterTransformOptions {\n  bandWidth?: number;\n  bandHeight?: number;\n  widthRatio?: number;\n  heightRatio?: number;\n  random?: (index?: number, total?: number) => number;\n}\n\nexport interface JitterXTransformOptions {\n  bandWidth?: number;\n  widthRatio?: number;\n  random?: (index?: number, total?: number) => number;\n}\nexport interface JitterYTransformOptions {\n  bandHeight?: number;\n  heightRatio?: number;\n  random?: (index?: number, total?: number) => number;\n}\n\nexport type CircularRelationTransformOptions = LayoutViewBox & {\n  field: string;\n  radiusField?: string;\n  radiusRange?: [number, number];\n  center?: [string | number, string | number];\n  startAngle?: number;\n  endAngle?: number;\n  innerRadius?: string | number;\n  outerRadius?: string | number;\n};\n\nexport interface CircularRelationItem {\n  x: number;\n  y: number;\n  radius: number;\n  datum: any;\n}\n\nexport interface IdentifierTransformOptions {\n  as: string;\n}\n\nexport interface MarkOverlapTransformOptions {\n  direction: number;\n  delta?: number;\n  deltaMul?: number;\n  radius?: boolean;\n  hideMode?: number;\n  forceUpdate?: boolean;\n  forceUpdateStamp?: number;\n  groupBy?: string;\n}\n\nexport interface SampleTransformOptions {\n  size: number;\n  factor?: number;\n  skipfirst?: boolean;\n  yfield?: string;\n  groupBy?: string;\n  mode?: 'lttb' | 'min' | 'max' | 'average' | 'sum';\n}\n\nexport interface SymmetryTransformOptions {\n  channel?: 'x' | 'y';\n  align?: 'min' | 'max';\n}\n\nexport interface BinTransformSpec extends BinTransformOption {\n  type: 'bin';\n}\n\nexport interface ContourTransformSpec extends ContourTransformOption {\n  type: 'contour';\n}\n\nexport interface FilterTransformSpec extends ConvertTransformOptionToSpec<FilterTransformOption> {\n  type: 'filter';\n}\n\nexport interface FunnelTransformSpec extends FunnelTransformOption {\n  type: 'funnel';\n}\n\nexport interface PieTransformSpec extends PieTransformOption {\n  type: 'pie';\n}\n\nexport interface JoinTransformSpec extends ConvertTransformOptionToSpec<Omit<JoinTransformOption, 'from'>> {\n  type: 'join';\n  from?: TransformFunctionType<JoinTransformOption['from']> | { data: string | IData };\n}\n\nexport interface KDETransformSpec extends KDETransformOption {\n  type: 'kde';\n}\n\nexport interface MapTransformSpec extends ConvertTransformOptionToSpec<Omit<MapTransformOption, 'callback'>> {\n  type: 'map';\n  callback: MapTransformOption['callback'];\n}\n\nexport interface PickTransformSpec extends ConvertTransformOptionToSpec<PickTransformOption> {\n  type: 'pick';\n}\nexport interface RangeTransformSpec extends ConvertTransformOptionToSpec<RangeTransformOptions> {\n  type: 'range';\n}\n\nexport interface SortTransformSpec extends ConvertTransformOptionToSpec<SortTransformOptions> {\n  type: 'sort';\n}\nexport interface StackTransformSpec extends ConvertTransformOptionToSpec<StackTransformOptions> {\n  type: 'stack';\n}\nexport interface DodgeTransformSpec extends ConvertTransformOptionToSpec<DodgeTransformOptions> {\n  type: 'dodge';\n}\n\nexport interface IdentifierTransformSpec extends ConvertTransformOptionToSpec<IdentifierTransformOptions> {\n  type: 'identifier';\n}\n\nexport interface MarkOverlapTransformSpec extends ConvertTransformOptionToSpec<MarkOverlapTransformOptions> {\n  type: 'markoverlap';\n}\nexport interface SampleTransformSpec extends ConvertTransformOptionToSpec<SampleTransformOptions> {\n  type: 'sampling';\n}\n\nexport interface JitterTransformSpec extends ConvertTransformOptionToSpec<JitterTransformOptions> {\n  type: 'jitter';\n}\n\nexport interface JitterXTransformSpec extends ConvertTransformOptionToSpec<JitterXTransformOptions> {\n  type: 'jitterX';\n}\n\nexport interface JitterYTransformSpec extends ConvertTransformOptionToSpec<JitterYTransformOptions> {\n  type: 'jitterY';\n}\n\nexport type CircularRelationTransformSpec = ConvertTransformOptionToSpec<CircularRelationTransformOptions> & {\n  type: 'circularRelation';\n};\n\nexport interface FoldTransformSpec extends ConvertTransformOptionToSpec<FoldTransformOptions> {\n  type: 'fold';\n}\n\nexport interface UnfoldTransformSpec extends ConvertTransformOptionToSpec<UnfoldTransformOptions> {\n  type: 'unfold';\n}\n\nexport interface SymmetryTransformSpec extends ConvertTransformOptionToSpec<SymmetryTransformOptions> {\n  type: 'symmetry';\n}\n\nexport interface BaseTransformSpec {\n  /** the type of transform */\n  type: string;\n  [key: string]: TransformSpecValue | TransformSpecValue[];\n}\n\nexport type TransformSpec =\n  | FilterTransformSpec\n  | FunnelTransformSpec\n  | PieTransformSpec\n  | JoinTransformSpec\n  | MapTransformSpec\n  | PickTransformSpec\n  | RangeTransformSpec\n  | SortTransformSpec\n  | StackTransformSpec\n  | DodgeTransformSpec\n  | IdentifierTransformSpec\n  | BaseTransformSpec\n  | MarkOverlapTransformSpec\n  | SampleTransformSpec\n  | JitterTransformSpec\n  | JitterXTransformSpec\n  | JitterYTransformSpec\n  | CircularRelationTransformSpec\n  | FoldTransformSpec\n  | UnfoldTransformSpec;\n\nexport interface IProgressiveTransformResult<Output = any> {\n  /** is progressive finished */\n  unfinished: () => boolean;\n  /** return all the result */\n  output: () => Output;\n  /** the output result of current progressive run */\n  progressiveOutput: () => Output;\n  /** run in progressive mode */\n  progressiveRun: () => void;\n  /** release the progressive context */\n  release: () => void;\n}\n\nexport interface IProgressiveTransform<Output = any> {\n  progressive: IProgressiveTransformResult<Output>;\n}\n\nexport type IFunctionTransform<Options = any, Input = any, Output = any> = (\n  options?: Options,\n  data?: Input,\n  params?: Record<string, any>,\n  view?: IView\n) => Output | Promise<Output> | IProgressiveTransformResult<Output>;\nexport interface ITransform<Options = any, Input = any, Output = any> {\n  type: string;\n  markPhase?: 'beforeJoin' | 'afterEncode' | 'afterEncodeItems';\n  /** 是否支持渐进流程 */\n  canProgressive?: boolean;\n  /** transform function */\n  transform: IFunctionTransform<Options, Input, Output>;\n  isBuiltIn?: boolean;\n}\n"]}