{"version":3,"sources":["../src/types/mark.ts"],"names":[],"mappings":"","file":"mark.js","sourcesContent":["import type {\n  ICustomPath2D,\n  IPyramid3dGraphicAttribute,\n  IArc3dGraphicAttribute,\n  IRect3dGraphicAttribute,\n  ISymbolAttribute,\n  IRectGraphicAttribute,\n  ILineGraphicAttribute,\n  ICircleGraphicAttribute,\n  IArcGraphicAttribute,\n  IPolygonGraphicAttribute,\n  IAreaGraphicAttribute,\n  IGlyphGraphicAttribute,\n  IImageGraphicAttribute,\n  IPathGraphicAttribute,\n  ISymbolGraphicAttribute,\n  ITextGraphicAttribute,\n  IGraphicAttribute,\n  IGroupGraphicAttribute,\n  IRichTextGraphicAttribute\n} from '@visactor/vrender-core';\nimport type { Bounds, IPointLike } from '@visactor/vutils';\nimport type { IAnimationConfig, IStateAnimationConfig } from './animate';\nimport type { IElement } from './element';\nimport type { IMark, IScale, IGroupMark, ICoordinate, GrammarSpec, IData } from './grammar';\nimport type { GenericFunctionType } from './signal';\nimport type { TransformSpec } from './transform';\nimport type { CommonPaddingSpec } from './base';\nimport type { ILayoutOptions, IView } from './view';\nimport type {\n  AxisSpec,\n  BuiltInComponentSpec,\n  DatazoomSpec,\n  LabelSpec,\n  LegendSpec,\n  PlayerSpec,\n  SliderSpec\n} from './component';\nimport type { GrammarMarkType } from '../graph/enums';\n\nexport type MarkFunctionCallback<T> = (datum: any, element: IElement, parameters: any) => T;\n\nexport type MarkFunctionType<T> = GenericFunctionType<MarkFunctionCallback<T>, T>;\n\nexport type MarkType = keyof typeof GrammarMarkType | string;\n\nexport interface MarkFromSpec {\n  data: string | IData;\n  transform?: {\n    name: string;\n    transform?: TransformSpec[];\n  };\n}\n\nexport type MarkStateSpec = MarkFunctionType<string | string[]>;\n\nexport type ScaleEncodeType = {\n  scale: IScale | string;\n  field?: string | ((datum: any) => any) | string[] | ((datum: any) => any)[];\n  value?: any;\n  band?: number;\n  offset?: number;\n};\n\nexport type FieldEncodeType = {\n  field: string | ((datum: any) => any) | string[] | ((datum: any) => any)[];\n};\n\nexport type ChannelEncodeType<T = any> = MarkFunctionType<T> | ScaleEncodeType | FieldEncodeType;\n\nexport type GenerateEncoderSpec<T> = {\n  [Key in keyof T]?: ChannelEncodeType<T[Key]>;\n};\n\n/**\n *  the common channel supported by graphic marks\n */\nexport type GenerateBasicEncoderSpec<T> = Partial<\n  Omit<\n    T,\n    | 'strokeSeg'\n    | 'boundsPadding'\n    | 'pickMode'\n    | 'boundsMode'\n    | 'customPickShape'\n    | 'pickable'\n    | 'childrenPickable'\n    | 'visible'\n    | 'zIndex'\n    | 'layout'\n    | 'keepDirIn3d'\n    | 'postMatrix'\n    | 'anchor'\n    | 'anchor3d'\n  >\n>;\n\nexport type BasicEncoderSpecMap = {\n  rect: GenerateBasicEncoderSpec<IRectGraphicAttribute & { y1?: number; x1?: number }>;\n  line: Omit<GenerateBasicEncoderSpec<ILineGraphicAttribute>, 'points' | 'segments'>;\n  circle: GenerateBasicEncoderSpec<ICircleGraphicAttribute>;\n  arc: GenerateBasicEncoderSpec<IArcGraphicAttribute>;\n  polygon: GenerateBasicEncoderSpec<IPolygonGraphicAttribute>;\n  arc3d: GenerateBasicEncoderSpec<IArc3dGraphicAttribute>;\n  pyramid3d: GenerateBasicEncoderSpec<IPyramid3dGraphicAttribute>;\n  area: Omit<GenerateBasicEncoderSpec<IAreaGraphicAttribute>, 'points' | 'segments'>;\n  group: GenerateBasicEncoderSpec<IGroupGraphicAttribute>;\n  glyph: GenerateBasicEncoderSpec<IGlyphGraphicAttribute & any>;\n  image: GenerateBasicEncoderSpec<IImageGraphicAttribute>;\n  rect3d: GenerateBasicEncoderSpec<IRect3dGraphicAttribute>;\n  path: GenerateBasicEncoderSpec<IPathGraphicAttribute>;\n  rule: Omit<GenerateBasicEncoderSpec<ILineGraphicAttribute>, 'points' | 'segments'> & { x1?: number; y1?: number };\n  shape: GenerateBasicEncoderSpec<IPathGraphicAttribute>;\n  symbol: GenerateBasicEncoderSpec<ISymbolGraphicAttribute> & {\n    shape?: ISymbolGraphicAttribute['symbolType'];\n    image?: ISymbolGraphicAttribute['background'];\n  };\n  text: GenerateBasicEncoderSpec<ITextGraphicAttribute> & {\n    limit?: number;\n    autoLimit?: number;\n  };\n  richtext: GenerateBasicEncoderSpec<IRichTextGraphicAttribute>;\n  interval: Omit<GenerateBasicEncoderSpec<IRectGraphicAttribute>, 'width' | 'height'> & {\n    /**\n     * the gap for two graphic elements\n     */\n    innerGap?: number | string;\n    /**\n     * only used for rect / interval mark\n     */\n    maxWidth?: number;\n    minWidth?: number;\n    /** the gap between two category */\n    categoryGap?: number | string;\n  };\n  cell: GenerateBasicEncoderSpec<ISymbolGraphicAttribute> & {\n    padding?: number | [number, number];\n    shape?: ISymbolAttribute['symbolType'];\n  };\n};\nexport type GenerateBaseEncodeSpec<BasicSpec = GenerateBasicEncoderSpec<IGraphicAttribute>> =\n  | GenerateEncoderSpec<BasicSpec>\n  | MarkFunctionCallback<BasicSpec>;\n\nexport type StateProxyEncodeSpec<T = any> = (datum: any, element: IElement, state: string, nextStates: string[]) => T;\n\nexport type StateEncodeSpec<BasicSpec = GenerateBasicEncoderSpec<IGraphicAttribute>> =\n  | {\n      enter?: GenerateBaseEncodeSpec<BasicSpec>;\n      update?: GenerateBaseEncodeSpec<BasicSpec>;\n      exit?: GenerateBaseEncodeSpec<BasicSpec>;\n    }\n  | {\n      [state: string]: GenerateEncoderSpec<BasicSpec> | StateProxyEncodeSpec<BasicSpec>;\n    };\n\nexport type MarkAnimationSpec = Record<string, IAnimationConfig | IAnimationConfig[]> & {\n  state?: IStateAnimationConfig;\n};\n\n// TODO: support string[]\nexport type MarkKeySpec = string | ((datum: any) => string);\n\nexport type MarkSortSpec = (datumA: any, datumB: any) => number;\n\nexport type MarkStateSortSpec = (stateA: string, stateB: string) => number;\n\nexport interface MarkGridContainerSpec extends MarkBaseLayoutSpec {\n  display: 'grid';\n  gridTemplateRows?: (number | string | 'auto')[];\n  gridTemplateColumns?: (number | string | 'auto')[];\n  gridRowGap?: number;\n  gridColumnGap?: number;\n}\n\nexport interface MarkGridItemSpec extends MarkBaseLayoutSpec {\n  gridRowStart?: number;\n  gridRowEnd?: number;\n  gridColumnStart?: number;\n  gridColumnEnd?: number;\n}\n\nexport interface MarkBaseLayoutSpec {\n  callback?: MarkLayoutCallback;\n  skipBeforeLayouted?: boolean;\n  updateViewSignals?: boolean;\n}\n\nexport interface MarkRelativeItemSpec extends MarkBaseLayoutSpec {\n  position?: 'top' | 'bottom' | 'left' | 'right' | 'content' | 'auto' | string;\n  padding?: CommonPaddingSpec;\n  align?: 'left' | 'right' | 'center' | 'top' | 'bottom' | 'middle';\n  order?: number;\n}\n\nexport interface MarkRelativeContainerSpec extends MarkBaseLayoutSpec {\n  display: 'relative';\n  maxChildWidth?: string | number;\n  maxChildHeight?: string | number;\n}\n\nexport type MarkLayoutSpec =\n  | MarkGridContainerSpec\n  | MarkGridItemSpec\n  | MarkRelativeContainerSpec\n  | MarkRelativeItemSpec;\n\nexport type MarkLayoutCallback = (\n  group: IGroupMark,\n  children: IMark[],\n  parentLayoutBounds: Bounds,\n  options?: ILayoutOptions\n) => void;\n\nexport interface IMarkConfig {\n  clip?: boolean;\n  zIndex?: number;\n  interactive?: boolean;\n  context?: any;\n  skipTheme?: boolean;\n  /**\n   * set customized shape\n   */\n  setCustomizedShape?: (datum: any[], attrs: any, path: ICustomPath2D) => ICustomPath2D;\n  /** 是否开启大数据渲染模式 */\n  large?: boolean;\n  /** 开启大数据渲染优化的阀值，对应的是data的长度 */\n  largeThreshold?: number;\n  /** 分片长度 */\n  progressiveStep?: number;\n  /** 开启分片渲染的阀值，对应的是单系列data的长度 */\n  progressiveThreshold?: number;\n  /**\n   * use 'sequential' for symbol chart\n   * use 'mod' for bar/line chart\n   */\n  // largeChunkMode?: 'sequential' | 'mod';\n  support3d?: boolean;\n  /**\n   * enable global morphing animation of the mark\n   */\n  morph?: boolean;\n  /**\n   * this key will be used to match the mark to morph\n   */\n  morphKey?: string;\n  /**\n   * this key will be used to match the element of two marks to morph\n   * If not specified, we'll use the \"key\" of the mark by default\n   */\n  morphElementKey?: string;\n  /** transforms of attributes */\n  attributeTransforms?: AttributeTransform[];\n  /**\n   * only used in line/area mark\n   * TODO\n   */\n  enableSegments?: boolean;\n}\n\n/**\n * Base mark specification type\n */\nexport interface GenerateMarkSpec<T extends MarkType = string, P = any> extends IMarkConfig, GrammarSpec {\n  type: T;\n  name?: string;\n  group?: string | IGroupMark;\n  // data attributes\n  from?: MarkFromSpec;\n  key?: MarkKeySpec;\n  /**\n   * sort all the elements in the mark\n   */\n  sort?: MarkSortSpec;\n  /**\n   * set the group key of the mark\n   */\n  groupBy?: MarkKeySpec;\n  /**\n   * sort the data of each group\n   */\n  groupSort?: MarkSortSpec;\n  context?: any;\n  // coordinate attributes\n  coordinate?: string | ICoordinate;\n  // encode attributes\n  state?: MarkStateSpec;\n  stateSort?: MarkStateSortSpec;\n  encode?: GetEncoderSpecByType<T, P>;\n  // animation attributes\n  animationState?: MarkFunctionType<string>;\n  animation?: MarkAnimationSpec;\n  transform?: TransformSpec[];\n  layout?: MarkLayoutSpec | MarkLayoutCallback;\n}\n\nexport type CircleMarkSpec = GenerateMarkSpec<'circle'>;\nexport type ArcMarkSpec = GenerateMarkSpec<'arc'>;\nexport type AreaMarkSpec = GenerateMarkSpec<'area'>;\nexport type LineMarkSpec = GenerateMarkSpec<'line'>;\nexport type RectMarkSpec = GenerateMarkSpec<'rect'>;\nexport type ImageMarkSpec = GenerateMarkSpec<'image'>;\nexport type PathMarkSpec = GenerateMarkSpec<'path'>;\nexport type RuleMarkSpec = GenerateMarkSpec<'rule'>;\nexport type ShapeMarkSpec = GenerateMarkSpec<'shape'>;\nexport type SymbolMarkSpec = GenerateMarkSpec<'symbol'>;\nexport type TextMarkSpec = GenerateMarkSpec<'text'>;\nexport type RichTextMarkSpec = GenerateMarkSpec<'richtext'>;\nexport type PolygonMarkSpec = GenerateMarkSpec<'polygon'>;\nexport type CellMarkSpec = GenerateMarkSpec<'cell'>;\nexport type IntervalMarkSpec = GenerateMarkSpec<'interval'>;\nexport type Arc3dMarkSpec = GenerateMarkSpec<'arc3d'>;\nexport type Pyramid3dMarkSpec = GenerateMarkSpec<'pyramid3d'>;\nexport type Rect3dMarkSpec = GenerateMarkSpec<'rect3d'>;\n\nexport type BasicGlyphEncoderSpec = BasicEncoderSpecMap['glyph'];\nexport type BasicGroupEncoderSpec = BasicEncoderSpecMap['group'];\nexport interface GroupMarkSpec extends GenerateMarkSpec<'group'> {\n  marks?: MarkSpec[];\n}\n\nexport interface GlyphMarkSpec<CustomizedEncoderSpec = any> extends GenerateMarkSpec<'glyph', CustomizedEncoderSpec> {\n  glyphType: string;\n  glyphConfig?: any;\n}\n\nexport interface BoxPlotEncoderSpec extends BasicGlyphEncoderSpec {\n  boxWidth?: number;\n  boxHeight?: number;\n  ruleWidth?: number;\n  ruleHeight?: number;\n  q1?: number;\n  q3?: number;\n  min?: number;\n  max?: number;\n  median?: number;\n  angle?: number;\n  anchor?: [number, number];\n}\n\nexport interface BarBoxPlotEncoderSpec extends BasicGlyphEncoderSpec {\n  minMaxWidth?: number;\n  q1q3Width?: number;\n  minMaxHeight?: number;\n  q1q3Height?: number;\n  q1?: number;\n  q3?: number;\n  min?: number;\n  max?: number;\n  median?: number;\n  angle?: number;\n  lineWidth?: number;\n  minMaxFillOpacity?: number;\n  anchor?: [number, number];\n}\n\nexport interface LinkPathEncoderSpec extends BasicGlyphEncoderSpec {\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n  thickness: number;\n  curvature?: number;\n  /** round all the coordinates */\n  round?: boolean;\n  /** the ratio of normal style path */\n  ratio?: number;\n  align?: 'start' | 'end' | 'center';\n  pathType?: 'line' | 'smooth' | 'polyline';\n  endArrow?: boolean;\n  startArrow?: boolean;\n  backgroundStyle?: any;\n  direction?: 'horizontal' | 'vertical' | 'LR' | 'RL' | 'TB' | 'BL' | 'radial';\n}\nexport interface TreePathEncoderSpec extends BasicGlyphEncoderSpec {\n  x0: number;\n  y0: number;\n  x1: number;\n  y1: number;\n  curvature?: number;\n  /** round all the coordinates */\n  round?: boolean;\n  /** the ratio of normal style path */\n  align?: 'start' | 'end' | 'center';\n  pathType?: 'line' | 'smooth' | 'polyline';\n  startArrowStyle?: Partial<IGraphicAttribute>;\n  endArrowStyle?: Partial<IGraphicAttribute>;\n  endArrow?: boolean;\n  startArrow?: boolean;\n  arrowSize?: number;\n  backgroundStyle?: any;\n  direction?: 'horizontal' | 'vertical' | 'LR' | 'RL' | 'TB' | 'BL' | 'radial';\n}\n\nexport interface RipplePointEncoderSpec extends BasicGlyphEncoderSpec {\n  ripple?: number;\n  size?: number;\n}\n\nexport interface ViolinEncoderSpec extends BasicGlyphEncoderSpec {\n  violinFill: string;\n  violinStroke: string;\n  medianFill?: string;\n  density?: IPointLike[];\n  boxWidth?: number;\n  q1?: number;\n  q3?: number;\n  min?: number;\n  max?: number;\n  median?: number;\n  angle?: number;\n  anchor?: [number, number];\n}\n\nexport interface WaveEncoderSpec extends BasicGlyphEncoderSpec {\n  wave?: number;\n}\nexport interface BoxPlotGlyphSpec extends GlyphMarkSpec<BoxPlotEncoderSpec> {\n  glyphType: 'boxplot';\n}\nexport interface BarBoxPlotGlyphSpec extends GlyphMarkSpec<BarBoxPlotEncoderSpec> {\n  glyphType: 'barBoxplot';\n}\nexport interface LinkPathGlyphSpec extends GlyphMarkSpec<LinkPathEncoderSpec> {\n  glyphType: 'linkPath';\n}\nexport interface TreePathGlyphSpec extends GlyphMarkSpec<TreePathEncoderSpec> {\n  glyphType: 'treePath';\n}\nexport interface RipplePointGlyphSpec extends GlyphMarkSpec<RipplePointEncoderSpec> {\n  glyphType: 'ripplePoint';\n}\nexport interface ViolinGlyphSpec extends GlyphMarkSpec<ViolinEncoderSpec> {\n  glyphType: 'violin';\n}\nexport interface WaveGlyphSpec extends GlyphMarkSpec<WaveEncoderSpec> {\n  glyphType: 'wave';\n}\n\nexport interface ComponentSpec<\n  BasicEncoderSpec extends GenerateBasicEncoderSpec<IGraphicAttribute> = GenerateBasicEncoderSpec<IGraphicAttribute>\n> extends GenerateMarkSpec<'component', BasicEncoderSpec> {\n  componentType: string;\n  componentConfig?: any;\n  mode?: '2d' | '3d';\n}\n\nexport type BaseMarkSpec = GenerateMarkSpec<MarkType>;\nexport type MarkSpecMap = {\n  circle: CircleMarkSpec;\n  arc: ArcMarkSpec;\n  area: AreaMarkSpec;\n  image: ImageMarkSpec;\n  line: LineMarkSpec;\n  path: PathMarkSpec;\n  rule: RuleMarkSpec;\n  shape: ShapeMarkSpec;\n  symbol: SymbolMarkSpec;\n  text: TextMarkSpec;\n  richtext: RichTextMarkSpec;\n  polygon: PolygonMarkSpec;\n  cell: CellMarkSpec;\n  interval: IntervalMarkSpec;\n  rect: RectMarkSpec;\n  rect3d: Rect3dMarkSpec;\n  arc3d: Arc3dMarkSpec;\n  pyramid3d: Pyramid3dMarkSpec;\n  group: GroupMarkSpec;\n  glyph: GlyphMarkSpec;\n  linkPath: LinkPathGlyphSpec;\n  treePath: TreePathGlyphSpec;\n  wave: WaveEncoderSpec;\n  ripplePoint: RipplePointGlyphSpec;\n  barBoxplot: BarBoxPlotGlyphSpec;\n  boxPlot: BoxPlotGlyphSpec;\n  component: ComponentSpec;\n  axis: AxisSpec;\n  legend: LegendSpec;\n  slider: SliderSpec;\n  datazoom: DatazoomSpec;\n  label: LabelSpec;\n  player: PlayerSpec;\n};\n\nexport type GetMarkSpecByType<T, P = any> = T extends keyof MarkSpecMap ? MarkSpecMap[T] : GenerateMarkSpec<string, P>;\nexport type GetBasicEncoderSpecByType<T, P = any> = T extends keyof BasicEncoderSpecMap\n  ? BasicEncoderSpecMap[T]\n  : GenerateBasicEncoderSpec<IGraphicAttribute & P>;\nexport type GetEncoderSpecByType<T, P = any> = T extends keyof BasicEncoderSpecMap\n  ? StateEncodeSpec<BasicEncoderSpecMap[T]>\n  : StateEncodeSpec<GenerateBasicEncoderSpec<IGraphicAttribute> & P>;\n\nexport type BaseEncodeSpec<P = any> = StateEncodeSpec<GenerateBasicEncoderSpec<IGraphicAttribute & P>>;\nexport type BaseSingleEncodeSpec<P = any> =\n  | GenerateEncoderSpec<GenerateBasicEncoderSpec<IGraphicAttribute & P>>\n  | StateProxyEncodeSpec<GenerateBasicEncoderSpec<IGraphicAttribute & P>>;\n\nexport type GetSingleEncodeSpecByType<T, P = any> = T extends keyof BasicEncoderSpecMap\n  ? GenerateEncoderSpec<BasicEncoderSpecMap[T]> | StateProxyEncodeSpec<BasicEncoderSpecMap[T]>\n  : BaseSingleEncodeSpec<P>;\n\nexport type MarkSpec =\n  | GenerateMarkSpec<string, any>\n  | CircleMarkSpec\n  | ArcMarkSpec\n  | AreaMarkSpec\n  | ImageMarkSpec\n  | LineMarkSpec\n  | PathMarkSpec\n  | RuleMarkSpec\n  | ShapeMarkSpec\n  | SymbolMarkSpec\n  | TextMarkSpec\n  | RichTextMarkSpec\n  | PolygonMarkSpec\n  | CellMarkSpec\n  | IntervalMarkSpec\n  | RectMarkSpec\n  | Rect3dMarkSpec\n  | Arc3dMarkSpec\n  | Pyramid3dMarkSpec\n  | GroupMarkSpec\n  | GlyphMarkSpec\n  | LinkPathGlyphSpec\n  | TreePathGlyphSpec\n  | WaveGlyphSpec\n  | RipplePointGlyphSpec\n  | BarBoxPlotGlyphSpec\n  | BoxPlotGlyphSpec\n  | ViolinGlyphSpec\n  | ComponentSpec\n  | BuiltInComponentSpec;\n\nexport interface AttributeTransform {\n  channels: string[];\n  transform: (graphicAttributes: any, nextAttrs: any, storedAttrs: any) => void;\n  storedAttrs?: string;\n}\n\nexport interface IMarkConstructor {\n  readonly markType: string;\n\n  new (view: IView, markType: MarkType, group?: IGroupMark): IMark;\n}\n"]}