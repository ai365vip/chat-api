{"version":3,"sources":["../src/types/element.ts"],"names":[],"mappings":"","file":"element.js","sourcesContent":["import type {\n  IArc,\n  IArc3d,\n  IArea,\n  ICircle,\n  IGlyph,\n  IGraphic,\n  IGroup,\n  IImage,\n  ILine,\n  IPath,\n  IPolygon,\n  IPyramid3d,\n  IRect,\n  IRect3d,\n  IRichText,\n  ISymbol,\n  IText\n} from '@visactor/vrender-core';\nimport type { DiffState } from '../graph/enums';\nimport type { IMark, IGlyphMark } from './grammar';\nimport type { BaseEncodeSpec, IMarkConfig, MarkFunctionType, MarkKeySpec, MarkType } from './mark';\n\nexport interface ElementGraphicMap {\n  circle: ICircle;\n  arc: IArc;\n  area: IArea;\n  image: IImage;\n  line: ILine;\n  path: IPath;\n  rule: ILine;\n  shape: IPath;\n  symbol: ISymbol;\n  text: IText;\n  richtext: IRichText;\n  polygon: IPolygon;\n  cell: ISymbol;\n  interval: IGraphic;\n  rect: IRect;\n  rect3d: IRect3d;\n  arc3d: IArc3d;\n  pyramid3d: IPyramid3d;\n  group: IGroup;\n  glyph: IGlyph;\n  linkPath: IGlyph;\n  treePath: IGlyph;\n  wave: IGlyph;\n  ripplePoint: IGlyph;\n  barBoxplot: IGlyph;\n  boxPlot: IGlyph;\n  component: IGroup;\n  axis: IGroup;\n  legend: IGroup;\n  corsshair: IGroup;\n  slider: IGroup;\n  datazoom: IGroup;\n  label: IGroup;\n  player: IGroup;\n}\n\nexport type GetGraphicByType<T> = T extends keyof ElementGraphicMap ? ElementGraphicMap[T] : IGraphic;\n\n/**\n * 保存graphicItem状态\n */\nexport interface MarkElementItem {\n  /** 唯一key */\n  key: string;\n  /** 原始数据 */\n  datum: any;\n  /** VGrammar view */\n  view: any;\n  /** 当前渲染帧下graphicItem对应的最新属性 */\n  nextAttrs?: any;\n  /** 是否初始化过，用于解决collection mark对应的item，可能跳过enter状态的问题 */\n  // hasEntered: boolean;\n}\nexport interface IElement {\n  mark: IMark;\n  isReserved: boolean;\n  diffState: DiffState;\n  key: string;\n  groupKey?: string;\n  data?: any[];\n  /**\n   * 不推荐使用，但是collection图元暂时可能回涉及到相关修改\n   */\n  items: MarkElementItem[];\n\n  initGraphicItem: (attrs?: any) => void;\n  updateGraphicItem: (config: IMarkConfig) => void;\n\n  getDatum: () => any;\n  getBounds: () => any;\n  getGraphicItem: () => IGraphic;\n  removeGraphicItem: () => void;\n  resetGraphicItem: () => void;\n\n  /**\n   * 获取 graphic 视觉通道属性\n   * @param channel 视觉通道\n   * @param prev 是否从之前的 graphic 属性上获取，默认为 false\n   * @returns 视觉通道值\n   */\n  getGraphicAttribute: (channel: string, prev?: boolean) => any;\n  /**\n   * 设置 graphic 视觉通道属性\n   * @param channel 视觉通道\n   * @param value 视觉通道属性\n   * @param final 是否更新 graphic 最终变更的视觉通道结果，默认为 false\n   */\n  setGraphicAttribute: (channel: string, value: any, final?: boolean) => void;\n  /**\n   * 设置一系列 graphic 视觉通道属性\n   * @param attributes 视觉通道键值对\n   * @param final 是否更新 graphic 最终变更的视觉通道结果，默认为 false\n   */\n  setGraphicAttributes: (attributes: { [channel: string]: any }, final?: boolean) => void;\n\n  /**\n   * 【慎重使用】获取 VGrammar 自身的视觉通道属性\n   * 只有在 'afterEncodeItems' 时机的mark transform中才能调用\n   */\n  getItemAttribute: (channel?: string) => any;\n  /**\n   * 【慎重使用】设置 VGrammar 自身的视觉通道\n   * 只有在 'afterEncodeItems' 时机的mark transform中才能调用\n   * @param attributes\n   * @returns\n   */\n  setItemAttributes: (attributes: { [channel: string]: any } | any[]) => void;\n\n  // element 执行流程相关接口\n  updateData: (groupKey: string, data: any[], keyGenerator: MarkKeySpec, view: any) => void;\n  state: (markState: MarkFunctionType<string | string[]>, parameters?: any) => void;\n  encodeItems: (items: MarkElementItem[], encoders: BaseEncodeSpec, isReentered?: boolean, parameters?: any) => void;\n  encodeGraphic: (attributes?: any) => void;\n  transformElementItems: (items: MarkElementItem[], markType: MarkType, computePoints?: boolean) => Record<string, any>;\n  remove: () => void;\n  release: () => void;\n\n  // 动画相关接口\n\n  getFinalGraphicAttributes: () => { [key: string]: any };\n  getPrevGraphicAttributes: () => { [key: string]: any };\n  getNextGraphicAttributes: () => { [key: string]: any };\n  clearChangedGraphicAttributes: () => void;\n  clearGraphicAttributes: () => void;\n\n  // state相关接口\n  getStates: () => string[];\n  hasState: (state: string) => boolean;\n  clearStates: (noAnimation?: boolean) => void;\n  addState: (state: string | string[], attrs?: any) => boolean;\n  removeState: (state: string | string[]) => boolean;\n  useStates: (states: string[], noAnimation?: boolean) => boolean;\n}\n\nexport interface IGlyphElement<P = any> extends IElement {\n  mark: IGlyphMark;\n\n  getGlyphGraphicItems: () => { [markName: string]: any };\n\n  getGraphicAttribute: (channel: string, prev?: boolean, markName?: any) => any;\n  setGraphicAttribute: (channel: string, value: any, final?: boolean, markName?: any) => void;\n  setGraphicAttributes: (attributes: { [channel: string]: any }, final?: boolean, markName?: any) => void;\n\n  getFinalGraphicAttributes: (markName?: string) => { [key: string]: any };\n  getPrevGraphicAttributes: (markName?: string) => { [key: string]: any };\n  getNextGraphicAttributes: (markName?: string) => { [key: string]: any };\n\n  encodeCustom: (nextAttrs?: any) => { [markName: string]: any };\n}\n"]}