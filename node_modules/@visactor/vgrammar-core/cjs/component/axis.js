"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerAxis = exports.Axis = exports.generateCoordinateAxisAttribute = exports.generateCircleAxisAttributes = exports.generateLineAxisAttributes = void 0;

const vutils_1 = require("@visactor/vutils"), vrender_components_1 = require("@visactor/vrender-components"), enums_1 = require("../graph/enums"), scale_1 = require("./scale"), encode_1 = require("../graph/mark/encode"), util_1 = require("../parse/util"), factory_1 = require("../core/factory"), generateLineAxisAttributes = (scale, theme, addition, tickCount) => {
    var _a, _b, _c, _d;
    const axisTheme = null !== (_b = null === (_a = null == theme ? void 0 : theme.components) || void 0 === _a ? void 0 : _a.axis) && void 0 !== _b ? _b : {};
    if (!scale) return (0, vutils_1.merge)({}, axisTheme, null != addition ? addition : {});
    const items = [ (null !== (_d = null === (_c = scale.tickData) || void 0 === _c ? void 0 : _c.call(scale, tickCount)) && void 0 !== _d ? _d : []).map((tick => ({
        id: tick.index,
        label: tick.tick,
        value: tick.value,
        rawValue: tick.tick
    }))) ];
    return (0, vutils_1.merge)({}, axisTheme, {
        items: items
    }, null != addition ? addition : {});
};

exports.generateLineAxisAttributes = generateLineAxisAttributes;

const generateCircleAxisAttributes = (scale, theme, addition, tickCount) => {
    var _a, _b, _c, _d;
    const axisTheme = null !== (_b = null === (_a = null == theme ? void 0 : theme.components) || void 0 === _a ? void 0 : _a.circleAxis) && void 0 !== _b ? _b : {};
    if (!scale) return (0, vutils_1.merge)({}, axisTheme, null != addition ? addition : {});
    const items = [ (null !== (_d = null === (_c = scale.tickData) || void 0 === _c ? void 0 : _c.call(scale, tickCount)) && void 0 !== _d ? _d : []).map((tick => ({
        id: tick.index,
        label: tick.tick,
        value: tick.value,
        rawValue: tick.tick
    }))) ];
    return (0, vutils_1.merge)({}, axisTheme, {
        items: items
    }, null != addition ? addition : {});
};

exports.generateCircleAxisAttributes = generateCircleAxisAttributes;

const generateCoordinateAxisAttribute = (scale, coordinate, inside, baseValue, layout, isGrid) => {
    var _a;
    const axisPosition = scale.getCoordinateAxisPosition();
    layout && "auto" === layout.position && (layout.position = inside ? "content" : axisPosition);
    const axisPoints = scale.getCoordinateAxisPoints(baseValue);
    if (axisPoints) {
        const res = {
            start: axisPoints[0],
            end: axisPoints[1],
            verticalFactor: ("top" === axisPosition || "left" === axisPosition ? -1 : 1) * (inside ? -1 : 1) * ((null === (_a = scale.getSpec().range) || void 0 === _a ? void 0 : _a.reversed) ? -1 : 1)
        };
        if (isGrid && "polar" === coordinate.type) {
            const angle = coordinate.angle();
            res.center = coordinate.origin(), res.startAngle = angle[0], res.endAngle = angle[1];
        }
        return res;
    }
    const radius = coordinate.radius(), angle = coordinate.angle();
    return {
        center: coordinate.origin(),
        radius: radius[1],
        innerRadius: radius[0],
        inside: inside,
        startAngle: angle[0],
        endAngle: angle[1]
    };
};

exports.generateCoordinateAxisAttribute = generateCoordinateAxisAttribute;

class Axis extends scale_1.ScaleComponent {
    constructor(view, group, mode) {
        super(view, enums_1.ComponentEnum.axis, group), this.spec.componentType = enums_1.ComponentEnum.axis, 
        this.mode = mode;
    }
    parseAddition(spec) {
        return super.parseAddition(spec), this.axisType(spec.axisType), this.tickCount(spec.tickCount), 
        this.inside(spec.inside), this.baseValue(spec.baseValue), this;
    }
    scale(scale) {
        return super.scale(scale), this._axisComponentType = null, this;
    }
    axisType(axisType) {
        return this.spec.axisType = axisType, this._axisComponentType = null, this._prepareRejoin(), 
        this.commit(), this;
    }
    addGraphicItem(attrs, groupKey) {
        const initialAttributes = (0, vutils_1.merge)({
            x: 0,
            y: 0,
            start: {
                x: 0,
                y: 0
            },
            end: {
                x: 0,
                y: 0
            }
        }, attrs), graphicItem = factory_1.Factory.createGraphicComponent(this._getAxisComponentType(), initialAttributes, {
            mode: this.mode,
            skipDefault: this.spec.skipTheme
        });
        return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
    }
    tickCount(tickCount) {
        const scaleGrammar = (0, vutils_1.isString)(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
        return scaleGrammar && scaleGrammar.tickCount(tickCount), this.setFunctionSpec(tickCount, "tickCount");
    }
    inside(inside) {
        return this.setFunctionSpec(inside, "inside");
    }
    baseValue(baseValue) {
        return this.setFunctionSpec(baseValue, "baseValue");
    }
    getAxisComponentType() {
        return this._axisComponentType;
    }
    _updateComponentEncoders() {
        const scaleGrammar = (0, vutils_1.isString)(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, encoders = Object.assign({
            update: {}
        }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce(((res, state) => {
            const encoder = encoders[state];
            return encoder && (res[state] = {
                callback: (datum, element, parameters) => {
                    var _a, _b;
                    const theme = this.spec.skipTheme ? null : this.view.getCurrentTheme();
                    let addition = (0, encode_1.invokeEncoder)(encoder, datum, element, parameters);
                    const inside = (0, util_1.invokeFunctionType)(this.spec.inside, parameters, datum, element), baseValue = (0, 
                    util_1.invokeFunctionType)(this.spec.baseValue, parameters, datum, element), coordinate = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
                    coordinate && (addition = Object.assign((0, exports.generateCoordinateAxisAttribute)(scaleGrammar, coordinate, inside, baseValue, this.spec.layout), addition));
                    const scale = null === (_b = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _b ? void 0 : _b.call(scaleGrammar), tickCount = (0, 
                    util_1.invokeFunctionType)(this.spec.tickCount, parameters, datum, element);
                    switch (this._getAxisComponentType()) {
                      case enums_1.AxisEnum.lineAxis:
                        return (0, exports.generateLineAxisAttributes)(scale, theme, addition, tickCount);

                      case enums_1.AxisEnum.circleAxis:
                        return (0, exports.generateCircleAxisAttributes)(scale, theme, addition, tickCount);
                    }
                    return addition;
                }
            }), res;
        }), {});
        this._encoders = componentEncoders;
    }
    _getAxisComponentType() {
        var _a;
        if (this._axisComponentType) return this._axisComponentType;
        let type = this.spec.axisType;
        if ((0, vutils_1.isNil)(type)) {
            const scaleGrammar = (0, vutils_1.isString)(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
            type = (null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar)) ? scaleGrammar.getCoordinateAxisPoints() ? "line" : "circle" : "line";
        }
        return this._axisComponentType = "circle" === type ? enums_1.AxisEnum.circleAxis : enums_1.AxisEnum.lineAxis, 
        this._axisComponentType;
    }
}

exports.Axis = Axis, Axis.componentType = enums_1.ComponentEnum.axis;

const registerAxis = () => {
    factory_1.Factory.registerGraphicComponent(enums_1.AxisEnum.lineAxis, ((attrs, options) => new vrender_components_1.LineAxis(attrs, options))), 
    factory_1.Factory.registerGraphicComponent(enums_1.AxisEnum.circleAxis, (attrs => new vrender_components_1.CircleAxis(attrs))), 
    factory_1.Factory.registerComponent(enums_1.ComponentEnum.axis, Axis);
};

exports.registerAxis = registerAxis;
//# sourceMappingURL=axis.js.map