"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.transform = void 0;

const vutils_1 = require("@visactor/vutils"), HIDE_KEY = "_mo_hide_";

function reset(elements) {
    return elements.forEach((element => {
        element.getGraphicAttribute("HIDE_KEY") && (element.setGraphicAttribute("visible", !0), 
        element.setGraphicAttribute(HIDE_KEY, !1));
    })), elements;
}

function overlapX(elements, delta, deltaMul, useRadius) {
    if (useRadius) {
        let lastX = -1 / 0, lastR = 0;
        const useDeltaMul = (0, vutils_1.isNil)(delta);
        let itemDelta = delta;
        elements.forEach((element => {
            if (!1 === element.getGraphicAttribute("visible")) return;
            const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x");
            useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentX - lastX) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, !0), 
            element.setGraphicAttribute("visible", !1)) : lastX = currentX, lastR = r;
        }));
    }
}

function overlapY(elements, delta, deltaMul, useRadius) {
    if (useRadius) {
        let lastY = -1 / 0, lastR = 0;
        const useDeltaMul = (0, vutils_1.isNil)(delta);
        let itemDelta = delta;
        elements.forEach((element => {
            if (!1 === element.getGraphicAttribute("visible")) return;
            const r = element.getGraphicAttribute("size") / 2, currentY = element.getGraphicAttribute("y");
            useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentY - lastY) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, !0), 
            element.setGraphicAttribute("visible", !1)) : lastY = currentY, lastR = r;
        }));
    }
}

function overlapXY(elements, delta, deltaMul, useRadius) {
    if (useRadius) {
        const lastX = -1 / 0;
        let lastY = -1 / 0, lastR = 0, dis = 0;
        const useDeltaMul = (0, vutils_1.isNil)(delta);
        let itemDelta = delta;
        elements.forEach((element => {
            if (!1 === element.getGraphicAttribute("visible")) return;
            const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x"), currentY = element.getGraphicAttribute("y");
            useDeltaMul && (itemDelta = (r + lastR) * deltaMul), dis = (lastX - currentX) ** 2 + (lastY - currentY) ** 2, 
            dis < (itemDelta + lastR + r) ** 2 ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, !0), 
            element.setGraphicAttribute("visible", !1)) : lastY = currentY, lastR = r;
        }));
    }
}

const transform = (options, upstreamData) => {
    if (!upstreamData || 0 === upstreamData.length) return;
    let {radius: radius} = options;
    (0, vutils_1.isNil)(radius) && "symbol" === upstreamData[0].mark.markType && (radius = !0);
    const {direction: direction, delta: delta, deltaMul: deltaMul = 1, groupBy: groupBy} = options, handleOverlap = elements => {
        reset(elements);
        const sortedElements = elements.slice().sort(((a, b) => a.getGraphicAttribute("x") - b.getGraphicAttribute("x")));
        0 === direction ? overlapXY(sortedElements, delta, deltaMul, radius) : 1 === direction ? overlapX(sortedElements, delta, deltaMul, radius) : overlapY(sortedElements, delta, deltaMul, radius);
    };
    if (groupBy) {
        const map = upstreamData.reduce(((res, element) => {
            const groupName = element.getDatum()[groupBy];
            return res[groupName] ? res[groupName].push(element) : res[groupName] = [ element ], 
            res;
        }), {});
        Object.keys(map).forEach((key => {
            handleOverlap(map[key]);
        }));
    } else handleOverlap(upstreamData);
    return upstreamData;
};

exports.transform = transform;
//# sourceMappingURL=mark-overlap.js.map
