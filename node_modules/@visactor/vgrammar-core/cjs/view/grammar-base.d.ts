import { EventEmitter } from '@visactor/vutils';
import type { GrammarType, IGrammarBase, IView, IGrammarTask, BaseEventHandler } from '../types';
import type { Nil } from '../types/base';
export declare abstract class GrammarBase extends EventEmitter implements IGrammarBase {
    readonly grammarType: GrammarType;
    readonly uid: number;
    protected _id: string;
    protected _name: string;
    protected spec: any;
    view: IView;
    rank: number;
    grammarSource: IGrammarBase;
    references: Map<IGrammarBase, number>;
    targets: IGrammarBase[];
    transforms: IGrammarTask[];
    constructor(view: IView);
    parse(spec: any): this;
    depend(grammars: IGrammarBase[] | IGrammarBase | string[] | string): this;
    addEventListener(type: string, handler: BaseEventHandler, options?: any): this;
    removeEventListener(type: string, handler?: BaseEventHandler): this;
    emit<T extends EventEmitter.EventNames<string | symbol>>(event: T, ...args: EventEmitter.EventArgs<string | symbol, T>): boolean;
    emitGrammarEvent<T extends EventEmitter.EventNames<string | symbol>>(event: T, ...args: EventEmitter.EventArgs<string | symbol, T>): boolean;
    abstract evaluate(upstream: any, parameters: any): this | Promise<this>;
    abstract output(): any;
    evaluateSync?: (upstream: any, parameters: any) => this;
    evaluateTransform(transforms: IGrammarTask[], upstream: any, parameters: any): Promise<any>;
    evaluateTransformSync(transforms: IGrammarTask[], upstream: any, parameters: any): any;
    set(value: any): boolean;
    id(): string;
    id(id: string): this;
    name(): string;
    name(name: string): this;
    attach(reference: IGrammarBase | IGrammarBase[], count?: number): this;
    detach(reference: IGrammarBase | IGrammarBase[], count?: number): this;
    detachAll(): void;
    link(source: IGrammarBase): void;
    run(): this | Promise<this>;
    runSync(): this | Promise<this>;
    commit(): void;
    parameters(): any;
    getSpec(): any;
    reuse(grammar: IGrammarBase): this;
    clear(): void;
    release(): void;
    protected setFunctionSpec<T>(spec: T | Nil, specField: string): this;
}
