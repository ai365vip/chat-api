"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Data = void 0;

const vutils_1 = require("@visactor/vutils"), grammar_base_1 = require("./grammar-base"), util_1 = require("../parse/util"), transform_1 = require("../parse/transform"), enums_1 = require("../graph/enums"), data_1 = require("../util/data");

class Data extends grammar_base_1.GrammarBase {
    constructor(view, values, format) {
        super(view), this.grammarType = "data", this.spec = {}, this._dataIDKey = `VGRAMMAR_DATA_ID_KEY_${this.uid}`, 
        this._loadTasks = [], this._postFilters = [], this.ingest = options => {
            const format = (0, util_1.invokeParameterFunctionType)(options.format, this.parameters());
            return this._input = (0, data_1.parseFormat)(options.values, format), this._input;
        }, this.load = options => {
            var _a;
            if (options.values) return this.ingest(options);
            const url = (0, util_1.invokeParameterFunctionType)(options.url, this.parameters()), format = null !== (_a = (0, 
            util_1.invokeParameterFunctionType)(options.format, this.parameters())) && void 0 !== _a ? _a : {
                type: "json"
            };
            return (0, data_1.load)(url).then((data => this.ingest({
                values: data,
                format: format
            })));
        }, this.relay = options => options[0], this.evaluateSync = (upstream, parameters) => {
            this.view.emit(enums_1.HOOK_EVENT.BEFORE_EVALUATE_DATA);
            const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms), values = this.evaluateTransformSync(tasks, this.grammarSource ? upstream : this._input, parameters), filteredValues = this._evaluateFilter(values, parameters);
            return this.setValues(filteredValues), this._isLoaded = !0, this.view.emit(enums_1.HOOK_EVENT.AFTER_EVALUATE_DATA), 
            this;
        }, this._loadTasks = [], (0, vutils_1.isNil)(values) || this.values(values, format);
    }
    parse(spec) {
        return super.parse(spec), this._isLoaded = !1, this.source(spec.source, spec.format, !1), 
        this.url(spec.url, spec.format, !1), this.values(spec.values, spec.format, !1), 
        this.transform(spec.transform), this.parseLoad(spec), this.commit(), this;
    }
    parseDataSource(spec) {
        const refs = [], transforms = [], formatRef = spec.format ? (0, util_1.parseFunctionType)(spec.format, this.view)[0] : null;
        if (formatRef && refs.push(formatRef), spec.values) {
            const valuesRef = (0, util_1.parseFunctionType)(spec.values, this.view)[0];
            valuesRef && refs.push(valuesRef), transforms.push({
                type: "ingest",
                transform: this.ingest,
                isRawOptions: !0,
                options: {
                    values: spec.values,
                    format: spec.format
                }
            });
        } else if (spec.url) {
            const urlRef = (0, util_1.parseFunctionType)(spec.url, this.view)[0];
            urlRef && refs.push(urlRef), transforms.push({
                type: "load",
                transform: this.load,
                options: {
                    url: null != urlRef ? urlRef : spec.url,
                    format: null != formatRef ? formatRef : spec.format
                }
            });
        } else if (spec.source) {
            const upstreamData = [];
            (0, vutils_1.array)(spec.source).forEach((sourceId => {
                const sourceData = (0, util_1.isGrammar)(sourceId) ? sourceId : this.view.getDataById(sourceId);
                sourceData && (refs.push(sourceData), upstreamData.push(sourceData));
            })), upstreamData.length && (transforms.push({
                type: "relay",
                transform: this.relay,
                options: upstreamData
            }), this.grammarSource = upstreamData[0]);
        }
        return {
            transforms: transforms,
            refs: refs
        };
    }
    evaluate(upstream, parameters) {
        return __awaiter(this, void 0, void 0, (function*() {
            this.view.emit(enums_1.HOOK_EVENT.BEFORE_EVALUATE_DATA);
            const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms);
            this.grammarSource && (this._input = upstream);
            const values = yield this.evaluateTransform(tasks, this._input, parameters), filteredValues = this._evaluateFilter(values, parameters);
            return this.setValues(filteredValues), this._isLoaded = !0, this.view.emit(enums_1.HOOK_EVENT.AFTER_EVALUATE_DATA), 
            this;
        }));
    }
    output() {
        return this._values;
    }
    getDataIDKey() {
        return this._dataIDKey;
    }
    values(values, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            values: values,
            format: format
        });
        return (0, vutils_1.isNil)(values) || (spec.url = void 0, spec.source = void 0), 
        load ? this.parseLoad(spec) : this;
    }
    url(url, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            url: url,
            format: format
        });
        return (0, vutils_1.isNil)(url) || (spec.values = void 0, spec.source = void 0), 
        load ? this.parseLoad(spec) : this;
    }
    source(source, format, load = !0) {
        const spec = Object.assign({}, this.spec, {
            source: source,
            format: format
        });
        return (0, vutils_1.isNil)(source) || (spec.values = void 0, spec.url = void 0), 
        load ? this.parseLoad(spec) : this;
    }
    parseLoad(spec) {
        this.detach(this.parseDataSource(this.spec).refs), this.spec = spec;
        const dataSourceResult = this.parseDataSource(this.spec);
        return this.attach(dataSourceResult.refs), this._loadTasks = dataSourceResult.transforms, 
        this._isLoaded = !1, this.commit(), this;
    }
    setValues(data) {
        this._values = (0, vutils_1.array)(data).map(((entry, index) => {
            const datum = entry === Object(entry) ? entry : {
                data: entry
            };
            return datum[this._dataIDKey] = index, datum;
        }));
    }
    field(field) {
        return this._values.map((value => value[field]));
    }
    transform(transforms) {
        const prevTransforms = (0, transform_1.parseTransformSpec)(this.spec.transform, this.view);
        prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []), this.spec.transform = transforms;
        const nextTransforms = (0, transform_1.parseTransformSpec)(this.spec.transform, this.view);
        return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), 
        this.commit(), this;
    }
    getValue() {
        return this._values;
    }
    getInput() {
        return this._input;
    }
    addDataFilter(filter) {
        return this._postFilters = this._postFilters.concat((0, vutils_1.array)(filter)), 
        this._postFilters.sort(((filterA, filterB) => {
            var _a, _b;
            return (null !== (_a = filterA.rank) && void 0 !== _a ? _a : 0) - (null !== (_b = filterB.rank) && void 0 !== _b ? _b : 0);
        })), this;
    }
    removeDataFilter(filter) {
        const filters = (0, vutils_1.array)(filter);
        return this._postFilters = this._postFilters.filter((filter => !filters.includes(filter))), 
        this;
    }
    _evaluateFilter(value, parameters) {
        return this._postFilters.reduce(((result, filter) => filter.filter(result, parameters)), value);
    }
    reuse(grammar) {
        return grammar.grammarType !== this.grammarType || (this._isLoaded = !1, this._values = grammar.output()), 
        this;
    }
    clear() {
        super.clear(), this._input = null, this._values = null;
    }
}

exports.Data = Data;
//# sourceMappingURL=data.js.map
