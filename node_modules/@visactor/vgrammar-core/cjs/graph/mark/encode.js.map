{"version":3,"sources":["../src/graph/mark/encode.ts"],"names":[],"mappings":"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","file":"encode.js","sourcesContent":["import { isNil, isNumber, isString } from '@visactor/vutils';\nimport { field as getFieldAccessor } from '@visactor/vgrammar-util';\nimport type { BaseSingleEncodeSpec, IElement, MarkElementItem } from '../../types';\nimport { isFieldEncode, isScaleEncode } from '../../parse/mark';\nimport { getGrammarOutput, invokeFunctionType, isFunctionType } from '../../parse/util';\nimport { isPositionOrSizeChannel } from '../attributes/helpers';\nimport { GrammarMarkType } from '../enums';\nimport { Factory } from '../../core/factory';\n\n/**\n * invoke encoder for multiple items\n */\nexport function invokeEncoderToItems(\n  element: IElement,\n  items: MarkElementItem[],\n  encoder: BaseSingleEncodeSpec,\n  parameters: any,\n  onlyFullEncodeFirst?: boolean\n) {\n  if (!encoder) {\n    return;\n  }\n\n  if (isFunctionType(encoder)) {\n    items.forEach(item => {\n      const attributes = invokeFunctionType(encoder, parameters, item.datum, element);\n      Object.assign(item.nextAttrs, attributes);\n    });\n  } else {\n    Object.keys(encoder).forEach(channel => {\n      const encode = encoder[channel];\n      const encodeItems =\n        onlyFullEncodeFirst && !isPositionOrSizeChannel(element.mark.markType, channel) ? [items[0]] : items;\n\n      if (isScaleEncode(encode)) {\n        const scale = getGrammarOutput(encode.scale, parameters);\n        const offset = encode?.offset ?? 0;\n        const bandOffset = !isNil(encode.band) && scale.bandwidth ? scale.bandwidth() * encode.band : null;\n        const hasField = isString(encode?.field);\n        const fieldAccessor = hasField ? getFieldAccessor(encode.field) : null;\n\n        let to = hasField ? null : !isNil(encode?.value) ? scale.scale?.(encode.value) : 0;\n\n        encodeItems.forEach(item => {\n          if (hasField) {\n            to = scale.scale?.(fieldAccessor(item.datum));\n          }\n          item.nextAttrs[channel] = isNumber(to) || isNumber(bandOffset) ? to + offset + bandOffset : to;\n        });\n      } else if (isFieldEncode(encode)) {\n        const fieldAccessor = getFieldAccessor(encode.field);\n\n        encodeItems.forEach(item => {\n          item.nextAttrs[channel] = fieldAccessor(item.datum);\n        });\n      } else {\n        encodeItems.forEach(item => {\n          item.nextAttrs[channel] = invokeFunctionType(encode, parameters, item.datum, element);\n        });\n      }\n    });\n  }\n}\n\n/**\n * invoke encoder for single item\n * use invokeEncoderToItems instead if item amount is large\n */\nexport function invokeEncoder(encoder: BaseSingleEncodeSpec, datum: any, element: IElement, parameters: any) {\n  if (!encoder) {\n    return null;\n  }\n  if (isFunctionType(encoder)) {\n    return invokeFunctionType(encoder, parameters, datum, element);\n  }\n  const attributes: any = {};\n  Object.keys(encoder).forEach(channel => {\n    const encode = encoder[channel];\n\n    if (isScaleEncode(encode)) {\n      const scale = getGrammarOutput(encode.scale, parameters);\n      const offset = encode?.offset ?? 0;\n      const bandOffset = !isNil(encode.band) && scale.bandwidth ? scale.bandwidth() * encode.band : null;\n      const hasField = isString(encode?.field);\n      const fieldAccessor = hasField ? getFieldAccessor(encode.field) : null;\n      const to = hasField\n        ? scale.scale?.(fieldAccessor(datum))\n        : !isNil(encode?.value)\n        ? scale.scale?.(encode.value)\n        : 0;\n\n      attributes[channel] = isNumber(to) || isNumber(bandOffset) ? to + offset + bandOffset : to;\n    } else if (isFieldEncode(encode)) {\n      const fieldAccessor = getFieldAccessor(encode.field);\n      attributes[channel] = fieldAccessor(datum);\n    } else {\n      attributes[channel] = invokeFunctionType(encode, parameters, datum, element);\n    }\n  });\n  return attributes;\n}\n\nexport function splitEncoderInLarge(markType: string, encoder: BaseSingleEncodeSpec, glyphType?: string) {\n  // function encoder can not be splitted\n  if (isFunctionType(encoder)) {\n    return { themeEncoder: {}, positionEncoder: encoder };\n  }\n\n  const themeEncoder = {};\n  const positionEncoder = {};\n\n  if (markType === GrammarMarkType.glyph && Factory.getGlyph(glyphType)) {\n    const glyphMeta = Factory.getGlyph(glyphType);\n    const progressiveChannels = glyphMeta.getProgressiveChannels();\n    if (progressiveChannels) {\n      Object.keys(encoder).forEach(channel => {\n        if (progressiveChannels.includes(channel)) {\n          positionEncoder[channel] = encoder[channel];\n        } else {\n          themeEncoder[channel] = encoder[channel];\n        }\n      });\n    } else {\n      const markTypes: string[] = Array.from(new Set(Object.values(glyphMeta.getMarks())));\n      Object.keys(encoder).forEach(channel => {\n        if (markTypes.some(type => isPositionOrSizeChannel(type, channel))) {\n          positionEncoder[channel] = encoder[channel];\n        } else {\n          themeEncoder[channel] = encoder[channel];\n        }\n      });\n    }\n  } else {\n    Object.keys(encoder).forEach(channel => {\n      if (isPositionOrSizeChannel(markType, channel)) {\n        positionEncoder[channel] = encoder[channel];\n      } else {\n        themeEncoder[channel] = encoder[channel];\n      }\n    });\n  }\n\n  return { positionEncoder, themeEncoder };\n}\n"]}