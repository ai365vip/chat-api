{"version":3,"sources":["../src/graph/attributes/helpers.ts"],"names":[],"mappings":";;;AAEA,6CAAwD;AAExD,oCAA2C;AAE3C,SAAgB,oBAAoB,CAAC,QAAkB,EAAE,QAAkB;IACzE,QAAQ,QAAQ,EAAE;QAChB,KAAK,MAAM;YACT,OAAO,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;QAC3E,KAAK,MAAM;YACT,OAAO,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;QACvF,KAAK,YAAY;YACf,OAAO,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;QAC/E,KAAK,cAAc;YACjB,OAAO,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;KACjE;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAZD,oDAYC;AAQD,SAAgB,aAAa,CAAC,SAA2D;IACvF,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,SAAS,CAAC;IAEnC,IAAI,CAAC,IAAA,sBAAa,EAAC,CAAC,CAAC,IAAI,CAAC,IAAA,sBAAa,EAAC,CAAC,CAAC,IAAI,CAAC,IAAA,sBAAa,EAAC,EAAE,CAAC,IAAI,CAAC,IAAA,sBAAa,EAAC,EAAE,CAAC,EAAE;QACtF,OAAO,EAAE,CAAC;KACX;IACD,OAAO;QACL,EAAE,CAAC,EAAE,CAAC,EAAE;QACR,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE;KACjB,CAAC;AACJ,CAAC;AAVD,sCAUC;AAMD,SAAgB,aAAa,CAC3B,KAAyB,EACzB,eAAyB,EACzB,UAAyB,EACzB,MAAgB;IAEhB,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,eAAe,CAAC,EAAE;QACtE,OAAO,EAAE,CAAC;KACX;IACD,MAAM,eAAe,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;QACxC,OAAO,oBAAoB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC,CAAC;IACnE,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,eAAe,EAAE;QACpB,OAAO,UAAU,aAAV,UAAU,cAAV,UAAU,GAAI,EAAE,CAAC;KACzB;IACD,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;;QAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;QAC7B,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,OAAO,EAAE,GAAG,MAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAG,KAAK,CAAC,mCAAI,EAAE,CAAC;QAC5D,IAAI,IAAA,cAAK,EAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YAClB,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;SACb;QACD,IAAI,IAAA,cAAK,EAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YAClB,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;SACb;QAED,IAAI,IAAA,cAAK,EAAC,KAAK,CAAC,OAAO,CAAC,IAAI,OAAO,KAAK,KAAK,EAAE;YAC7C,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC;SACvB;QAED,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC;QAEzB,IAAI,MAAM,EAAE;YACV,IAAI,IAAA,cAAK,EAAC,KAAK,CAAC,EAAE,CAAC,EAAE;gBACnB,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC;aACf;YACD,IAAI,IAAA,cAAK,EAAC,KAAK,CAAC,EAAE,CAAC,EAAE;gBACnB,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC;aACf;SACF;QAED,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC;AA1CD,sCA0CC;AAED,SAAgB,mBAAmB,CACjC,KAAyB,EACzB,eAAyB,EACzB,aAAsC,EAAE;IAExC,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,eAAe,CAAC,EAAE;QACtE,OAAO,EAAE,CAAC;KACX;IACD,MAAM,GAAG,GAAiB,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAE7D,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;;QAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;QAC7B,MAAM,CAAC,GAAG,MAAA,KAAK,CAAC,CAAC,mCAAI,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QAC3C,MAAM,CAAC,GAAG,MAAA,KAAK,CAAC,CAAC,mCAAI,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QAC/C,MAAM,KAAK,GAAG,MAAA,KAAK,CAAC,KAAK,mCAAI,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACvD,MAAM,EAAE,GAAG,MAAA,KAAK,CAAC,EAAE,mCAAI,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QACjD,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACnB,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACvB,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC;QAC3B,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;IAEH,OAAO,GAAG,CAAC;AACb,CAAC;AAvBD,kDAuBC;AAED,SAAgB,qBAAqB,CACnC,KAAyB,EACzB,eAAyB,EACzB,aAAsC,EAAE;IAExC,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,eAAe,CAAC,EAAE;QACtE,OAAO,EAAE,CAAC;KACX;IACD,MAAM,GAAG,GAAiB,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAE7D,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;;QAC5B,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC;QAC7B,MAAM,CAAC,GAAG,MAAA,KAAK,CAAC,CAAC,mCAAI,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QAC3C,MAAM,CAAC,GAAG,MAAA,KAAK,CAAC,CAAC,mCAAI,UAAU,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;QAC/C,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACnB,GAAG,CAAC,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IAEH,OAAO,GAAG,CAAC;AACb,CAAC;AAnBD,sDAmBC;AAED,SAAgB,uBAAuB,CAAC,IAAY,EAAE,OAAe;IACnE,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;QAC5C,OAAO,IAAI,CAAC;KACb;IAED,QAAQ,IAAI,EAAE;QACZ,KAAK,uBAAe,CAAC,GAAG;YACtB,OAAO,CAAC,aAAa,EAAE,aAAa,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACpF,KAAK,uBAAe,CAAC,KAAK,CAAC;QAC3B,KAAK,uBAAe,CAAC,IAAI,CAAC;QAC1B,KAAK,uBAAe,CAAC,KAAK;YACxB,OAAO,CAAC,OAAO,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACrD,KAAK,uBAAe,CAAC,IAAI,CAAC;QAC1B,KAAK,uBAAe,CAAC,KAAK;YACxB,OAAO,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAClD,KAAK,uBAAe,CAAC,IAAI;YACvB,OAAO,OAAO,KAAK,SAAS,CAAC;QAC/B,KAAK,uBAAe,CAAC,IAAI;YACvB,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACnD,KAAK,uBAAe,CAAC,IAAI;YACvB,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACxC,KAAK,uBAAe,CAAC,MAAM;YACzB,OAAO,OAAO,KAAK,MAAM,CAAC;QAC5B,KAAK,uBAAe,CAAC,OAAO;YAC1B,OAAO,OAAO,KAAK,QAAQ,CAAC;QAC9B,KAAK,uBAAe,CAAC,IAAI;YACvB,OAAO,OAAO,KAAK,MAAM,CAAC;KAC7B;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AA9BD,0DA8BC;AAED,SAAgB,gBAAgB,CAAC,QAAkB;IACjD,OACE,CAAC,uBAAe,CAAC,IAAI,EAAE,uBAAe,CAAC,IAAI,EAAE,uBAAe,CAAC,UAAU,EAAE,uBAAe,CAAC,YAAY,CACtG,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;AACvB,CAAC;AAJD,4CAIC","file":"helpers.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\n// eslint-disable-next-line no-duplicate-imports\nimport { isNil, isValidNumber } from '@visactor/vutils';\nimport type { MarkElementItem, MarkType } from '../../types';\nimport { GrammarMarkType } from '../enums';\n\nexport function isValidPointsChannel(channels: string[], markType: MarkType): boolean {\n  switch (markType) {\n    case 'line':\n      return channels.some(channel => ['x', 'y', 'defined'].includes(channel));\n    case 'area':\n      return channels.some(channel => ['x', 'y', 'x1', 'y1', 'defined'].includes(channel));\n    case 'largeRects':\n      return channels.some(channel => ['x', 'y', 'width', 'y1'].includes(channel));\n    case 'largeSymbols':\n      return channels.some(channel => ['x', 'y'].includes(channel));\n  }\n  return false;\n}\n\n/**\n * 获取rule的points\n * 相对位置\n * @param {*} item\n * @returns\n */\nexport function getRulePoints(nextAttrs: { x: number; y: number; x1: number; y1: number }) {\n  const { x, y, x1, y1 } = nextAttrs;\n\n  if (!isValidNumber(x) || !isValidNumber(y) || !isValidNumber(x1) || !isValidNumber(y1)) {\n    return [];\n  }\n  return [\n    { x, y },\n    { x: x1, y: y1 }\n  ];\n}\n/**\n * 生成用于渲染的点数组\n * @param {*} item\n * @returns {IPointLike[]}\n */\nexport function getLinePoints(\n  items?: MarkElementItem[],\n  includeOnePoint?: boolean,\n  lastPoints?: IPointLike[],\n  isArea?: boolean\n) {\n  if (!items || !items.length || (items.length === 1 && includeOnePoint)) {\n    return [];\n  }\n  const hasValidChannel = items.some(item => {\n    return isValidPointsChannel(Object.keys(item.nextAttrs), 'line');\n  });\n  if (!hasValidChannel) {\n    return lastPoints ?? [];\n  }\n  return items.map((item, index) => {\n    const attrs = item.nextAttrs;\n    const { x, y, x1, y1, defined } = lastPoints?.[index] ?? {};\n    if (isNil(attrs.x)) {\n      attrs.x = x;\n    }\n    if (isNil(attrs.y)) {\n      attrs.y = y;\n    }\n\n    if (isNil(attrs.defined) && defined === false) {\n      attrs.defined = false;\n    }\n\n    attrs.context = item.key;\n\n    if (isArea) {\n      if (isNil(attrs.x1)) {\n        attrs.x1 = x1;\n      }\n      if (isNil(attrs.y1)) {\n        attrs.y1 = y1;\n      }\n    }\n\n    return attrs;\n  });\n}\n\nexport function getLargeRectsPoints(\n  items?: MarkElementItem[],\n  includeOnePoint?: boolean,\n  lastPoints: Float32Array | number[] = []\n): Float32Array | number[] {\n  if (!items || !items.length || (items.length === 1 && includeOnePoint)) {\n    return [];\n  }\n  const arr: Float32Array = new Float32Array(items.length * 4);\n\n  items.forEach((item, index) => {\n    const attrs = item.nextAttrs;\n    const x = attrs.x ?? lastPoints[index * 4];\n    const y = attrs.y ?? lastPoints[index * 4 + 1];\n    const width = attrs.width ?? lastPoints[index * 4 + 2];\n    const y1 = attrs.y1 ?? lastPoints[index * 4 + 3];\n    arr[index * 4] = x;\n    arr[index * 4 + 1] = y;\n    arr[index * 4 + 2] = width;\n    arr[index * 4 + 3] = y1 - y;\n  });\n\n  return arr;\n}\n\nexport function getLargeSymbolsPoints(\n  items?: MarkElementItem[],\n  includeOnePoint?: boolean,\n  lastPoints: Float32Array | number[] = []\n): Float32Array | number[] {\n  if (!items || !items.length || (items.length === 1 && includeOnePoint)) {\n    return [];\n  }\n  const arr: Float32Array = new Float32Array(items.length * 2);\n\n  items.forEach((item, index) => {\n    const attrs = item.nextAttrs;\n    const x = attrs.x ?? lastPoints[index * 2];\n    const y = attrs.y ?? lastPoints[index * 2 + 1];\n    arr[index * 2] = x;\n    arr[index * 2 + 1] = y;\n  });\n\n  return arr;\n}\n\nexport function isPositionOrSizeChannel(type: string, channel: string) {\n  if (['x', 'y', 'dx', 'dy'].includes(channel)) {\n    return true;\n  }\n\n  switch (type) {\n    case GrammarMarkType.arc:\n      return ['innerRadius', 'outerRadius', 'startAngle', 'endAngle'].includes(channel);\n    case GrammarMarkType.group:\n    case GrammarMarkType.rect:\n    case GrammarMarkType.image:\n      return ['width', 'height', 'y1'].includes(channel);\n    case GrammarMarkType.path:\n    case GrammarMarkType.shape:\n      return ['path', 'customPath'].includes(channel);\n    case GrammarMarkType.line:\n      return channel === 'defined';\n    case GrammarMarkType.area:\n      return ['x1', 'y1', 'defined'].includes(channel);\n    case GrammarMarkType.rule:\n      return ['x1', 'y1'].includes(channel);\n    case GrammarMarkType.symbol:\n      return channel === 'size';\n    case GrammarMarkType.polygon:\n      return channel === 'points';\n    case GrammarMarkType.text:\n      return channel === 'text';\n  }\n\n  return false;\n}\n\nexport function isPointsMarkType(markType: MarkType): boolean {\n  return (\n    [GrammarMarkType.line, GrammarMarkType.area, GrammarMarkType.largeRects, GrammarMarkType.largeSymbols] as MarkType[]\n  ).includes(markType);\n}\n"]}