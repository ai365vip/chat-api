"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ViewZoomMixin = void 0;

const vutils_1 = require("@visactor/vutils"), view_utils_1 = require("./view-utils");

class ViewZoomMixin {
    _formatPinchZoom(e) {
        const scale = e.scale;
        if ((0, vutils_1.isNil)(this._lastScale)) return this._lastScale = scale, e;
        const zoomDelta = scale / this._lastScale;
        this._lastScale = scale;
        const center = e.center;
        return e.zoomDelta = zoomDelta, e.zoomX = center.x, e.zoomY = center.y, e;
    }
    _formatWheelZoom(e) {
        if (!e.ctrlKey) return e.zoomDelta = null, e.zoomX = null, e.zoomY = null, e;
        const zoomDelta = Math.pow(1.0005, -e.deltaY * Math.pow(16, e.deltaMode));
        return e.zoomDelta = zoomDelta, e.zoomX = e.canvasX, e.zoomY = e.canvasY, e;
    }
    formatZoomEvent(e) {
        return e ? "pinch" === e.type ? this._formatPinchZoom(e) : this._formatWheelZoom(e) : e;
    }
    updateZoomRange(rangeFactor = [ 0, 1 ], range, zoomEvent, zoomOptions) {
        var _a;
        const {zoomDelta: zoomDelta} = zoomEvent, rangeDelta = Math.abs(rangeFactor[1] - rangeFactor[0]);
        if (rangeDelta >= 1 && zoomDelta >= 1) return;
        if (rangeDelta <= .001 && zoomDelta <= 1) return;
        const value = rangeDelta * (zoomDelta - 1) * (null !== (_a = zoomOptions.rate) && void 0 !== _a ? _a : 1) / 2, start = (0, 
        vutils_1.clamp)(rangeFactor[0] - value, 0, 1), end = (0, vutils_1.clamp)(rangeFactor[1] + value, 0, 1);
        return [ Math.min(start, end), Math.max(start, end) ];
    }
    _handleZooming(zoomPos, navState, zoomOptions) {
        const res = {
            needUpdate: !1
        };
        return navState ? (Object.keys(navState).forEach((dim => {
            const {scale: scale, data: data, linkedComponent: linkedComponent, rangeFactor: rangeFactor} = navState[dim];
            if (linkedComponent) res[dim] = this.updateZoomRange((0, view_utils_1.getRangeOfLinkedComponent)(linkedComponent), null, zoomPos, zoomOptions); else if (scale) {
                const innerScale = scale.getScale(), newRange = this.updateZoomRange(rangeFactor, innerScale, zoomPos, zoomOptions);
                newRange && (navState[dim].rangeFactor = newRange, data ? (navState[dim].filterValue = newRange, 
                data.commit()) : (scale.setRangeFactor(newRange), scale.commit()), res.needUpdate = !0, 
                res[dim] = newRange);
            }
        })), res) : res;
    }
    handleZoomStart(e, navState, zoomOptions) {
        if (!(0, vutils_1.isNil)(e.zoomDelta)) return e.stopPropagation(), e.preventDefault(), 
        zoomOptions && zoomOptions.realtime ? this._handleZooming(e, navState, zoomOptions) : ((0, 
        vutils_1.isNil)(this._zoomPos) ? this._zoomPos = {
            zoomDelta: e.zoomDelta,
            zoomX: e.zoomX,
            zoomY: e.zoomY
        } : this._zoomPos.zoomDelta *= e.zoomDelta, null);
    }
    handleZoomEnd(e, navState, zoomOptions) {
        this._lastScale = null;
        const res = zoomOptions && !1 === zoomOptions.realtime && this._zoomPos ? this._handleZooming(this._zoomPos, navState, zoomOptions) : null;
        return this._zoomPos = null, res;
    }
    handleZoomReset(e, navState, zoomOptions) {
        const res = {
            needUpdate: !1
        };
        return navState ? (Object.keys(navState).forEach((dim => {
            const {scale: scale, data: data, linkedComponent: linkedComponent} = navState[dim], newRange = [ 0, 1 ];
            linkedComponent ? res[dim] = newRange : scale && (navState[dim].rangeFactor = null, 
            data ? (navState[dim].filterValue = null, data.commit()) : (scale.setRangeFactor(newRange), 
            scale.commit()), res.needUpdate = !0, res[dim] = newRange);
        })), res) : res;
    }
}

exports.ViewZoomMixin = ViewZoomMixin;
//# sourceMappingURL=view-zoom-mixin.js.map
