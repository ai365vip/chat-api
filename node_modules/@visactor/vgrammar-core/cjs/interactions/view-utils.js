"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.handleScrolling = exports.updateScrollRange = exports.getFilteredValuesFromScale = exports.getBoundsRangeOfLinkedComponent = exports.getRangeOfLinkedComponent = void 0;

const vscale_1 = require("@visactor/vscale"), enums_1 = require("../graph/enums"), getRangeOfLinkedComponent = comp => {
    if (comp.componentType === enums_1.ComponentEnum.datazoom) {
        const res = comp.getStartEndValue();
        return res ? [ res.start, res.end ] : null;
    }
    return comp.getScrollRange();
};

exports.getRangeOfLinkedComponent = getRangeOfLinkedComponent;

const getBoundsRangeOfLinkedComponent = (comp, dim) => {
    const bounds = comp.getBounds();
    if (bounds && !bounds.empty()) return "y" === dim ? [ bounds.y1, bounds.y2 ] : [ bounds.x1, bounds.x2 ];
};

exports.getBoundsRangeOfLinkedComponent = getBoundsRangeOfLinkedComponent;

const getFilteredValuesFromScale = (scale, range) => {
    const scaleRange = scale.range(), startPos = scaleRange[0] + (scaleRange[1] - scaleRange[0]) * range[0], endPos = scaleRange[0] + (scaleRange[1] - scaleRange[0]) * range[1];
    if ((0, vscale_1.isContinuous)(scale.type)) {
        const startValue = scale.invert(startPos), endValue = scale.invert(endPos);
        return [ Math.min(startValue, endValue), Math.max(startValue, endValue) ];
    }
    return scale.domain().filter((entry => {
        const val = scale.scale(entry);
        return val >= startPos && val <= endPos;
    }));
};

exports.getFilteredValuesFromScale = getFilteredValuesFromScale;

const updateScrollRange = (rangeFactor = [ 0, 1 ], range, scrollValue = 0, scrollOptions) => {
    if (Math.abs(scrollValue) < .001) return;
    if (Math.abs(rangeFactor[1] - rangeFactor[0]) >= 1) return;
    const size = Math.abs(range[range.length - 1] - range[0]);
    if (size <= 0 || Number.isNaN(size)) return;
    const value = (scrollOptions.reversed ? -1 : 1) * scrollValue;
    if (value > 0 && rangeFactor[1] < 1) {
        const delta = Math.min(1 - rangeFactor[1], value / size);
        return [ rangeFactor[0] + delta, rangeFactor[1] + delta ];
    }
    if (value < 0 && rangeFactor[0] > 0) {
        const delta = Math.max(-rangeFactor[0], value / size);
        return [ rangeFactor[0] + delta, rangeFactor[1] + delta ];
    }
};

exports.updateScrollRange = updateScrollRange;

const handleScrolling = (scrollPos, navState, scrollOptions) => {
    const res = {
        needUpdate: !1
    };
    return navState ? (Object.keys(navState).forEach((dim => {
        const {scale: scale, data: data, linkedComponent: linkedComponent, rangeFactor: rangeFactor, wholeScale: wholeScale} = navState[dim];
        if (linkedComponent) res[dim] = (0, exports.updateScrollRange)((0, exports.getRangeOfLinkedComponent)(linkedComponent), (0, 
        exports.getBoundsRangeOfLinkedComponent)(linkedComponent, dim), scrollPos[dim], scrollOptions); else if (scale) {
            const innerScale = scale.getScale(), newRange = (0, exports.updateScrollRange)(rangeFactor, innerScale.range(), scrollPos[dim], scrollOptions);
            newRange && (navState[dim].rangeFactor = newRange, data ? (navState[dim].filterValue = rangeFactor, 
            data.commit()) : (scale.setRangeFactor(newRange), scale.commit()), res.needUpdate = !0, 
            res[dim] = newRange);
        }
    })), res) : res;
};

exports.handleScrolling = handleScrolling;
//# sourceMappingURL=view-utils.js.map
