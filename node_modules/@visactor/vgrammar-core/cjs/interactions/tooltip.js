"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Tooltip = void 0;

const vutils_1 = require("@visactor/vutils"), base_tooltip_1 = require("./base-tooltip"), util_1 = require("../parse/util");

class Tooltip extends base_tooltip_1.BaseTooltip {
    constructor(view, options) {
        super(view, options), this.type = Tooltip.type, this.handleTooltipShow = (0, vutils_1.throttle)((event => {
            const element = event.element;
            if (!this._marks.includes(null == element ? void 0 : element.mark)) return void this._tooltipComponent.hideAll();
            this._tooltipComponent.showAll();
            const groupGraphicItem = this.view.rootMark.getGroupGraphicItem(), point = {
                x: 0,
                y: 0
            };
            if (groupGraphicItem.globalTransMatrix.transformPoint(event.canvas, point), element === this._lastElement) return void this._tooltipComponent.setAttributes({
                pointerX: point.x,
                pointerY: point.y
            });
            const boundsStart = {
                x: 0,
                y: 0
            };
            groupGraphicItem.globalTransMatrix.transformPoint({
                x: 0,
                y: 0
            }, boundsStart);
            const boundsEnd = {
                x: 0,
                y: 0
            };
            groupGraphicItem.globalTransMatrix.transformPoint({
                x: this.view.getSignalById("width").getValue(),
                y: this.view.getSignalById("height").getValue()
            }, boundsEnd);
            const bounds = (new vutils_1.AABBBounds).set(boundsStart.x, boundsStart.y, boundsEnd.x, boundsEnd.y), {title: title, content: content} = this._computeTitleContent(element.getDatum()), theme = this.view.getCurrentTheme(), addition = (0, 
            util_1.invokeFunctionType)(this.options.attributes, this.parameters(), element.getDatum()), attributes = (0, 
            base_tooltip_1.generateTooltipAttributes)(point, title, content, bounds, theme, addition);
            this._tooltipComponent.setAttributes(attributes);
        }), 10), this.handleTooltipHide = event => {
            this._tooltipComponent.hideAll();
        }, this.options = Object.assign({}, Tooltip.defaultOptions, options);
    }
    getEvents() {
        return [ {
            type: this.options.trigger,
            handler: this.handleTooltipShow
        }, {
            type: this.options.resetTrigger,
            handler: this.handleTooltipHide
        } ];
    }
}

exports.Tooltip = Tooltip, Tooltip.type = "tooltip", Tooltip.defaultOptions = {
    trigger: "pointermove",
    resetTrigger: "pointerleave"
};
//# sourceMappingURL=tooltip.js.map