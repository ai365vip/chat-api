{"version":3,"sources":["../src/axis/grid/circle.ts"],"names":[],"mappings":"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","file":"circle.js","sourcesContent":["/**\n * @description 圆弧型坐标轴的网格线\n */\n\nimport { merge, mixin } from '@visactor/vutils';\nimport { BaseGrid } from './base';\nimport type { CircleAxisGridAttributes, GridItem } from './type';\nimport { POLAR_END_ANGLE, POLAR_START_ANGLE } from '../../constant';\nimport type { TransformedAxisItem } from '../type';\nimport { CircleAxisMixin } from '../mixin/circle';\nimport type { ComponentOptions } from '../../interface';\nimport { loadCircleAxisGridComponent } from '../register';\n\nexport interface CircleAxisGrid\n  extends Pick<CircleAxisMixin, 'isInValidValue' | 'getTickCoord' | 'getVerticalVector'>,\n    BaseGrid<CircleAxisGridAttributes> {}\n\nloadCircleAxisGridComponent();\nexport class CircleAxisGrid extends BaseGrid<CircleAxisGridAttributes> {\n  constructor(attributes: CircleAxisGridAttributes, options?: ComponentOptions) {\n    super(options?.skipDefault ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);\n  }\n\n  protected getGridAttribute(isSubGrid: boolean) {\n    let gridAttribute;\n    let items: GridItem[] = [];\n    const {\n      radius,\n      innerRadius = 0,\n      startAngle = POLAR_START_ANGLE,\n      endAngle = POLAR_END_ANGLE,\n      center,\n      subGrid,\n      ...grid\n    } = this.attribute;\n    const { alignWithLabel = true } = grid || {};\n\n    const length = radius - innerRadius;\n    let tickSegment = 1;\n    const count = this.data.length;\n    if (count >= 2) {\n      tickSegment = this.data[1].value - this.data[0].value;\n    }\n    if (!isSubGrid) {\n      gridAttribute = grid as CircleAxisGridAttributes;\n      // 计算 grid Items\n      const gridItems: GridItem[] = [];\n      let data;\n      if (Math.abs(endAngle - startAngle) % (Math.PI * 2) === 0) {\n        data = [...this.data].concat(this.data[0]);\n      } else {\n        data = this.data;\n      }\n\n      data.forEach(item => {\n        let { point } = item;\n        if (!alignWithLabel) {\n          // tickLine 不同 tick 对齐时需要调整 point\n          const value = item.value - tickSegment / 2;\n          if (this.isInValidValue(value)) {\n            return;\n          }\n          point = this.getTickCoord(value);\n        }\n        const endPoint = this.getVerticalCoord(point, length as number, true);\n        gridItems.push({\n          id: item.id,\n          points: [point, endPoint],\n          datum: item\n        });\n      });\n      items = gridItems;\n    } else {\n      // 渲染 subGrid\n      gridAttribute = merge({}, grid, subGrid);\n      // 计算 grid Items\n      const subGridItems: GridItem[] = [];\n      const { count: subCount = 4 } = subGrid || {};\n      const tickLineCount = this.data.length;\n      // 刻度线的数量大于 2 时，才绘制子刻度\n      if (tickLineCount >= 2) {\n        const points: { value: number }[] = [];\n        this.data.forEach((item: TransformedAxisItem) => {\n          let tickValue = item.value;\n          if (!alignWithLabel) {\n            // tickLine 不同 tick 对齐时需要调整 point\n            const value = item.value - tickSegment / 2;\n            if (this.isInValidValue(value)) {\n              return;\n            }\n            tickValue = value;\n          }\n          points.push({\n            value: tickValue\n          });\n        });\n\n        for (let i = 0; i < tickLineCount; i++) {\n          const pre = points[i];\n          const next = points[i + 1];\n          subGridItems.push({\n            id: `sub-${i}-${0}`,\n            points: [this.getTickCoord(pre.value), this.getVerticalCoord(this.getTickCoord(pre.value), length, true)],\n            datum: {}\n          });\n          for (let j = 0; j < subCount; j++) {\n            const percent = (j + 1) / (subCount + 1);\n            const value =\n              (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment);\n            const point = this.getTickCoord(value);\n            const endPoint = this.getVerticalCoord(point, length, true);\n            subGridItems.push({\n              id: `sub-${i}-${j + 1}`,\n              points: [point, endPoint],\n              // TODO: 这里也需要，后续考虑如何加上\n              datum: {}\n            });\n          }\n        }\n\n        if (Math.abs(endAngle - startAngle) % (Math.PI * 2) === 0) {\n          subGridItems.push(subGridItems[0]);\n        }\n\n        items = subGridItems;\n      }\n    }\n    return {\n      ...gridAttribute,\n      items,\n      center,\n      type: 'line'\n    };\n  }\n}\n\nmixin(CircleAxisGrid, CircleAxisMixin);\n"]}