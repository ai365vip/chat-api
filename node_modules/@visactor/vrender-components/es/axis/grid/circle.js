var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { merge, mixin } from "@visactor/vutils";

import { BaseGrid } from "./base";

import { POLAR_END_ANGLE, POLAR_START_ANGLE } from "../../constant";

import { CircleAxisMixin } from "../mixin/circle";

import { loadCircleAxisGridComponent } from "../register";

loadCircleAxisGridComponent();

export class CircleAxisGrid extends BaseGrid {
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
    }
    getGridAttribute(isSubGrid) {
        let gridAttribute, items = [];
        const _a = this.attribute, {radius: radius, innerRadius: innerRadius = 0, startAngle: startAngle = POLAR_START_ANGLE, endAngle: endAngle = POLAR_END_ANGLE, center: center, subGrid: subGrid} = _a, grid = __rest(_a, [ "radius", "innerRadius", "startAngle", "endAngle", "center", "subGrid" ]), {alignWithLabel: alignWithLabel = !0} = grid || {}, length = radius - innerRadius;
        let tickSegment = 1;
        if (this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value), 
        isSubGrid) {
            gridAttribute = merge({}, grid, subGrid);
            const subGridItems = [], {count: subCount = 4} = subGrid || {}, tickLineCount = this.data.length;
            if (tickLineCount >= 2) {
                const points = [];
                this.data.forEach((item => {
                    let tickValue = item.value;
                    if (!alignWithLabel) {
                        const value = item.value - tickSegment / 2;
                        if (this.isInValidValue(value)) return;
                        tickValue = value;
                    }
                    points.push({
                        value: tickValue
                    });
                }));
                for (let i = 0; i < tickLineCount; i++) {
                    const pre = points[i], next = points[i + 1];
                    subGridItems.push({
                        id: `sub-${i}-0`,
                        points: [ this.getTickCoord(pre.value), this.getVerticalCoord(this.getTickCoord(pre.value), length, !0) ],
                        datum: {}
                    });
                    for (let j = 0; j < subCount; j++) {
                        const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment), point = this.getTickCoord(value), endPoint = this.getVerticalCoord(point, length, !0);
                        subGridItems.push({
                            id: `sub-${i}-${j + 1}`,
                            points: [ point, endPoint ],
                            datum: {}
                        });
                    }
                }
                Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 && subGridItems.push(subGridItems[0]), 
                items = subGridItems;
            }
        } else {
            gridAttribute = grid;
            const gridItems = [];
            let data;
            data = Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? [ ...this.data ].concat(this.data[0]) : this.data, 
            data.forEach((item => {
                let {point: point} = item;
                if (!alignWithLabel) {
                    const value = item.value - tickSegment / 2;
                    if (this.isInValidValue(value)) return;
                    point = this.getTickCoord(value);
                }
                const endPoint = this.getVerticalCoord(point, length, !0);
                gridItems.push({
                    id: item.id,
                    points: [ point, endPoint ],
                    datum: item
                });
            })), items = gridItems;
        }
        return Object.assign(Object.assign({}, gridAttribute), {
            items: items,
            center: center,
            type: "line"
        });
    }
}

mixin(CircleAxisGrid, CircleAxisMixin);
//# sourceMappingURL=circle.js.map
