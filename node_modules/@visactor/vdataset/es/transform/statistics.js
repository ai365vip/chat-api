import * as simpleStatistics from "simple-statistics";

import { mergeDeepImmer } from "../utils/js";

import { isArray, uniqArray, flattenArray } from "@visactor/vutils";

import { STATISTICS_METHODS } from "../constants";

const DEFAULT_STATISTICS_OPTIONS = {
    as: [],
    fields: [],
    groupBy: null,
    operations: [ "count", "max", "min", "average", "sum" ]
}, aggregates = {
    count: data => data.length,
    distinct: (data, field) => uniqArray(data.map((row => row[field]))).length
};

STATISTICS_METHODS.forEach((method => {
    aggregates[method] = (data, field) => {
        let values = data.map((row => row[field]));
        return isArray(values) && isArray(values[0]) && (values = flattenArray(values)), 
        simpleStatistics[method](values);
    };
})), aggregates.average = aggregates.mean;

export const statistics = (data, options) => {
    const mergeOptions = mergeDeepImmer(DEFAULT_STATISTICS_OPTIONS, options), {as: as, fields: fields, groupBy: groupBy, operations: operations} = mergeOptions, groups = {};
    data.forEach((d => {
        groups[d[groupBy]] = groups[d[groupBy]] || [], groups[d[groupBy]].push(d);
    }));
    const results = [];
    for (const key in groups) {
        const result = {
            group: key
        }, group = groups[key];
        operations.forEach(((operation, i) => {
            var _a, _b;
            const outputName = null !== (_a = as[i]) && void 0 !== _a ? _a : operation, field = null !== (_b = fields[i]) && void 0 !== _b ? _b : fields[0];
            result[outputName] = aggregates[operation](group, field);
        })), results.push(result);
    }
    return results;
};
//# sourceMappingURL=statistics.js.map