(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VScale = {}));
})(this, (function (exports) { 'use strict';

  var eventemitter3 = {exports: {}};

  (function (module) {

    var has = Object.prototype.hasOwnProperty,
      prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
      }
      var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }

    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [],
        events,
        name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };

    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length,
          j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
      }
      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);

  const isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
  var isType$1 = isType;

  const isNil = value => null == value;
  var isNil$1 = isNil;

  const isValid = value => null != value;
  var isValid$1 = isValid;

  const isString = function (value) {
    let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    const type = typeof value;
    return fuzzy ? "string" === type : "string" === type || isType$1(value, "String");
  };
  var isString$1 = isString;

  const isArray = value => Array.isArray ? Array.isArray(value) : isType$1(value, "Array");
  var isArray$1 = isArray;

  const isNumber = function (value) {
    let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    const type = typeof value;
    return fuzzy ? "number" === type : "number" === type || isType$1(value, "Number");
  };
  var isNumber$1 = isNumber;

  const isValidNumber = value => isNumber$1(value) && Number.isFinite(value);
  var isValidNumber$1 = isValidNumber;

  function arrayEqual(a, b) {
    if (!isArray$1(a) || !isArray$1(b)) return !1;
    if (a.length !== b.length) return !1;
    for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
    return !0;
  }

  function range(start, stop, step) {
    isValid$1(stop) || (stop = start, start = 0), isValid$1(step) || (step = 1);
    let i = -1;
    const n = 0 | Math.max(0, Math.ceil((stop - start) / step)),
      range = new Array(n);
    for (; ++i < n;) range[i] = start + i * step;
    return range;
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function toNumber(a) {
    return Number(a);
  }

  function quantileSorted(values, percent) {
    let valueof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toNumber;
    const n = values.length;
    if (!n) return;
    if (percent <= 0 || n < 2) return valueof(values[0], 0, values);
    if (percent >= 1) return valueof(values[n - 1], n - 1, values);
    const i = (n - 1) * percent,
      i0 = Math.floor(i),
      value0 = valueof(values[i0], i0, values);
    return value0 + (valueof(values[i0 + 1], i0 + 1, values) - value0) * (i - i0);
  }

  function bisect(a, x) {
    let lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let hi = arguments.length > 3 ? arguments[3] : undefined;
    for (isNil$1(hi) && (hi = a.length); lo < hi;) {
      const mid = lo + hi >>> 1;
      ascending(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
    }
    return lo;
  }

  const e10$1 = Math.sqrt(50),
    e5$1 = Math.sqrt(10),
    e2$1 = Math.sqrt(2);
  function tickStep(start, stop, count) {
    const step0 = Math.abs(stop - start) / Math.max(0, count);
    let step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10));
    const error = step0 / step1;
    return error >= e10$1 ? step1 *= 10 : error >= e5$1 ? step1 *= 5 : error >= e2$1 && (step1 *= 2), stop < start ? -step1 : step1;
  }

  const DEFAULT_ABSOLUTE_TOLERATE = 1e-10,
    DEFAULT_RELATIVE_TOLERATE = 1e-10;
  function isNumberClose(a, b) {
    let relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RELATIVE_TOLERATE;
    let absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ABSOLUTE_TOLERATE;
    const abs = absTol,
      rel = relTol * Math.max(a, b);
    return Math.abs(a - b) <= Math.max(abs, rel);
  }
  function isGreater(a, b, relTol, absTol) {
    return a > b && !isNumberClose(a, b, relTol, absTol);
  }
  function isLess(a, b, relTol, absTol) {
    return a < b && !isNumberClose(a, b, relTol, absTol);
  }

  const memoize = func => {
    let lastArgs = null,
      lastResult = null;
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return lastArgs && args.every((val, i) => val === lastArgs[i]) || (lastArgs = args, lastResult = func(...args)), lastResult;
    };
  };

  const repeat = function (str) {
      let repeatCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let s = "",
        i = repeatCount - 1;
      for (; i >= 0;) s = `${s}${str}`, i -= 1;
      return s;
    },
    pad = function (str, length) {
      let padChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : " ";
      let align = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "right";
      const c = padChar,
        s = str + "",
        n = length - s.length;
      return n <= 0 ? s : "left" === align ? repeat(c, n) + s : "center" === align ? repeat(c, Math.floor(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);
    };
  var pad$1 = pad;

  const clamp = function (input, min, max) {
    return input < min ? min : input > max ? max : input;
  };
  var clamp$1 = clamp;

  function clamper(a, b) {
    let t;
    return a > b && (t = a, a = b, b = t), x => Math.max(a, Math.min(b, x));
  }

  function interpolateNumber(a, b) {
    return t => a * (1 - t) + b * t;
  }
  function interpolateNumberRound(a, b) {
    return function (t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }
  function interpolateDate(a, b) {
    const aVal = a.valueOf(),
      bVal = b.valueOf(),
      d = new Date();
    return t => (d.setTime(aVal * (1 - t) + bVal * t), d);
  }

  const TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function toDate(val) {
    if (val instanceof Date) return val;
    if (isString$1(val)) {
      const match = TIME_REG.exec(val);
      if (!match) return new Date(NaN);
      if (!match[8]) return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
      let hour = +match[4] || 0;
      return "Z" !== match[8].toUpperCase() && (hour -= +match[8].slice(0, 3)), new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
    return isNil$1(val) ? new Date(NaN) : new Date(Math.round(val));
  }

  function hslToRgb(h, s, l) {
    s /= 100, l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s,
      x = c * (1 - Math.abs(h / 60 % 2 - 1)),
      m = l - c / 2;
    let r = 0,
      g = 0,
      b = 0;
    return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
      r: r,
      g: g,
      b: b
    };
  }

  function rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    const cMin = Math.min(r, g, b),
      cMax = Math.max(r, g, b),
      delta = cMax - cMin;
    let h = 0,
      s = 0,
      l = 0;
    return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
      h: h,
      s: s,
      l: l
    };
  }

  const REG_HEX = /^#([0-9a-f]{3,8})$/,
    DEFAULT_COLORS_OPACITY = {
      transparent: 4294967040
    };
  const DEFAULT_COLORS = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  function hex(value) {
    return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
  }
  function rgb(value) {
    return isNumber$1(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray$1(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
  }
  function rgba(value) {
    return isNumber$1(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray$1(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
  }
  function SRGBToLinear(c) {
    return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
  }
  class Color {
    static Brighter(source) {
      let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return 1 === b ? source : new Color(source).brighter(b).toRGBA();
    }
    static SetOpacity(source) {
      let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
    }
    static getColorBrightness(source) {
      let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hsl";
      const color = source instanceof Color ? source : new Color(source);
      switch (model) {
        case "hsv":
        default:
          return color.getHSVBrightness();
        case "hsl":
          return color.getHSLBrightness();
        case "lum":
          return color.getLuminance();
        case "lum2":
          return color.getLuminance2();
        case "lum3":
          return color.getLuminance3();
      }
    }
    static parseColorString(value) {
      if (isValid$1(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
      if (isValid$1(DEFAULT_COLORS[value])) return rgb(DEFAULT_COLORS[value]);
      const formatValue = `${value}`.trim().toLowerCase(),
        isHex = REG_HEX.exec(formatValue);
      if (isHex) {
        const hex = parseInt(isHex[1], 16),
          hexLength = isHex[1].length;
        return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : void 0;
      }
      if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
        const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
        return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
      }
      if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
        const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
          rgb = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
        return new RGB(rgb.r, rgb.g, rgb.b, parseFloat(aColor[3]));
      }
    }
    constructor(value) {
      const color = Color.parseColorString(value);
      color ? this.color = color : (console.warn(`Warn: 传入${value}无法解析为Color`), this.color = new RGB(255, 255, 255));
    }
    toRGBA() {
      return this.color.formatRgb();
    }
    toString() {
      return this.color.formatRgb();
    }
    toHex() {
      return this.color.formatHex();
    }
    toHsl() {
      return this.color.formatHsl();
    }
    brighter(k) {
      const {
        r: r,
        g: g,
        b: b
      } = this.color;
      return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
    }
    add(color) {
      const {
        r: r,
        g: g,
        b: b
      } = this.color;
      return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
    }
    sub(color) {
      return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
    }
    multiply(color) {
      const {
        r: r,
        g: g,
        b: b
      } = this.color;
      return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
    }
    getHSVBrightness() {
      return Math.max(this.color.r, this.color.g, this.color.b) / 255;
    }
    getHSLBrightness() {
      return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
    }
    setHsl(h, s, l) {
      const opacity = this.color.opacity,
        hsl = rgbToHsl(this.color.r, this.color.g, this.color.b),
        rgb = hslToRgb(isNil$1(h) ? hsl.h : clamp$1(h, 0, 360), isNil$1(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, isNil$1(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
      return this.color = new RGB(rgb.r, rgb.g, rgb.b, opacity), this;
    }
    setRGB(r, g, b) {
      return !isNil$1(r) && (this.color.r = r), !isNil$1(g) && (this.color.g = g), !isNil$1(b) && (this.color.b = b), this;
    }
    setHex(value) {
      const formatValue = `${value}`.trim().toLowerCase(),
        isHex = REG_HEX.exec(formatValue),
        hex = parseInt(isHex[1], 16),
        hexLength = isHex[1].length;
      return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : this;
    }
    setColorName(name) {
      const hex = DEFAULT_COLORS[name.toLowerCase()];
      return void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + name), this;
    }
    setScalar(scalar) {
      return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
    }
    setOpacity() {
      let o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.color.opacity = o, this;
    }
    getLuminance() {
      return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
    }
    getLuminance2() {
      return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
    }
    getLuminance3() {
      return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
    }
    clone() {
      return new Color(this.color.toString());
    }
    copyGammaToLinear(color) {
      let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
    }
    copyLinearToGamma(color) {
      let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
      return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
    }
    convertGammaToLinear(gammaFactor) {
      return this.copyGammaToLinear(this, gammaFactor), this;
    }
    convertLinearToGamma(gammaFactor) {
      return this.copyLinearToGamma(this, gammaFactor), this;
    }
    copySRGBToLinear(color) {
      return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
    }
    copyLinearToSRGB(color) {
      return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
  }
  class RGB {
    constructor(r, g, b, opacity) {
      this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid$1(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
    }
    formatHex() {
      return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
    }
    formatRgb() {
      const opacity = this.opacity;
      return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
    }
    formatHsl() {
      const opacity = this.opacity,
        {
          h: h,
          s: s,
          l: l
        } = rgbToHsl(this.r, this.g, this.b);
      return `${1 === opacity ? "hsl(" : "hsla("}${h},${s}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
    }
    toString() {
      return this.formatHex();
    }
  }

  function hexToRgb(str) {
    let r = "",
      g = "",
      b = "";
    const strtIndex = "#" === str[0] ? 1 : 0;
    for (let i = strtIndex; i < str.length; i++) "#" !== str[i] && (i < strtIndex + 2 ? r += str[i] : i < strtIndex + 4 ? g += str[i] : i < strtIndex + 6 && (b += str[i]));
    return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
  }

  function rgbToHex(r, g, b) {
    return Number((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function interpolateRgb$1(colorA, colorB) {
    const redA = colorA.r,
      redB = colorB.r,
      greenA = colorA.g,
      greenB = colorB.g,
      blueA = colorA.b,
      blueB = colorB.b,
      opacityA = colorA.opacity,
      opacityB = colorB.opacity;
    return t => {
      const r = Math.round(redA * (1 - t) + redB * t),
        g = Math.round(greenA * (1 - t) + greenB * t),
        b = Math.round(blueA * (1 - t) + blueB * t);
      return new RGB(r, g, b, opacityA * (1 - t) + opacityB * t);
    };
  }

  var ColorUtil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Color: Color,
    DEFAULT_COLORS: DEFAULT_COLORS,
    RGB: RGB,
    hexToRgb: hexToRgb,
    hslToRgb: hslToRgb,
    interpolateRgb: interpolateRgb$1,
    rgbToHex: rgbToHex,
    rgbToHsl: rgbToHsl
  });

  function fullYearGetterName(isUTC) {
    return isUTC ? "getUTCFullYear" : "getFullYear";
  }
  function monthGetterName(isUTC) {
    return isUTC ? "getUTCMonth" : "getMonth";
  }
  function dateGetterName(isUTC) {
    return isUTC ? "getUTCDate" : "getDate";
  }
  function hoursGetterName(isUTC) {
    return isUTC ? "getUTCHours" : "getHours";
  }
  function minutesGetterName(isUTC) {
    return isUTC ? "getUTCMinutes" : "getMinutes";
  }
  function secondsGetterName(isUTC) {
    return isUTC ? "getUTCSeconds" : "getSeconds";
  }
  function millisecondsGetterName(isUTC) {
    return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
  }
  function fullYearSetterName(isUTC) {
    return isUTC ? "setUTCFullYear" : "setFullYear";
  }
  function monthSetterName(isUTC) {
    return isUTC ? "setUTCMonth" : "setMonth";
  }
  function hoursSetterName(isUTC) {
    return isUTC ? "setUTCHours" : "setHours";
  }
  function getFormatFromValue(value, isUTC) {
    const date = toDate(value),
      M = date[monthGetterName(isUTC)]() + 1,
      d = date[dateGetterName(isUTC)](),
      h = date[hoursGetterName(isUTC)](),
      m = date[minutesGetterName(isUTC)](),
      s = date[secondsGetterName(isUTC)](),
      isSecond = 0 === date[millisecondsGetterName(isUTC)](),
      isMinute = isSecond && 0 === s,
      isHour = isMinute && 0 === m,
      isDay = isHour && 0 === h,
      isMonth = isDay && 1 === d;
    return isMonth && 1 === M ? "YYYY" : isMonth ? "YYYY-MM" : isDay ? "YYYY-MM-DD" : isHour ? "HH" : isMinute ? "HH:mm" : isSecond ? "HH:mm:ss" : "HH:mm:ss SSS";
  }
  function getTimeFormatter(template, isUTC) {
    return time => {
      const date = toDate(time),
        y = date[fullYearGetterName(isUTC)](),
        M = date[monthGetterName(isUTC)]() + 1,
        q = Math.floor((M - 1) / 3) + 1,
        d = date[dateGetterName(isUTC)](),
        e = date["get" + (isUTC ? "UTC" : "") + "Day"](),
        H = date[hoursGetterName(isUTC)](),
        h = (H - 1) % 12 + 1,
        m = date[minutesGetterName(isUTC)](),
        s = date[secondsGetterName(isUTC)](),
        S = date[millisecondsGetterName(isUTC)]();
      return (template || "").replace(/YYYY/g, pad$1(y + "", 4, "0", "left")).replace(/yyyy/g, y + "").replace(/yy/g, y % 100 + "").replace(/Q/g, q + "").replace(/MM/g, pad$1(M, 2, "0", "left")).replace(/M/g, M + "").replace(/dd/g, pad$1(d, 2, "0", "left")).replace(/d/g, d + "").replace(/e/g, e + "").replace(/HH/g, pad$1(H, 2, "0", "left")).replace(/H/g, H + "").replace(/hh/g, pad$1(h + "", 2, "0", "left")).replace(/h/g, h + "").replace(/mm/g, pad$1(m, 2, "0", "left")).replace(/m/g, m + "").replace(/ss/g, pad$1(s, 2, "0", "left")).replace(/s/g, s + "").replace(/SSS/g, pad$1(S, 3, "0", "left")).replace(/S/g, S + "");
    };
  }

  const SECOND = 1e3;
  const MINUTE = 6e4;
  const HOUR = 36e5;
  const DAY = 24 * HOUR;
  const MONTH = 31 * DAY;
  const YEAR = 365 * DAY;
  const yearFloor = date => (date.setMonth(0, 1), date.setHours(0, 0, 0, 0), date);
  const yearOffset = (date, step) => (date.setFullYear(date.getFullYear() + step), date);
  const yearCount = (start, end) => end.getFullYear() - start.getFullYear();
  const yearField = date => date.getFullYear();
  const utcYearFloor = date => (date.setUTCMonth(0, 1), date.setUTCHours(0, 0, 0, 0), date);
  const utcYearOffset = (date, step) => (date.setUTCFullYear(date.getUTCFullYear() + step), date);
  const utcYearCount = (start, end) => end.getUTCFullYear() - start.getUTCFullYear();
  const utcYearField = date => date.getUTCFullYear();
  const monthFloor = date => (date.setDate(1), date.setHours(0, 0, 0, 0), date);
  const monthOffset = (date, step) => (date.setMonth(date.getMonth() + step), date);
  const monthCount = (start, end) => end.getMonth() - start.getMonth() + 12 * (end.getFullYear() - start.getFullYear());
  const monthField = date => date.getMonth();
  const utcMonthFloor = date => (date.setUTCDate(1), date.setUTCHours(0, 0, 0, 0), date);
  const utcMonthOffset = (date, step) => (date.setUTCMonth(date.getUTCMonth() + step), date);
  const utcMonthCount = (start, end) => end.getUTCMonth() - start.getUTCMonth() + 12 * (end.getUTCFullYear() - start.getUTCFullYear());
  const utcMonthField = date => date.getUTCMonth();
  const dayFloor = date => (date.setHours(0, 0, 0, 0), date);
  const dayOffset = (date, step) => (date.setDate(date.getDate() + step), date);
  const dayCount = (start, end) => (+end - +start - 6e4 * (end.getTimezoneOffset() - start.getTimezoneOffset())) / DAY;
  const dayField = date => date.getDate() - 1;
  const utcDayFloor = date => (date.setUTCHours(0, 0, 0, 0), date);
  const utcDayOffset = (date, step) => (date.setUTCDate(date.getUTCDate() + step), date);
  const utcDayCount = (start, end) => (+end - +start) / DAY;
  const utcDayField = date => date.getUTCDate() - 1;
  const hourFloor = date => (date.setTime(+date - date.getMilliseconds() - 1e3 * date.getSeconds() - 6e4 * date.getMinutes()), date);
  const hourOffset = (date, step) => (date.setHours(date.getHours() + step), date);
  const hourCount = (start, end) => (+end - +start) / HOUR;
  const hourField = date => date.getHours();
  const utcHourFloor = date => (date.setTime(+date - date.getUTCMilliseconds() - 1e3 * date.getUTCSeconds() - 6e4 * date.getUTCMinutes()), date);
  const utcHourOffset = (date, step) => (date.setUTCHours(date.getUTCHours() + step), date);
  const utcHourField = date => date.getUTCHours();
  const minuteFloor = date => (date.setTime(+date - date.getMilliseconds() - 1e3 * date.getSeconds()), date);
  const minuteOffset = (date, step) => (date.setMinutes(date.getMinutes() + step), date);
  const minuteCount = (start, end) => (+end - +start) / 6e4;
  const minuteField = date => date.getMinutes();
  const utcMinuteFloor = date => (date.setTime(+date - date.getUTCMilliseconds() - 1e3 * date.getUTCSeconds()), date);
  const utcMinuteOffset = (date, step) => (date.setUTCMinutes(date.getUTCMinutes() + step), date);
  const utcMinuteField = date => date.getUTCMinutes();
  const secondFloor = date => (date.setTime(+date - date.getMilliseconds()), date);
  const secondOffset = (date, step) => (date.setSeconds(date.getSeconds() + step), date);
  const secondCount = (start, end) => (+end - +start) / 1e3;
  const secondField = date => date.getSeconds();
  const utcSecondFloor = date => (date.setTime(+date - date.getUTCMilliseconds()), date);
  const utcSecondOffset = (date, step) => (date.setUTCSeconds(date.getUTCSeconds() + step), date);
  const utcSecondField = date => date.getUTCSeconds();
  const millisecondsFloor = date => date;
  const millisecondsOffset = (date, step) => (date.setTime(+date + step), date);
  const millisecondsCount = (start, end) => +end - +start;
  const generateCeil = (floor, offset) => date => {
    const n = new Date(+date - 1);
    return offset(n, 1), floor(n), n;
  };
  const generateCount = (floor, count) => (start, end) => {
    const a = new Date(),
      b = new Date();
    return a.setTime(+start), b.setTime(+end), floor(a), floor(b), Math.floor(count(a, b));
  };
  const generateStepInterval = (step, _ref) => {
    let {
      floor: floor,
      offset: offset,
      field: field,
      count: count
    } = _ref;
    const s = Math.floor(step);
    if (!Number.isFinite(s) || s <= 0) return null;
    if (s <= 1) return {
      floor: floor,
      offset: offset,
      ceil: generateCeil(floor, offset)
    };
    const stepCount = generateCount(floor, count),
      testFunc = field ? d => field(d) % s == 0 : d => stepCount(0, d) % s == 0,
      stepFloor = date => {
        if (!Number.isNaN(+date)) for (floor(date); !testFunc(date);) date.setTime(+date - 1), floor(date);
        return date;
      },
      stepOffset = (date, stepCount) => {
        if (!Number.isNaN(+date)) if (s < 0) for (; ++stepCount <= 0;) for (offset(date, -1); !testFunc(date);) offset(date, -1);else for (; --stepCount >= 0;) for (offset(date, 1); !testFunc(date);) offset(date, 1);
        return date;
      };
    return {
      floor: stepFloor,
      offset: stepOffset,
      ceil: generateCeil(stepFloor, stepOffset)
    };
  };
  const getIntervalOptions = (type, isUTC) => "year" === type && isUTC ? {
    floor: utcYearFloor,
    offset: utcYearOffset,
    count: utcYearCount,
    field: utcYearField
  } : "month" === type && isUTC ? {
    floor: utcMonthFloor,
    offset: utcMonthOffset,
    count: utcMonthCount,
    field: utcMonthField
  } : "day" === type && isUTC ? {
    floor: utcDayFloor,
    offset: utcDayOffset,
    count: utcDayCount,
    field: utcDayField
  } : "hour" === type && isUTC ? {
    floor: utcHourFloor,
    offset: utcHourOffset,
    count: hourCount,
    field: utcHourField
  } : "minute" === type && isUTC ? {
    floor: utcMinuteFloor,
    offset: utcMinuteOffset,
    count: minuteCount,
    field: utcMinuteField
  } : "second" === type && isUTC ? {
    floor: utcSecondFloor,
    offset: utcSecondOffset,
    count: secondCount,
    field: utcSecondField
  } : "year" === type ? {
    floor: yearFloor,
    offset: yearOffset,
    count: yearCount,
    field: yearField
  } : "month" === type ? {
    floor: monthFloor,
    offset: monthOffset,
    count: monthCount,
    field: monthField
  } : "day" === type ? {
    floor: dayFloor,
    offset: dayOffset,
    count: dayCount,
    field: dayField
  } : "hour" === type ? {
    floor: hourFloor,
    offset: hourOffset,
    count: hourCount,
    field: hourField
  } : "minute" === type ? {
    floor: minuteFloor,
    offset: minuteOffset,
    count: minuteCount,
    field: minuteField
  } : "second" === type ? {
    floor: secondFloor,
    offset: secondOffset,
    count: secondCount,
    field: secondField
  } : {
    floor: millisecondsFloor,
    offset: millisecondsOffset,
    count: millisecondsCount
  };

  exports.ScaleEnum = void 0;
  (function (ScaleEnum) {
      ScaleEnum["Identity"] = "identity";
      ScaleEnum["Linear"] = "linear";
      ScaleEnum["Log"] = "log";
      ScaleEnum["Pow"] = "pow";
      ScaleEnum["Sqrt"] = "sqrt";
      ScaleEnum["Symlog"] = "symlog";
      ScaleEnum["Time"] = "time";
      ScaleEnum["Quantile"] = "quantile";
      ScaleEnum["Quantize"] = "quantize";
      ScaleEnum["Threshold"] = "threshold";
      ScaleEnum["Ordinal"] = "ordinal";
      ScaleEnum["Point"] = "point";
      ScaleEnum["Band"] = "band";
  })(exports.ScaleEnum || (exports.ScaleEnum = {}));
  const EnableScaleMap = {};
  Object.values(exports.ScaleEnum).forEach(v => {
      EnableScaleMap[v] = true;
  });
  function isContinuous(type) {
      switch (type) {
          case exports.ScaleEnum.Linear:
          case exports.ScaleEnum.Log:
          case exports.ScaleEnum.Pow:
          case exports.ScaleEnum.Sqrt:
          case exports.ScaleEnum.Symlog:
          case exports.ScaleEnum.Time:
              return true;
          default:
              return false;
      }
  }
  function isValidScaleType(type) {
      return !!EnableScaleMap[type];
  }
  function isDiscrete(type) {
      switch (type) {
          case exports.ScaleEnum.Ordinal:
          case exports.ScaleEnum.Point:
          case exports.ScaleEnum.Band:
              return true;
          default:
              return false;
      }
  }
  function isDiscretizing(type) {
      switch (type) {
          case exports.ScaleEnum.Quantile:
          case exports.ScaleEnum.Quantize:
          case exports.ScaleEnum.Threshold:
              return true;
          default:
              return false;
      }
  }
  function supportRangeFactor(type) {
      switch (type) {
          case exports.ScaleEnum.Linear:
          case exports.ScaleEnum.Log:
          case exports.ScaleEnum.Pow:
          case exports.ScaleEnum.Sqrt:
          case exports.ScaleEnum.Symlog:
          case exports.ScaleEnum.Time:
          case exports.ScaleEnum.Band:
          case exports.ScaleEnum.Point:
              return true;
          default:
              return false;
      }
  }

  function identity(x) {
      return x;
  }
  const generatePow = (exponent) => {
      return (x) => {
          return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
  };
  const sqrt = (x) => {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  };
  const square = (x) => {
      return x < 0 ? -x * x : x * x;
  };
  const logNegative = (x) => {
      return -Math.log(-x);
  };
  const expNegative = (x) => {
      return -Math.exp(-x);
  };
  const pow10 = (x) => {
      return isFinite(x) ? Math.pow(10, x) : x < 0 ? 0 : x;
  };
  const powp = (base) => {
      return base === 10 ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
  };
  const logp = (base) => {
      return base === Math.E
          ? Math.log
          : base === 10
              ? Math.log10
              : base === 2
                  ? Math.log2
                  : ((base = Math.log(base)), (x) => Math.log(x) / base);
  };
  const symlog = (c) => {
      return (x) => {
          return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
  };
  const symexp = (c) => {
      return (x) => {
          return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
  };
  function normalize(a, b) {
      a = Number(a);
      b = Number(b);
      b -= a;
      if (b) {
          return (x) => {
              return (x - a) / b;
          };
      }
      const result = Number.isNaN(b) ? NaN : 0.5;
      return () => {
          return result;
      };
  }
  function bimap(domain, range, interpolate) {
      const d0 = domain[0];
      const d1 = domain[1];
      const r0 = range[0];
      const r1 = range[1];
      let d0Fuc;
      let r0Fuc;
      if (d1 < d0) {
          d0Fuc = normalize(d1, d0);
          r0Fuc = interpolate(r1, r0);
      }
      else {
          d0Fuc = normalize(d0, d1);
          r0Fuc = interpolate(r0, r1);
      }
      return (x) => {
          return r0Fuc(d0Fuc(x));
      };
  }
  function bandSpace(count, paddingInner, paddingOuter) {
      let space;
      if (count === 1) {
          space = count + paddingOuter * 2;
      }
      else {
          space = count - paddingInner + paddingOuter * 2;
      }
      return count ? (space > 0 ? space : 1) : 0;
  }
  function scaleWholeRangeSize(count, bandwidth, paddingInner, paddingOuter) {
      if (paddingInner === 1) {
          paddingInner = 0;
      }
      const space = bandSpace(count, paddingInner, paddingOuter);
      const step = bandwidth / (1 - paddingInner);
      const wholeSize = space * step;
      return wholeSize;
  }
  function calculateBandwidthFromWholeRangeSize(count, wholeSize, paddingInner, paddingOuter, round) {
      const space = bandSpace(count, paddingInner, paddingOuter);
      let step = wholeSize / Math.max(1, space || 1);
      if (round) {
          step = Math.floor(step);
      }
      let bandwidth = step * (1 - paddingInner);
      if (round) {
          bandwidth = Math.round(bandwidth);
      }
      return bandwidth;
  }
  function calculateWholeRangeFromRangeFactor(range, rangeFactor) {
      const k = (range[1] - range[0]) / (rangeFactor[1] - rangeFactor[0]);
      const b = range[0] - k * rangeFactor[0];
      const r0 = b;
      const r1 = k + b;
      return [r0, r1];
  }
  function polymap(domain, range, interpolate) {
      const j = Math.min(domain.length, range.length) - 1;
      const d = new Array(j);
      const r = new Array(j);
      let i = -1;
      if (domain[j] < domain[0]) {
          domain = domain.slice().reverse();
          range = range.slice().reverse();
      }
      while (++i < j) {
          d[i] = normalize(domain[i], domain[i + 1]);
          r[i] = interpolate(range[i], range[i + 1]);
      }
      return function (x) {
          const i = bisect(domain, x, 1, j) - 1;
          return r[i](d[i](x));
      };
  }
  const nice = (domain, options) => {
      const newDomain = domain.slice();
      let startIndex = 0;
      let endIndex = newDomain.length - 1;
      let x0 = newDomain[startIndex];
      let x1 = newDomain[endIndex];
      if (x1 < x0) {
          [startIndex, endIndex] = [endIndex, startIndex];
          [x0, x1] = [x1, x0];
      }
      newDomain[startIndex] = options.floor(x0);
      newDomain[endIndex] = options.ceil(x1);
      return newDomain;
  };
  const niceNumber = (value, round = false) => {
      const exponent = Math.floor(Math.log10(value));
      const fraction = value / Math.pow(10, exponent);
      let niceFraction;
      if (round) {
          if (fraction < 1.5) {
              niceFraction = 1;
          }
          else if (fraction < 3) {
              niceFraction = 2;
          }
          else if (fraction < 7) {
              niceFraction = 5;
          }
          else {
              niceFraction = 10;
          }
      }
      else {
          if (fraction <= 1) {
              niceFraction = 1;
          }
          else if (fraction <= 2) {
              niceFraction = 2;
          }
          else if (fraction <= 5) {
              niceFraction = 5;
          }
          else {
              niceFraction = 10;
          }
      }
      return niceFraction * Math.pow(10, exponent);
  };
  const restrictNumber = (value, domain) => {
      let min;
      let max;
      if (domain[0] < domain[1]) {
          min = domain[0];
          max = domain[1];
      }
      else {
          min = domain[1];
          max = domain[0];
      }
      return Math.min(Math.max(value, min), max);
  };

  class BaseScale {
      constructor() {
          this._rangeFactorStart = null;
          this._rangeFactorEnd = null;
      }
      _calculateWholeRange(range) {
          if (this._wholeRange) {
              return this._wholeRange;
          }
          if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && range.length === 2) {
              this._wholeRange = calculateWholeRangeFromRangeFactor(range, [this._rangeFactorStart, this._rangeFactorEnd]);
              return this._wholeRange;
          }
          return range;
      }
      rangeFactor(_, slience, clear) {
          if (!_) {
              if (clear) {
                  this._wholeRange = null;
                  this._rangeFactorStart = null;
                  this._rangeFactorEnd = null;
                  return this;
              }
              if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd)) {
                  return [this._rangeFactorStart, this._rangeFactorEnd];
              }
              return null;
          }
          if (_.length === 2 && _.every(r => r >= 0 && r <= 1)) {
              this._wholeRange = null;
              if (_[0] === 0 && _[1] === 1) {
                  this._rangeFactorStart = null;
                  this._rangeFactorEnd = null;
              }
              else {
                  this._rangeFactorStart = _[0];
                  this._rangeFactorEnd = _[1];
              }
          }
          return this;
      }
      rangeFactorStart(_, slience) {
          var _a;
          if (isNil$1(_)) {
              return this._rangeFactorStart;
          }
          if (_ >= 0 && _ <= 1) {
              this._wholeRange = null;
              if (_ === 0 && (isNil$1(this._rangeFactorEnd) || this._rangeFactorEnd === 1)) {
                  this._rangeFactorStart = null;
                  this._rangeFactorEnd = null;
              }
              else {
                  this._rangeFactorStart = _;
                  this._rangeFactorEnd = (_a = this._rangeFactorEnd) !== null && _a !== void 0 ? _a : 1;
              }
          }
          return this;
      }
      rangeFactorEnd(_, slience) {
          var _a;
          if (isNil$1(_)) {
              return this._rangeFactorEnd;
          }
          if (_ >= 0 && _ <= 1) {
              this._wholeRange = null;
              if (_ === 0 && (isNil$1(this._rangeFactorStart) || this._rangeFactorStart === 0)) {
                  this._rangeFactorStart = null;
                  this._rangeFactorEnd = null;
              }
              else {
                  this._rangeFactorEnd = _;
                  this._rangeFactorStart = (_a = this._rangeFactorStart) !== null && _a !== void 0 ? _a : 0;
              }
          }
          return this;
      }
      generateFishEyeTransform() {
          var _a;
          if (!this._fishEyeOptions) {
              this._fishEyeTransform = null;
              return;
          }
          const { distortion = 2, radiusRatio = 0.1, radius } = this._fishEyeOptions;
          const range = this.range();
          const first = range[0];
          const last = range[range.length - 1];
          const min = Math.min(first, last);
          const max = Math.max(first, last);
          const focus = clamp$1((_a = this._fishEyeOptions.focus) !== null && _a !== void 0 ? _a : 0, min, max);
          const rangeRadius = isNil$1(radius) ? (max - min) * radiusRatio : radius;
          let k0 = Math.exp(distortion);
          k0 = (k0 / (k0 - 1)) * rangeRadius;
          const k1 = distortion / rangeRadius;
          this._fishEyeTransform = (output) => {
              const delta = Math.abs(output - focus);
              if (delta >= rangeRadius) {
                  return output;
              }
              if (delta <= 1e-6) {
                  return focus;
              }
              const k = ((k0 * (1 - Math.exp(-delta * k1))) / delta) * 0.75 + 0.25;
              return focus + (output - focus) * k;
          };
      }
      unknown(_) {
          if (!arguments.length) {
              return this._unknown;
          }
          this._unknown = _;
          return this;
      }
  }

  const implicit$1 = Symbol('implicit');
  class OrdinalScale extends BaseScale {
      specified(_) {
          var _a;
          if (!_) {
              return Object.assign({}, this._specified);
          }
          this._specified = Object.assign((_a = this._specified) !== null && _a !== void 0 ? _a : {}, _);
          return this;
      }
      _getSpecifiedValue(input) {
          if (!this._specified) {
              return undefined;
          }
          return this._specified[input];
      }
      constructor() {
          super();
          this.type = exports.ScaleEnum.Ordinal;
          this._index = new Map();
          this._domain = [];
          this._ordinalRange = [];
          this._unknown = implicit$1;
      }
      clone() {
          return new OrdinalScale().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
      }
      calculateVisibleDomain(range) {
          if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && range.length === 2) {
              const d0 = this.invert(range[0]);
              const d1 = this.invert(range[1]);
              return [d0, d1];
          }
          return this._domain;
      }
      scale(d) {
          const key = `${d}`;
          const special = this._getSpecifiedValue(key);
          if (special !== undefined) {
              return special;
          }
          let i = this._index.get(key);
          if (!i) {
              if (this._unknown !== implicit$1) {
                  return this._unknown;
              }
              i = this._domain.push(d);
              this._index.set(key, i);
          }
          const output = this._ordinalRange[(i - 1) % this._ordinalRange.length];
          return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      invert(d) {
          let i = 0;
          while (i < this._ordinalRange.length && this._ordinalRange[i] !== d) {
              i++;
          }
          return this._domain[(i - 1) % this._domain.length];
      }
      domain(_) {
          if (!_) {
              return this._domain.slice();
          }
          this._domain = [];
          this._index = new Map();
          for (const value of _) {
              const key = `${value}`;
              if (this._index.has(key)) {
                  continue;
              }
              this._index.set(key, this._domain.push(value));
          }
          return this;
      }
      range(_) {
          if (!_) {
              return this._ordinalRange.slice();
          }
          const nextRange = Array.from(_);
          this._ordinalRange = nextRange;
          return this;
      }
  }

  function ticks$1(start, stop, count, allowExcessive) {
      let reverse;
      const ticks = [];
      let step;
      stop = Math.floor(+stop);
      start = Math.floor(+start);
      count = Math.floor(+count);
      if (!count) {
          return [];
      }
      if (start === stop) {
          return [start];
      }
      if ((reverse = stop < start)) {
          const n = start;
          start = stop;
          stop = n;
      }
      let expectedCount = clamper(1, stop - start + 1)(count);
      step = Math.floor((stop - start + 1) / expectedCount);
      if (!allowExcessive) {
          while (Math.ceil((stop - start + 1) / step) > count &&
              expectedCount > 1) {
              expectedCount -= 1;
              step = Math.floor((stop - start) / expectedCount);
          }
      }
      let ptr = start;
      while (ptr <= stop) {
          ticks.push(ptr);
          ptr += step;
      }
      if (reverse) {
          ticks.reverse();
      }
      return ticks;
  }
  function stepTicks$1(start, stop, step) {
      const ticks = [];
      let reverse;
      stop = Math.floor(+stop);
      start = Math.floor(+start);
      step = clamper(1, stop - start + 1)(Math.floor(+step));
      if ((reverse = stop < start)) {
          const n = start;
          start = stop;
          stop = n;
      }
      let ptr = start;
      while (ptr <= stop) {
          ticks.push(ptr);
          ptr += step;
      }
      if (reverse) {
          ticks.reverse();
      }
      return ticks;
  }

  class BandScale extends OrdinalScale {
      constructor(slience) {
          super();
          this.type = exports.ScaleEnum.Band;
          this._range = [0, 1];
          this._step = undefined;
          this._bandwidth = undefined;
          this._isFixed = false;
          this._round = false;
          this._paddingInner = 0;
          this._paddingOuter = 0;
          this._align = 0.5;
          this._unknown = undefined;
          delete this.unknown;
          this.rescale(slience);
      }
      rescale(slience, changeProperty) {
          if (slience) {
              return this;
          }
          this._wholeRange = null;
          const wholeRange = this._calculateWholeRange(this._range, changeProperty);
          const n = super.domain().length;
          const reverse = wholeRange[1] < wholeRange[0];
          let start = wholeRange[Number(reverse) - 0];
          const stop = wholeRange[1 - Number(reverse)];
          const space = bandSpace(n, this._paddingInner, this._paddingOuter);
          this._step = (stop - start) / Math.max(1, space || 1);
          if (this._round) {
              this._step = Math.floor(this._step);
          }
          start += (stop - start - this._step * (n - this._paddingInner)) * this._align;
          if (!this.isBandwidthFixed()) {
              this._bandwidth = this._step * (1 - this._paddingInner);
          }
          if (this._round) {
              start = Math.round(start);
              if (!this.isBandwidthFixed()) {
                  this._bandwidth = Math.round(this._bandwidth);
              }
          }
          this._bandRangeState = {
              reverse,
              start: reverse ? start + this._step * (n - 1) : start,
              count: n
          };
          this.generateFishEyeTransform();
          return this;
      }
      scale(d) {
          if (!this._bandRangeState) {
              return undefined;
          }
          const key = `${d}`;
          const special = this._getSpecifiedValue(key);
          if (special !== undefined) {
              return special;
          }
          let i = this._index.get(key);
          if (!i) {
              if (this._unknown !== implicit$1) {
                  return this._unknown;
              }
              i = this._domain.push(d);
              this._index.set(key, i);
          }
          const { count, start, reverse } = this._bandRangeState;
          const stepIndex = (i - 1) % count;
          const output = start + (reverse ? -1 : 1) * stepIndex * this._step;
          return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      _calculateWholeRange(range, changeProperty) {
          if (this._wholeRange) {
              return this._wholeRange;
          }
          if ((this._minBandwidth || this._maxBandwidth) && !this._isBandwidthFixedByUser()) {
              let wholeSize;
              if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && range.length === 2) {
                  const wholeRange = calculateWholeRangeFromRangeFactor(range, [this._rangeFactorStart, this._rangeFactorEnd]);
                  wholeSize = Math.abs(wholeRange[1] - wholeRange[0]);
              }
              else {
                  wholeSize = Math.abs(range[1] - range[0]);
              }
              const autoBandwidth = calculateBandwidthFromWholeRangeSize(super.domain().length, wholeSize, this._paddingInner, this._paddingOuter, this._round);
              if (autoBandwidth < this._minBandwidth) {
                  this._bandwidth = this._minBandwidth;
                  this._isFixed = true;
              }
              else if (autoBandwidth > this._maxBandwidth) {
                  this._bandwidth = this._maxBandwidth;
                  this._isFixed = true;
              }
              else {
                  this._bandwidth = autoBandwidth;
                  this._isFixed = false;
              }
          }
          if (this.isBandwidthFixed()) {
              const wholeLength = scaleWholeRangeSize(super.domain().length, this._bandwidth, this._paddingInner, this._paddingOuter) *
                  Math.sign(range[1] - range[0]);
              const rangeFactorSize = Math.min((range[1] - range[0]) / wholeLength, 1);
              if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd)) {
                  if (wholeLength > 0) {
                      const r0 = range[0] - wholeLength * this._rangeFactorStart;
                      const r1 = r0 + wholeLength;
                      this._wholeRange = [r0, r1];
                  }
                  else {
                      const r1 = range[1] + wholeLength * (1 - this._rangeFactorEnd);
                      const r0 = r1 - wholeLength;
                      this._wholeRange = [r0, r1];
                  }
                  const canAlignStart = this._rangeFactorStart + rangeFactorSize <= 1;
                  const canAlignEnd = this._rangeFactorEnd - rangeFactorSize >= 0;
                  if (changeProperty === 'rangeFactorStart' && canAlignStart) {
                      this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize;
                  }
                  else if (changeProperty === 'rangeFactorEnd' && canAlignEnd) {
                      this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize;
                  }
                  else {
                      if (range[0] <= range[1]) {
                          if (canAlignStart) {
                              this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize;
                          }
                          else if (canAlignEnd) {
                              this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize;
                          }
                          else {
                              this._rangeFactorStart = 0;
                              this._rangeFactorEnd = rangeFactorSize;
                          }
                      }
                      else {
                          if (canAlignEnd) {
                              this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize;
                          }
                          else if (canAlignStart) {
                              this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize;
                          }
                          else {
                              this._rangeFactorStart = 1 - rangeFactorSize;
                              this._rangeFactorEnd = 1;
                          }
                      }
                  }
              }
              else {
                  this._rangeFactorStart = 0;
                  this._rangeFactorEnd = rangeFactorSize;
                  this._wholeRange = [range[0], range[0] + wholeLength];
              }
              return this._wholeRange;
          }
          return super._calculateWholeRange(range);
      }
      calculateWholeRangeSize() {
          const wholeRange = this._calculateWholeRange(this._range);
          return Math.abs(wholeRange[1] - wholeRange[0]);
      }
      calculateVisibleDomain(range) {
          const domain = this._domain;
          if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && domain.length) {
              const d0 = this._getInvertIndex(range[0]);
              const d1 = this._getInvertIndex(range[1]);
              return domain.slice(Math.min(d0, d1), Math.max(d0, d1) + 1);
          }
          return domain;
      }
      domain(_, slience) {
          if (_) {
              super.domain(_);
              return this.rescale(slience);
          }
          return super.domain();
      }
      range(_, slience) {
          if (_) {
              this._range = [toNumber(_[0]), toNumber(_[1])];
              return this.rescale(slience);
          }
          return this._range;
      }
      rangeRound(_, slience) {
          this._range = [toNumber(_[0]), toNumber(_[1])];
          this._round = true;
          return this.rescale(slience);
      }
      ticks(count = 10) {
          const d = this.calculateVisibleDomain(this._range);
          if (count === -1) {
              return d;
          }
          const tickIndexList = ticks$1(0, d.length - 1, count, false);
          return tickIndexList.map(i => d[i]);
      }
      tickData(count = 10) {
          const ticks = this.ticks(count);
          return ticks.map((tick, index) => {
              const scaledValue = this.scale(tick);
              return {
                  index,
                  tick,
                  value: (scaledValue - this._range[0] + this._bandwidth / 2) / (this._range[1] - this._range[0])
              };
          });
      }
      forceTicks(count = 10) {
          const d = this.calculateVisibleDomain(this._range);
          const tickIndexList = ticks$1(0, d.length - 1, count, true);
          return tickIndexList
              .filter(i => i < d.length)
              .map(i => d[i]);
      }
      stepTicks(step) {
          const d = this.calculateVisibleDomain(this._range);
          const tickIndexList = stepTicks$1(0, d.length - 1, step);
          return tickIndexList.map(i => d[i]);
      }
      _getInvertIndex(d) {
          let i = 0;
          const halfStep = this.step() / 2;
          const halfBandwidth = this.bandwidth() / 2;
          const len = this._domain.length;
          const range = this.range();
          const start = range[0];
          const stop = range[range.length - 1];
          const reverse = start > stop;
          for (i = 0; i < len; i++) {
              const r = this.scale(this._domain[i]) + halfBandwidth;
              if (i === 0 && ((!reverse && !isGreater(d, r + halfStep)) || (reverse && !isLess(d, r - halfStep)))) {
                  break;
              }
              if (i === len - 1) {
                  break;
              }
              if (!isLess(d, r - halfStep) && !isGreater(d, r + halfStep)) {
                  break;
              }
          }
          if (i >= 0 && i <= len - 1) {
              return i;
          }
          return len - 1;
      }
      invert(d) {
          return this._domain[this._getInvertIndex(d)];
      }
      padding(p, slience) {
          if (p !== undefined) {
              this._paddingOuter = Math.max(0, Math.min(Array.isArray(p) ? Math.min.apply(null, p) : p));
              this._paddingInner = this._paddingOuter;
              return this.rescale(slience);
          }
          return this._paddingInner;
      }
      paddingInner(_, slience) {
          if (_ !== undefined) {
              this._paddingInner = Math.max(0, Math.min(1, _));
              return this.rescale(slience);
          }
          return this._paddingInner;
      }
      paddingOuter(_, slience) {
          if (_ !== undefined) {
              this._paddingOuter = Math.max(0, Math.min(1, _));
              return this.rescale(slience);
          }
          return this._paddingOuter;
      }
      step() {
          return this._step;
      }
      round(_, slience) {
          if (_ !== undefined) {
              this._round = _;
              return this.rescale(slience);
          }
          return this._round;
      }
      align(_, slience) {
          if (_ !== undefined) {
              this._align = Math.max(0, Math.min(1, _));
              return this.rescale(slience);
          }
          return this._align;
      }
      rangeFactor(_, slience) {
          if (!_) {
              return super.rangeFactor();
          }
          super.rangeFactor(_);
          return this.rescale(slience);
      }
      rangeFactorStart(_, slience) {
          if (isNil$1(_)) {
              return super.rangeFactorStart();
          }
          super.rangeFactorStart(_);
          return this.rescale(slience, 'rangeFactorStart');
      }
      rangeFactorEnd(_, slience) {
          if (isNil$1(_)) {
              return super.rangeFactorEnd();
          }
          super.rangeFactorEnd(_);
          return this.rescale(slience, 'rangeFactorEnd');
      }
      bandwidth(_, slience) {
          if (!_) {
              return this._bandwidth;
          }
          if (_ === 'auto') {
              this._bandwidth = undefined;
              this._isFixed = false;
          }
          else {
              this._bandwidth = _;
              this._isFixed = true;
          }
          this._userBandwidth = _;
          return this.rescale(slience);
      }
      maxBandwidth(_, slience) {
          if (!_) {
              return this._maxBandwidth;
          }
          if (_ === 'auto') {
              this._maxBandwidth = undefined;
          }
          else {
              this._maxBandwidth = _;
          }
          return this.rescale(slience);
      }
      minBandwidth(_, slience) {
          if (!_) {
              return this._minBandwidth;
          }
          if (_ === 'auto') {
              this._minBandwidth = undefined;
          }
          else {
              this._minBandwidth = _;
          }
          return this.rescale(slience);
      }
      fishEye(options, slience, clear) {
          if (options || clear) {
              this._fishEyeOptions = options;
              this._fishEyeTransform = null;
              return this.rescale(slience);
          }
          return this._fishEyeOptions;
      }
      isBandwidthFixed() {
          return this._isFixed && !!this._bandwidth;
      }
      _isBandwidthFixedByUser() {
          return this._isFixed && this._userBandwidth && isNumber$1(this._userBandwidth);
      }
      clone() {
          var _a, _b, _c;
          const bandScale = new BandScale(true)
              .domain(this._domain, true)
              .range(this._range, true)
              .round(this._round, true)
              .paddingInner(this._paddingInner, true)
              .paddingOuter(this._paddingOuter, true)
              .align(this._align, true)
              .bandwidth((_a = this._userBandwidth) !== null && _a !== void 0 ? _a : 'auto', true)
              .maxBandwidth((_b = this._maxBandwidth) !== null && _b !== void 0 ? _b : 'auto', true)
              .minBandwidth((_c = this._maxBandwidth) !== null && _c !== void 0 ? _c : 'auto');
          return bandScale;
      }
  }

  const { interpolateRgb } = ColorUtil;
  function interpolate(a, b) {
      const t = typeof b;
      let c;
      if (isNil$1(b) || t === 'boolean') {
          return () => b;
      }
      if (t === 'number') {
          return interpolateNumber(a, b);
      }
      if (t === 'string') {
          if ((c = Color.parseColorString(b))) {
              const rgb = interpolateRgb(Color.parseColorString(a), c);
              return (t) => {
                  return rgb(t).formatRgb();
              };
          }
          return interpolateNumber(Number(a), Number(b));
      }
      if (b instanceof RGB) {
          return interpolateRgb(a, b);
      }
      if (b instanceof Color) {
          return interpolateRgb(a.color, b.color);
      }
      if (b instanceof Date) {
          return interpolateDate(a, b);
      }
      return interpolateNumber(Number(a), Number(b));
  }

  class ContinuousScale extends BaseScale {
      constructor(transformer = identity, untransformer = identity) {
          super();
          this._unknown = undefined;
          this.transformer = transformer;
          this.untransformer = untransformer;
          this._forceAlign = true;
          this._domain = [0, 1];
          this._range = [0, 1];
          this._clamp = identity;
          this._piecewise = bimap;
          this._interpolate = interpolate;
      }
      calculateVisibleDomain(range) {
          var _a;
          if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && range.length === 2) {
              const d0 = this.invert(range[0]);
              const d1 = this.invert(range[1]);
              return [d0, d1];
          }
          return (_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain;
      }
      fishEye(options, slience, clear) {
          if (options || clear) {
              this._fishEyeOptions = options;
              this._fishEyeTransform = null;
              return this.rescale(slience);
          }
          return this._fishEyeOptions;
      }
      scale(x) {
          var _a;
          x = Number(x);
          if (Number.isNaN(x) || (this._domainValidator && !this._domainValidator(x))) {
              return this._unknown;
          }
          if (!this._output) {
              this._output = this._piecewise(((_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate);
          }
          const output = this._output(this.transformer(this._clamp(x)));
          return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      invert(y) {
          var _a;
          if (!this._input) {
              this._input = this._piecewise(this._calculateWholeRange(this._range), ((_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain).map(this.transformer), interpolateNumber);
          }
          return this._clamp(this.untransformer(this._input(y)));
      }
      domain(_, slience) {
          var _a;
          if (!_) {
              return ((_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain).slice();
          }
          this._domainValidator = null;
          this._niceType = null;
          this._niceDomain = null;
          const nextDomain = Array.from(_, toNumber);
          this._domain = nextDomain;
          return this.rescale(slience);
      }
      range(_, slience) {
          if (!_) {
              return this._range.slice();
          }
          const nextRange = Array.from(_);
          this._range = nextRange;
          return this.rescale(slience);
      }
      rangeRound(_, slience) {
          const nextRange = Array.from(_);
          this._range = nextRange;
          this._interpolate = interpolateNumberRound;
          return this.rescale(slience);
      }
      rescale(slience) {
          var _a;
          if (slience) {
              return this;
          }
          const domain = (_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain;
          const domainLength = domain.length;
          const rangeLength = this._range.length;
          let n = Math.min(domainLength, rangeLength);
          if (domainLength && domainLength < rangeLength && this._forceAlign) {
              const deltaStep = rangeLength - domainLength + 1;
              const last = domain[domainLength - 1];
              const delta = domainLength >= 2 ? (last - domain[domainLength - 2]) / deltaStep : 0;
              for (let i = 1; i <= deltaStep; i++) {
                  domain[domainLength - 2 + i] = last - delta * (deltaStep - i);
              }
              n = rangeLength;
          }
          if (this._clamp === undefined) {
              this._clamp = clamper(domain[0], domain[n - 1]);
          }
          this._piecewise = n > 2 ? polymap : bimap;
          this._output = this._input = null;
          this._wholeRange = null;
          this.generateFishEyeTransform();
          return this;
      }
      clamp(_, f, slience) {
          if (!arguments.length) {
              return this._clamp !== identity;
          }
          if (f) {
              this._clamp = f;
          }
          else {
              this._clamp = _ ? undefined : identity;
          }
          return this.rescale(slience);
      }
      interpolate(_, slience) {
          if (!arguments.length) {
              return this._interpolate;
          }
          this._interpolate = _;
          return this.rescale(slience);
      }
      ticks(count = 10) {
          return [];
      }
      tickData(count = 10) {
          const ticks = this.ticks(count);
          return (ticks !== null && ticks !== void 0 ? ticks : []).map((tick, index) => {
              const scaledValue = this.scale(tick);
              return {
                  index,
                  tick,
                  value: (scaledValue - this._range[0]) / (this._range[1] - this._range[0])
              };
          });
      }
      rangeFactor(_, slience) {
          if (!_) {
              return super.rangeFactor();
          }
          super.rangeFactor(_);
          this._output = this._input = null;
          return this;
      }
      rangeFactorStart(_, slience) {
          if (isNil$1(_)) {
              return super.rangeFactorStart();
          }
          super.rangeFactorStart(_);
          this._output = this._input = null;
          return this;
      }
      rangeFactorEnd(_, slience) {
          if (isNil$1(_)) {
              return super.rangeFactorEnd();
          }
          super.rangeFactorEnd(_);
          this._output = this._input = null;
          return this;
      }
      forceAlignDomainRange(forceAlign) {
          if (!arguments.length) {
              return this._forceAlign;
          }
          this._forceAlign = forceAlign;
          return this;
      }
  }

  const e10 = Math.sqrt(50);
  const e5 = Math.sqrt(10);
  const e2 = Math.sqrt(2);
  const niceNumbers = [1, 2, 5, 10];
  const calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
      let step = 1;
      let start = value;
      const middleIndex = Math.floor((tickCount - 1) / 2);
      const absVal = Math.abs(value);
      if (value >= 0 && value <= Number.MIN_VALUE) {
          start = 0;
      }
      else if (value < 0 && value >= -Number.MIN_VALUE) {
          start = -(tickCount - 1);
      }
      else if (!noDecimals && absVal < 1) {
          step = getNickStep(absVal).step;
      }
      else if (noDecimals || absVal > 1) {
          start = Math.floor(value) - middleIndex * step;
      }
      if (step > 0) {
          if (value > 0) {
              start = Math.max(start, 0);
          }
          else if (value < 0) {
              start = Math.min(start, -(tickCount - 1) * step);
          }
          return range(0, tickCount).map((index) => start + index * step);
      }
      return value > 0
          ? calculateTicksByStep(0, -(tickCount - 1) / step, step)
          : calculateTicksByStep((tickCount - 1) / step, 0, step);
  };
  const d3Ticks = memoize((start, stop, count, options) => {
      let reverse;
      let i = -1;
      let n;
      let ticks;
      let step;
      stop = +stop;
      start = +start;
      count = +count;
      if (start === stop) {
          return [start];
      }
      if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) {
          return [start];
      }
      if ((reverse = stop < start)) {
          n = start;
          start = stop;
          stop = n;
      }
      step = tickIncrement(start, stop, count).step;
      if (!isFinite(step)) {
          return [];
      }
      if (step > 0) {
          let r0 = Math.round(start / step);
          let r1 = Math.round(stop / step);
          if (r0 * step < start) {
              ++r0;
          }
          if (r1 * step > stop) {
              --r1;
          }
          ticks = new Array((n = r1 - r0 + 1));
          while (++i < n) {
              ticks[i] = (r0 + i) * step;
          }
      }
      else if (step < 0 && (options === null || options === void 0 ? void 0 : options.noDecimals)) {
          step = 1;
          const r0 = Math.ceil(start);
          const r1 = Math.floor(stop);
          if (r0 <= r1) {
              ticks = new Array((n = r1 - r0 + 1));
              while (++i < n) {
                  ticks[i] = r0 + i;
              }
          }
          else {
              return [];
          }
      }
      else {
          step = -step;
          let r0 = Math.round(start * step);
          let r1 = Math.round(stop * step);
          if (r0 / step < start) {
              ++r0;
          }
          if (r1 / step > stop) {
              --r1;
          }
          ticks = new Array((n = r1 - r0 + 1));
          while (++i < n) {
              ticks[i] = (r0 + i) / step;
          }
      }
      if (reverse) {
          ticks.reverse();
      }
      return ticks;
  });
  const calculateTicksByStep = (start, stop, step) => {
      let i = -1;
      let n;
      let ticks;
      if (step > 0) {
          let r0 = Math.floor(start / step);
          let r1 = Math.ceil(stop / step);
          if ((r0 + 1) * step < start) {
              ++r0;
          }
          if ((r1 - 1) * step > stop) {
              --r1;
          }
          ticks = new Array((n = r1 - r0 + 1));
          while (++i < n) {
              ticks[i] = (r0 + i) * step;
          }
      }
      else {
          step = -step;
          let r0 = Math.floor(start * step);
          let r1 = Math.ceil(stop * step);
          if ((r0 + 1) / step < start) {
              ++r0;
          }
          if ((r1 - 1) / step > stop) {
              --r1;
          }
          ticks = new Array((n = r1 - r0 + 1));
          while (++i < n) {
              ticks[i] = (r0 + i) / step;
          }
      }
      return ticks;
  };
  const appendTicksToCount = (ticks, count, step) => {
      let n;
      const firstTick = ticks[0];
      const lastTick = ticks[ticks.length - 1];
      const appendCount = count - ticks.length;
      if (lastTick <= 0) {
          const headTicks = [];
          for (n = appendCount; n >= 1; n--) {
              headTicks.push(firstTick - n * step);
          }
          return headTicks.concat(ticks);
      }
      else if (firstTick >= 0) {
          for (n = 1; n <= appendCount; n++) {
              ticks.push(lastTick + n * step);
          }
          return ticks;
      }
      let headTicks = [];
      const tailTicks = [];
      for (n = 1; n <= appendCount; n++) {
          if (n % 2 === 0) {
              headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks);
          }
          else {
              tailTicks.push(lastTick + Math.ceil(n / 2) * step);
          }
      }
      return headTicks.concat(ticks).concat(tailTicks);
  };
  const ticks = memoize((start, stop, count, options) => {
      let reverse;
      let ticks;
      let n;
      const maxIterations = 5;
      stop = +stop;
      start = +start;
      count = +count;
      if (start === stop) {
          return calculateTicksOfSingleValue(start, count, options === null || options === void 0 ? void 0 : options.noDecimals);
      }
      if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) {
          return calculateTicksOfSingleValue(start, count, options === null || options === void 0 ? void 0 : options.noDecimals);
      }
      if ((reverse = stop < start)) {
          n = start;
          start = stop;
          stop = n;
      }
      const stepRes = tickIncrement(start, stop, count);
      let step = stepRes.step;
      if (!isFinite(step)) {
          return [];
      }
      if (step > 0) {
          let cur = 1;
          const { power, gap } = stepRes;
          const delatStep = gap === 10 ? 2 * 10 ** power : 1 * 10 ** power;
          while (cur <= maxIterations &&
              ((ticks = calculateTicksByStep(start, stop, step)), ticks.length > count + 1) &&
              count > 2) {
              step += delatStep;
              cur += 1;
          }
          if (count > 2 && ticks.length < count - 1) {
              ticks = appendTicksToCount(ticks, count, step);
          }
      }
      else {
          if ((options === null || options === void 0 ? void 0 : options.noDecimals) && step < 0) {
              step = 1;
          }
          ticks = calculateTicksByStep(start, stop, step);
      }
      if (reverse) {
          ticks.reverse();
      }
      return ticks;
  });
  const getNickStep = (step) => {
      const power = Math.floor(Math.log(step) / Math.LN10);
      const error = step / 10 ** power;
      let gap = niceNumbers[0];
      if (error >= e10) {
          gap = niceNumbers[3];
      }
      else if (error >= e5) {
          gap = niceNumbers[2];
      }
      else if (error >= e2) {
          gap = niceNumbers[1];
      }
      if (power >= 0) {
          return { step: gap * 10 ** power, gap, power };
      }
      return { step: -(10 ** -power) / gap, gap, power };
  };
  function tickIncrement(start, stop, count) {
      const step = (stop - start) / Math.max(0, count);
      return getNickStep(step);
  }
  function forceTicks(start, stop, count) {
      let step;
      stop = +stop;
      start = +start;
      count = +count;
      if (start === stop && count > 0) {
          return [start];
      }
      if (count <= 0 || (step = forceTickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
          return [];
      }
      const ticks = new Array(count);
      for (let i = 0; i < count; i++) {
          ticks[i] = start + i * step;
      }
      return ticks;
  }
  function forceTickIncrement(start, stop, count) {
      const step = (stop - start) / Math.max(1, count - 1);
      return step;
  }
  function stepTicks(start, stop, step) {
      let i = -1;
      let n;
      let reverse;
      stop = +stop;
      start = +start;
      step = +step;
      if ((reverse = stop < start)) {
          n = start;
          start = stop;
          stop = n;
      }
      if (!isFinite(step) || stop - start <= step) {
          return [start];
      }
      const count = Math.floor((stop - start) / step + 1);
      const ticks = new Array(count);
      while (++i < count) {
          ticks[i] = start + i * step;
      }
      if (reverse) {
          ticks.reverse();
      }
      return ticks;
  }
  function niceLinear(d, count = 10) {
      let i0 = 0;
      let i1 = d.length - 1;
      let start = d[i0];
      let stop = d[i1];
      let prestep;
      let step;
      let maxIter = 10;
      if (stop < start) {
          step = start;
          start = stop;
          stop = step;
          step = i0;
          i0 = i1;
          i1 = step;
      }
      while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count).step;
          if (step === prestep) {
              d[i0] = start;
              d[i1] = stop;
              return d;
          }
          else if (step > 0) {
              start = Math.floor(start / step) * step;
              stop = Math.ceil(stop / step) * step;
          }
          else if (step < 0) {
              start = Math.ceil(start * step) / step;
              stop = Math.floor(stop * step) / step;
          }
          else {
              break;
          }
          prestep = step;
      }
      return;
  }
  function parseNiceOptions(originalDomain, option) {
      const hasForceMin = isNumber$1(option.forceMin);
      const hasForceMax = isNumber$1(option.forceMax);
      let niceType = null;
      const niceMinMax = [];
      let niceDomain = null;
      const domainValidator = hasForceMin && hasForceMax
          ? (x) => x >= option.forceMin && x <= option.forceMax
          : hasForceMin
              ? (x) => x >= option.forceMin
              : hasForceMax
                  ? (x) => x <= option.forceMax
                  : null;
      if (hasForceMin) {
          niceMinMax[0] = option.forceMin;
      }
      else if (isNumber$1(option.min) &&
          option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1])) {
          niceMinMax[0] = option.min;
      }
      if (hasForceMax) {
          niceMinMax[1] = option.forceMax;
      }
      else if (isNumber$1(option.max) &&
          option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1])) {
          niceMinMax[1] = option.max;
      }
      if (isNumber$1(niceMinMax[0]) && isNumber$1(niceMinMax[1])) {
          niceDomain = originalDomain.slice();
          niceDomain[0] = niceMinMax[0];
          niceDomain[niceDomain.length - 1] = niceMinMax[1];
      }
      else if (!isNumber$1(niceMinMax[0]) && !isNumber$1(niceMinMax[1])) {
          niceType = 'all';
      }
      else if (!isNumber$1(niceMinMax[0])) {
          niceType = 'min';
      }
      else {
          niceType = 'max';
      }
      return { niceType, niceDomain, niceMinMax, domainValidator };
  }
  const fixPrecision = (start, stop, value) => {
      return Math.abs(stop - start) < 1 ? +value.toFixed(1) : Math.round(+value);
  };
  const ticksBaseTransform = memoize((start, stop, count, base, transformer, untransformer) => {
      const ticksResult = [];
      const ticksMap = {};
      const startExp = transformer(start);
      const stopExp = transformer(stop);
      let ticksExp = [];
      if (Number.isInteger(base)) {
          ticksExp = ticks(startExp, stopExp, count);
      }
      else {
          const stepExp = (stopExp - startExp) / (count - 1);
          for (let i = 0; i < count; i++) {
              ticksExp.push(startExp + i * stepExp);
          }
      }
      ticksExp.forEach((tl) => {
          const power = untransformer(tl);
          const nicePower = Number.isInteger(base)
              ? fixPrecision(start, stop, power)
              : fixPrecision(start, stop, niceNumber(power));
          const scopePower = fixPrecision(start, stop, restrictNumber(nicePower, [start, stop]));
          if (!ticksMap[scopePower] && !isNaN(scopePower) && ticksExp.length > 1) {
              ticksMap[scopePower] = 1;
              ticksResult.push(scopePower);
          }
      });
      return ticksResult;
  });
  const forceTicksBaseTransform = memoize((start, stop, count, transformer, untransformer) => {
      const startExp = transformer(start);
      const stopExp = transformer(stop);
      const ticksExp = forceTicks(startExp, stopExp, count);
      return ticksExp.map((te) => niceNumber(untransformer(te)));
  });

  class LinearScale extends ContinuousScale {
      constructor() {
          super(...arguments);
          this.type = exports.ScaleEnum.Linear;
      }
      clone() {
          return new LinearScale()
              .domain(this._domain, true)
              .range(this._range, true)
              .unknown(this._unknown)
              .clamp(this.clamp(), null, true)
              .interpolate(this._interpolate);
      }
      tickFormat() {
          return () => {
          };
      }
      d3Ticks(count = 10, options) {
          const d = this.calculateVisibleDomain(this._range);
          return d3Ticks(d[0], d[d.length - 1], count, options);
      }
      ticks(count = 10, options) {
          var _a;
          if ((isValid$1(this._rangeFactorStart) &&
              isValid$1(this._rangeFactorEnd) &&
              (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) &&
              this._range.length === 2) ||
              !this._niceType) {
              return this.d3Ticks(count, options);
          }
          const curNiceDomain = (_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain;
          const originalDomain = this._domain;
          const start = curNiceDomain[0];
          const stop = curNiceDomain[curNiceDomain.length - 1];
          let ticksResult = ticks(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
          if (!ticksResult.length) {
              return ticksResult;
          }
          if (this._domainValidator) {
              ticksResult = ticksResult.filter(this._domainValidator);
          }
          else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
              const newNiceDomain = curNiceDomain.slice();
              if (this._niceType === 'all') {
                  newNiceDomain[0] = ticksResult[0];
                  newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1];
                  this._niceDomain = newNiceDomain;
                  this.rescale();
              }
              else if (this._niceType === 'min' && ticksResult[0] !== start) {
                  newNiceDomain[0] = ticksResult[0];
                  this._niceDomain = newNiceDomain;
                  this.rescale();
              }
              else if (this._niceType === 'max' && ticksResult[ticksResult.length - 1] !== stop) {
                  newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1];
                  this._niceDomain = newNiceDomain;
                  this.rescale();
              }
              if (this._niceType !== 'all') {
                  const min = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
                  const max = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
                  ticksResult = ticksResult.filter((entry) => entry >= min && entry <= max);
              }
          }
          return ticksResult;
      }
      forceTicks(count = 10) {
          const d = this.calculateVisibleDomain(this._range);
          return forceTicks(d[0], d[d.length - 1], count);
      }
      stepTicks(step) {
          const d = this.calculateVisibleDomain(this._range);
          return stepTicks(d[0], d[d.length - 1], step);
      }
      nice(count = 10, option) {
          var _a, _b;
          const originalDomain = this._domain;
          let niceMinMax = [];
          if (option) {
              const res = parseNiceOptions(originalDomain, option);
              niceMinMax = res.niceMinMax;
              this._domainValidator = res.domainValidator;
              this._niceType = res.niceType;
              if (res.niceDomain) {
                  this._niceDomain = res.niceDomain;
                  this.rescale();
                  return this;
              }
          }
          else {
              this._niceType = 'all';
          }
          if (this._niceType) {
              const niceDomain = niceLinear(originalDomain.slice(), count);
              if (this._niceType === 'min') {
                  niceDomain[niceDomain.length - 1] = (_a = niceMinMax[1]) !== null && _a !== void 0 ? _a : niceDomain[niceDomain.length - 1];
              }
              else if (this._niceType === 'max') {
                  niceDomain[0] = (_b = niceMinMax[0]) !== null && _b !== void 0 ? _b : niceDomain[0];
              }
              this._niceDomain = niceDomain;
              this.rescale();
          }
          return this;
      }
      niceMin(count = 10) {
          this._niceType = 'min';
          const maxD = this._domain[this._domain.length - 1];
          const niceDomain = niceLinear(this.domain(), count);
          if (niceDomain) {
              niceDomain[niceDomain.length - 1] = maxD;
              this._niceDomain = niceDomain;
              this.rescale();
          }
          return this;
      }
      niceMax(count = 10) {
          this._niceType = 'max';
          const minD = this._domain[0];
          const niceDomain = niceLinear(this._domain.slice(), count);
          if (niceDomain) {
              niceDomain[0] = minD;
              this._niceDomain = niceDomain;
              this.rescale();
          }
          return this;
      }
  }

  function reflect(f) {
      return (x) => -f(-x);
  }
  function limitPositiveZero(min = Number.EPSILON) {
      return (x) => {
          return Math.max(x, min);
      };
  }
  function limitNegativeZero(min = Number.EPSILON) {
      return (x) => {
          return Math.min(x, -min);
      };
  }
  class LogScale extends ContinuousScale {
      constructor() {
          super(logp(10), powp(10));
          this.type = exports.ScaleEnum.Log;
          this._limit = limitPositiveZero();
          this._logs = this.transformer;
          this._pows = this.untransformer;
          this._domain = [1, 10];
          this._base = 10;
      }
      clone() {
          return new LogScale()
              .domain(this._domain, true)
              .range(this._range, true)
              .unknown(this._unknown)
              .clamp(this.clamp(), null, true)
              .interpolate(this._interpolate, true)
              .base(this._base);
      }
      rescale(slience) {
          var _a;
          if (slience) {
              return this;
          }
          super.rescale();
          const logs = logp(this._base);
          const pows = powp(this._base);
          const domain = (_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain;
          if (domain[0] < 0) {
              this._logs = reflect(logs);
              this._pows = reflect(pows);
              this._limit = limitNegativeZero();
              this.transformer = logNegative;
              this.untransformer = expNegative;
          }
          else {
              this._logs = logs;
              this._pows = pows;
              this._limit = limitPositiveZero();
              this.transformer = this._logs;
              this.untransformer = pows;
          }
          return this;
      }
      scale(x) {
          var _a;
          x = Number(x);
          if (Number.isNaN(x) || (this._domainValidator && !this._domainValidator(x))) {
              return this._unknown;
          }
          if (!this._output) {
              this._output = this._piecewise(((_a = this._niceDomain) !== null && _a !== void 0 ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate);
          }
          const output = this._output(this.transformer(this._limit(this._clamp(x))));
          return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      base(_, slience) {
          if (!arguments.length) {
              return this._base;
          }
          this._base = _;
          return this.rescale(slience);
      }
      tickFormat() {
          return identity;
      }
      d3Ticks(count = 10) {
          const d = this.domain();
          let u = this._limit(d[0]);
          let v = this._limit(d[d.length - 1]);
          const r = v < u;
          if (r) {
              [u, v] = [v, u];
          }
          let i = this._logs(u);
          let j = this._logs(v);
          let k;
          let t;
          let z = [];
          if (!(this._base % 1) && j - i < count) {
              (i = Math.floor(i)), (j = Math.ceil(j));
              if (u > 0) {
                  for (; i <= j; ++i) {
                      for (k = 1; k < this._base; ++k) {
                          t = i < 0 ? k / this._pows(-i) : k * this._pows(i);
                          if (t < u) {
                              continue;
                          }
                          if (t > v) {
                              break;
                          }
                          z.push(t);
                      }
                  }
              }
              else {
                  for (; i <= j; ++i) {
                      for (k = this._base - 1; k >= 1; --k) {
                          t = i > 0 ? k / this._pows(-i) : k * this._pows(i);
                          if (t < u) {
                              continue;
                          }
                          if (t > v) {
                              break;
                          }
                          z.push(t);
                      }
                  }
              }
              if (z.length * 2 < count) {
                  z = ticks(u, v, count);
              }
          }
          else {
              z = ticks(i, j, Math.min(j - i, count)).map(this._pows);
          }
          z = z.filter((t) => t !== 0);
          return r ? z.reverse() : z;
      }
      ticks(count = 10) {
          const d = this.calculateVisibleDomain(this._range);
          return ticksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
      }
      forceTicks(count = 10) {
          const d = this.calculateVisibleDomain(this._range);
          return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
      }
      stepTicks(step) {
          const d = this.calculateVisibleDomain(this._range);
          return forceTicksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
      }
      nice(count = 10, option) {
          var _a, _b;
          const originalDomain = this._domain;
          let niceMinMax = [];
          let niceType = null;
          if (option) {
              const res = parseNiceOptions(originalDomain, option);
              niceMinMax = res.niceMinMax;
              this._domainValidator = res.domainValidator;
              niceType = res.niceType;
              if (res.niceDomain) {
                  this._niceDomain = res.niceDomain;
                  this.rescale();
                  return this;
              }
          }
          else {
              niceType = 'all';
          }
          if (niceType) {
              const niceDomain = nice(originalDomain.slice(), {
                  floor: (x) => this._pows(Math.floor(this._logs(this._limit(x)))),
                  ceil: (x) => (Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x)))))
              });
              if (niceType === 'min') {
                  niceDomain[niceDomain.length - 1] = (_a = niceMinMax[1]) !== null && _a !== void 0 ? _a : niceDomain[niceDomain.length - 1];
              }
              else if (niceType === 'max') {
                  niceDomain[0] = (_b = niceMinMax[0]) !== null && _b !== void 0 ? _b : niceDomain[0];
              }
              this._niceDomain = niceDomain;
              this.rescale();
              return this;
          }
          return this;
      }
      niceMin() {
          const maxD = this._domain[this._domain.length - 1];
          this.nice();
          const niceDomain = this._domain.slice();
          if (this._domain) {
              niceDomain[niceDomain.length - 1] = maxD;
              this._niceDomain = niceDomain;
              this.rescale();
          }
          return this;
      }
      niceMax() {
          const minD = this._domain[0];
          this.nice();
          const niceDomain = this._domain.slice();
          if (this._domain) {
              niceDomain[0] = minD;
              this._niceDomain = niceDomain;
              this.rescale();
          }
          return this;
      }
  }

  class PointScale extends BandScale {
      constructor(slience) {
          super(false);
          this.type = exports.ScaleEnum.Point;
          this._padding = 0;
          this.paddingInner(1, slience);
          this.padding = this.paddingOuter;
          this.paddingInner = undefined;
          this.paddingOuter = undefined;
      }
  }

  class PowScale extends LinearScale {
      constructor() {
          super();
          this.type = exports.ScaleEnum.Pow;
          this._exponent = 1;
      }
      clone() {
          return new PowScale()
              .domain(this._domain, true)
              .range(this._range, true)
              .unknown(this._unknown)
              .clamp(this.clamp(), null, true)
              .interpolate(this._interpolate, true)
              .exponent(this._exponent);
      }
      rescale(slience) {
          if (slience) {
              return this;
          }
          if (this._exponent === 1) {
              this.transformer = identity;
              this.untransformer = identity;
          }
          else if (this._exponent === 0.5) {
              this.transformer = sqrt;
              this.untransformer = square;
          }
          else {
              this.transformer = generatePow(this._exponent);
              this.untransformer = generatePow(1 / this._exponent);
          }
          super.rescale();
          return this;
      }
      exponent(_, slience) {
          if (!arguments.length) {
              return this._exponent;
          }
          this._exponent = _;
          return this.rescale(slience);
      }
  }

  class QuantileScale {
      constructor() {
          this.type = exports.ScaleEnum.Quantile;
          this._range = [];
          this._domain = [];
          this._thresholds = [];
      }
      unknown(_) {
          if (!arguments.length) {
              return this._unknown;
          }
          this._unknown = _;
          return this;
      }
      rescale(slience) {
          if (slience) {
              return this;
          }
          let i = 0;
          const n = Math.max(1, this._range.length);
          this._thresholds = new Array(n - 1);
          while (++i < n) {
              this._thresholds[i - 1] = quantileSorted(this._domain, i / n);
          }
          return this;
      }
      scale(x) {
          return isValidNumber$1(x) ? this._range[bisect(this._thresholds, x)] : this._unknown;
      }
      invertExtent(y) {
          const i = this._range.indexOf(y);
          return i < 0
              ? [NaN, NaN]
              : [
                  i > 0 ? this._thresholds[i - 1] : this._domain[0],
                  i < this._thresholds.length ? this._thresholds[i] : this._domain[this._domain.length - 1]
              ];
      }
      quantiles() {
          return this._thresholds.slice();
      }
      domain(_, slience) {
          if (!_) {
              return this._domain.slice();
          }
          this._domain = [];
          for (const value of _) {
              if (!isNil$1(value) && !Number.isNaN(+value)) {
                  this._domain.push(+value);
              }
          }
          this._domain.sort(ascending);
          return this.rescale(slience);
      }
      range(_, slience) {
          if (!_) {
              return this._range.slice();
          }
          const nextRange = Array.from(_);
          if (arrayEqual(this._range, nextRange)) {
              return this;
          }
          this._range = nextRange;
          return this.rescale(slience);
      }
      clone() {
          return new QuantileScale().domain(this._domain, true).range(this._range).unknown(this._unknown);
      }
  }

  class QuantizeScale {
      constructor() {
          this.type = exports.ScaleEnum.Quantile;
          this._range = [0, 1];
          this._domain = [0.5];
          this.x0 = 0;
          this.x1 = 1;
          this.n = 1;
      }
      unknown(_) {
          if (!arguments.length) {
              return this._unknown;
          }
          this._unknown = _;
          return this;
      }
      rescale(slience) {
          if (slience) {
              return this;
          }
          let i = -1;
          this._domain = new Array(this.n);
          while (++i < this.n) {
              this._domain[i] = ((i + 1) * this.x1 - (i - this.n) * this.x0) / (this.n + 1);
          }
          return this;
      }
      scale(x) {
          return isValidNumber$1(x) ? this._range[bisect(this._domain, x, 0, this.n)] : this._unknown;
      }
      invertExtent(y) {
          const i = this._range.indexOf(y);
          return i < 0
              ? [NaN, NaN]
              : i < 1
                  ? [this.x0, this._domain[0]]
                  : i >= this.n
                      ? [this._domain[this.n - 1], this.x1]
                      : [this._domain[i - 1], this._domain[i]];
      }
      thresholds() {
          return this._domain.slice();
      }
      domain(_, slience) {
          if (!_) {
              return [this.x0, this.x1];
          }
          const domain = Array.from(_);
          this.x0 = +domain[0];
          this.x1 = +domain[1];
          return this.rescale(slience);
      }
      range(_, slience) {
          if (!_) {
              return this._range.slice();
          }
          const nextRange = Array.from(_);
          if (arrayEqual(this._range, nextRange)) {
              return this;
          }
          this.n = nextRange.length - 1;
          this._range = nextRange;
          return this.rescale(slience);
      }
      clone() {
          return new QuantizeScale()
              .domain([this.x0, this.x1], true)
              .range(this._range)
              .unknown(this._unknown);
      }
      ticks(count = 10) {
          const d = this.domain();
          return ticks(d[0], d[d.length - 1], count);
      }
      forceTicks(count = 10) {
          const d = this.domain();
          return forceTicks(d[0], d[d.length - 1], count);
      }
      stepTicks(step) {
          const d = this.domain();
          return stepTicks(d[0], d[d.length - 1], step);
      }
      nice(count = 10) {
          const niceDomain = niceLinear(this.domain(), count);
          if (niceDomain) {
              return this.domain(niceDomain);
          }
          return this;
      }
      niceMin(count = 10) {
          const maxD = this._domain[this._domain.length - 1];
          const niceDomain = niceLinear(this.domain(), count);
          if (niceDomain) {
              niceDomain[niceDomain.length - 1] = maxD;
              this.domain(niceDomain);
          }
          return this;
      }
      niceMax(count = 10) {
          const minD = this._domain[0];
          const niceDomain = niceLinear(this.domain(), count);
          if (niceDomain) {
              niceDomain[0] = minD;
              this.domain(niceDomain);
          }
          return this;
      }
  }

  class SqrtScale extends LinearScale {
      constructor() {
          super(sqrt, square);
          this.type = exports.ScaleEnum.Sqrt;
      }
      clone() {
          return new SqrtScale()
              .domain(this._domain, true)
              .range(this._range, true)
              .unknown(this._unknown)
              .clamp(this.clamp(), null, true)
              .interpolate(this._interpolate);
      }
  }

  class SymlogScale extends LinearScale {
      constructor() {
          super(symlog(1), symexp(1));
          this.type = exports.ScaleEnum.Symlog;
          this._const = 1;
      }
      clone() {
          return new SymlogScale()
              .domain(this._domain, true)
              .range(this._range, true)
              .unknown(this._unknown)
              .clamp(this.clamp(), null, true)
              .interpolate(this._interpolate, true)
              .constant(this._const);
      }
      constant(_, slience) {
          if (!arguments.length) {
              return this._const;
          }
          this._const = _;
          this.transformer = symlog(_);
          this.untransformer = symexp(_);
          return this.rescale(slience);
      }
      ticks(count = 10) {
          const d = this.calculateVisibleDomain(this._range);
          return ticksBaseTransform(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
      }
      forceTicks(count = 10) {
          const d = this.calculateVisibleDomain(this._range);
          return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
      }
      stepTicks(step) {
          const d = this.calculateVisibleDomain(this._range);
          return forceTicksBaseTransform(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
      }
      nice(count = 10, option) {
          var _a, _b;
          const originalDomain = this._domain;
          let niceMinMax = [];
          let niceType = null;
          if (option) {
              const res = parseNiceOptions(originalDomain, option);
              niceMinMax = res.niceMinMax;
              this._domainValidator = res.domainValidator;
              niceType = res.niceType;
              if (res.niceDomain) {
                  this._niceDomain = res.niceDomain;
                  this.rescale();
                  return this;
              }
          }
          else {
              niceType = 'all';
          }
          if (niceType) {
              const niceDomain = nice(originalDomain.slice(), {
                  floor: (x) => Math.floor(x),
                  ceil: (x) => Math.ceil(x)
              });
              if (niceType === 'min') {
                  niceDomain[niceDomain.length - 1] = (_a = niceMinMax[1]) !== null && _a !== void 0 ? _a : niceDomain[niceDomain.length - 1];
              }
              else if (niceType === 'max') {
                  niceDomain[0] = (_b = niceMinMax[0]) !== null && _b !== void 0 ? _b : niceDomain[0];
              }
              this._niceDomain = niceDomain;
              this.rescale();
              return this;
          }
          return this;
      }
      niceMin() {
          const maxD = this._domain[this._domain.length - 1];
          this.nice();
          const niceDomain = this._domain.slice();
          if (this._domain) {
              niceDomain[niceDomain.length - 1] = maxD;
              this._niceDomain = niceDomain;
              this.rescale();
          }
          return this;
      }
      niceMax() {
          const minD = this._domain[0];
          this.nice();
          const niceDomain = this._domain.slice();
          if (this._domain) {
              niceDomain[0] = minD;
              this._niceDomain = niceDomain;
              this.rescale();
          }
          return this;
      }
  }

  class ThresholdScale {
      constructor() {
          this.type = exports.ScaleEnum.Threshold;
          this._range = [0, 1];
          this._domain = [0.5];
          this.n = 1;
      }
      unknown(_) {
          if (!arguments.length) {
              return this._unknown;
          }
          this._unknown = _;
          return this;
      }
      scale(x) {
          return !isNil$1(x) && isValidNumber$1(+x) ? this._range[bisect(this._domain, x, 0, this.n)] : this._unknown;
      }
      invertExtent(y) {
          const i = this._range.indexOf(y);
          return [this._domain[i - 1], this._domain[i]];
      }
      domain(_) {
          if (!_) {
              return this._domain.slice();
          }
          this._domain = Array.from(_);
          this.n = Math.min(this._domain.length, this._range.length - 1);
          return this;
      }
      range(_) {
          if (!_) {
              return this._range.slice();
          }
          this._range = Array.from(_);
          this.n = Math.min(this._domain.length, this._range.length - 1);
          return this;
      }
      clone() {
          return new ThresholdScale().domain(this._domain).range(this._range).unknown(this._unknown);
      }
  }

  const timeIntervals = [
      ['second', 1, SECOND],
      ['second', 5, SECOND * 5],
      ['second', 10, SECOND * 10],
      ['second', 30, SECOND * 30],
      ['minute', 1, MINUTE],
      ['minute', 5, MINUTE * 5],
      ['minute', 10, MINUTE * 10],
      ['minute', 30, MINUTE * 30],
      ['hour', 1, HOUR],
      ['hour', 3, HOUR * 3],
      ['hour', 6, HOUR * 6],
      ['hour', 12, HOUR * 12],
      ['day', 1, DAY],
      ['day', 2, DAY * 2],
      ['day', 7, DAY * 7],
      ['month', 1, MONTH],
      ['month', 3, MONTH * 3],
      ['month', 6, MONTH * 6],
      ['year', 1, DAY * 365]
  ];
  function toDateNumber(t) {
      return +toDate(t);
  }
  function getTickInterval(min, max, tickCount, isUTC) {
      const target = (+max - +min) / tickCount;
      const idx = bisect(timeIntervals.map(entry => entry[2]), target);
      if (idx === timeIntervals.length) {
          const step = Math.max(tickStep(+min / YEAR, +max / YEAR, tickCount), 1);
          const floor = (date) => {
              date[fullYearSetterName(isUTC)](Math.floor(date[fullYearGetterName(isUTC)]() / step) * step);
              date[monthSetterName(isUTC)](0, 1);
              date[hoursSetterName(isUTC)](0, 0, 0, 0);
              return date;
          };
          const offset = (date, s) => {
              date[fullYearSetterName(isUTC)](date[fullYearGetterName(isUTC)]() + s * step);
              return date;
          };
          return {
              floor,
              offset,
              ceil: generateCeil(floor, offset)
          };
      }
      if (idx === 0) {
          const step = Math.max(tickStep(+min, +max, tickCount), 1);
          const floor = (date) => {
              date.setTime(Math.floor(+date / step) * step);
              return date;
          };
          const offset = (date, s) => {
              date.setTime(+date + s * step);
              return date;
          };
          return {
              floor,
              offset,
              ceil: generateCeil(floor, offset)
          };
      }
      const [timeUnit, step] = timeIntervals[target / timeIntervals[idx - 1][2] < timeIntervals[idx][2] / target ? idx - 1 : idx];
      const simpleIntervalOptions = getIntervalOptions(timeUnit, isUTC);
      return generateStepInterval(step, simpleIntervalOptions);
  }

  class TimeScale extends ContinuousScale {
      constructor(isUtc = false) {
          super();
          this.type = exports.ScaleEnum.Time;
          this._domain = isUtc
              ? [Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]
              : [+new Date(2000, 0, 1), +new Date(2000, 0, 2)];
          this._isUtc = isUtc;
      }
      invert(y) {
          return new Date(super.invert(y));
      }
      domain(_, slience) {
          if (!_) {
              return this._domain.map(toDate);
          }
          const nextDomain = Array.from(_, toDateNumber);
          this._domain = nextDomain;
          return this.rescale(slience);
      }
      ticks(interval) {
          const d = this.domain();
          let start = d[0];
          let stop = d[d.length - 1];
          const reverse = stop < start;
          if (reverse) {
              [start, stop] = [stop, start];
          }
          let options = interval;
          if (isNumber$1(interval) || isNil$1(interval)) {
              options = getTickInterval(start, stop, isNil$1(interval) ? 10 : interval, this._isUtc);
          }
          start = options.ceil(start);
          const tickValues = [];
          let cur = +start;
          let i = 0;
          const maxCount = 100;
          while (cur <= +stop && i < maxCount) {
              tickValues.push(new Date(cur));
              cur = +options.offset(new Date(cur), 1);
              i++;
          }
          return reverse ? tickValues.reverse() : tickValues;
      }
      tickFormat(count, specifier) {
          return specifier == null
              ? getTimeFormatter(getFormatFromValue(this._domain[0], this._isUtc), this._isUtc)
              : getTimeFormatter(specifier, this._isUtc);
      }
      clone() {
          return new TimeScale(this._isUtc)
              .domain(this.domain(), true)
              .range(this._range, true)
              .unknown(this._unknown)
              .clamp(this.clamp(), null, true)
              .interpolate(this._interpolate);
      }
      nice(interval) {
          const d = this.domain();
          let options = interval;
          if (isNumber$1(interval) || isNil$1(interval)) {
              options = getTickInterval(d[0], d[d.length - 1], isNil$1(interval) ? 10 : interval, this._isUtc);
          }
          if (options) {
              this.domain(nice(d, options));
          }
          return this;
      }
      utc() {
          return this._isUtc;
      }
  }

  const implicit = Symbol('implicit');
  class IdentityScale {
      constructor() {
          this.type = exports.ScaleEnum.Identity;
      }
      specified(_) {
          var _a;
          if (!_) {
              return Object.assign({}, this._specified);
          }
          this._specified = Object.assign((_a = this._specified) !== null && _a !== void 0 ? _a : {}, _);
          return this;
      }
      _getSpecifiedValue(input) {
          if (!this._specified) {
              return undefined;
          }
          return this._specified[input];
      }
      clone() {
          return new IdentityScale().unknown(this._unknown).domain(this._domain).specified(this._specified);
      }
      scale(d) {
          const key = `${d}`;
          const special = this._getSpecifiedValue(key);
          if (special !== undefined) {
              return special;
          }
          if (this._unknown !== implicit && this._domain && !this._domain.includes(d)) {
              return this._unknown;
          }
          return d;
      }
      invert(d) {
          return d;
      }
      domain(_) {
          if (!_) {
              return this._domain ? this._domain.slice() : undefined;
          }
          this._domain = _;
          return this;
      }
      range(_) {
          if (!_) {
              return this._domain ? this._domain.slice() : undefined;
          }
          return this;
      }
      unknown(_) {
          if (!arguments.length) {
              return this._unknown;
          }
          this._unknown = _;
          return this;
      }
  }

  exports.BandScale = BandScale;
  exports.ContinuousScale = ContinuousScale;
  exports.IdentityScale = IdentityScale;
  exports.LinearScale = LinearScale;
  exports.LogScale = LogScale;
  exports.OrdinalScale = OrdinalScale;
  exports.PointScale = PointScale;
  exports.PowScale = PowScale;
  exports.QuantileScale = QuantileScale;
  exports.QuantizeScale = QuantizeScale;
  exports.SqrtScale = SqrtScale;
  exports.SymlogScale = SymlogScale;
  exports.ThresholdScale = ThresholdScale;
  exports.TimeScale = TimeScale;
  exports.isContinuous = isContinuous;
  exports.isDiscrete = isDiscrete;
  exports.isDiscretizing = isDiscretizing;
  exports.isValidScaleType = isValidScaleType;
  exports.scaleWholeRangeSize = scaleWholeRangeSize;
  exports.supportRangeFactor = supportRangeFactor;

}));
