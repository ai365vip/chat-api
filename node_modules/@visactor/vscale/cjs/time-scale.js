"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TimeScale = void 0;

const vutils_1 = require("@visactor/vutils"), continuous_scale_1 = require("./continuous-scale"), type_1 = require("./type"), time_1 = require("./utils/time"), utils_1 = require("./utils/utils");

class TimeScale extends continuous_scale_1.ContinuousScale {
    constructor(isUtc = !1) {
        super(), this.type = type_1.ScaleEnum.Time, this._domain = isUtc ? [ Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2) ] : [ +new Date(2e3, 0, 1), +new Date(2e3, 0, 2) ], 
        this._isUtc = isUtc;
    }
    invert(y) {
        return new Date(super.invert(y));
    }
    domain(_, slience) {
        if (!_) return this._domain.map(vutils_1.toDate);
        const nextDomain = Array.from(_, time_1.toDateNumber);
        return this._domain = nextDomain, this.rescale(slience);
    }
    ticks(interval) {
        const d = this.domain();
        let start = d[0], stop = d[d.length - 1];
        const reverse = stop < start;
        reverse && ([start, stop] = [ stop, start ]);
        let options = interval;
        ((0, vutils_1.isNumber)(interval) || (0, vutils_1.isNil)(interval)) && (options = (0, 
        time_1.getTickInterval)(start, stop, (0, vutils_1.isNil)(interval) ? 10 : interval, this._isUtc)), 
        start = options.ceil(start);
        const tickValues = [];
        let cur = +start, i = 0;
        for (;cur <= +stop && i < 100; ) tickValues.push(new Date(cur)), cur = +options.offset(new Date(cur), 1), 
        i++;
        return reverse ? tickValues.reverse() : tickValues;
    }
    tickFormat(count, specifier) {
        return null == specifier ? (0, vutils_1.getTimeFormatter)((0, vutils_1.getFormatFromValue)(this._domain[0], this._isUtc), this._isUtc) : (0, 
        vutils_1.getTimeFormatter)(specifier, this._isUtc);
    }
    clone() {
        return new TimeScale(this._isUtc).domain(this.domain(), !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate);
    }
    nice(interval) {
        const d = this.domain();
        let options = interval;
        return ((0, vutils_1.isNumber)(interval) || (0, vutils_1.isNil)(interval)) && (options = (0, 
        time_1.getTickInterval)(d[0], d[d.length - 1], (0, vutils_1.isNil)(interval) ? 10 : interval, this._isUtc)), 
        options && this.domain((0, utils_1.nice)(d, options)), this;
    }
    utc() {
        return this._isUtc;
    }
}

exports.TimeScale = TimeScale;