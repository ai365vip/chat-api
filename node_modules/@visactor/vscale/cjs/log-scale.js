"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LogScale = void 0;

const tick_sample_1 = require("./utils/tick-sample"), continuous_scale_1 = require("./continuous-scale"), type_1 = require("./type"), utils_1 = require("./utils/utils");

function reflect(f) {
    return x => -f(-x);
}

function limitPositiveZero(min = Number.EPSILON) {
    return x => Math.max(x, min);
}

function limitNegativeZero(min = Number.EPSILON) {
    return x => Math.min(x, -min);
}

class LogScale extends continuous_scale_1.ContinuousScale {
    constructor() {
        super((0, utils_1.logp)(10), (0, utils_1.powp)(10)), this.type = type_1.ScaleEnum.Log, 
        this._limit = limitPositiveZero(), this._logs = this.transformer, this._pows = this.untransformer, 
        this._domain = [ 1, 10 ], this._base = 10;
    }
    clone() {
        return (new LogScale).domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate, !0).base(this._base);
    }
    rescale(slience) {
        var _a;
        if (slience) return this;
        super.rescale();
        const logs = (0, utils_1.logp)(this._base), pows = (0, utils_1.powp)(this._base);
        return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect(logs), 
        this._pows = reflect(pows), this._limit = limitNegativeZero(), this.transformer = utils_1.logNegative, 
        this.untransformer = utils_1.expNegative) : (this._logs = logs, this._pows = pows, 
        this._limit = limitPositiveZero(), this.transformer = this._logs, this.untransformer = pows), 
        this;
    }
    scale(x) {
        var _a;
        if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
        this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
        const output = this._output(this.transformer(this._limit(this._clamp(x))));
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
    }
    base(_, slience) {
        return arguments.length ? (this._base = _, this.rescale(slience)) : this._base;
    }
    tickFormat() {
        return utils_1.identity;
    }
    d3Ticks(count = 10) {
        const d = this.domain();
        let u = this._limit(d[0]), v = this._limit(d[d.length - 1]);
        const r = v < u;
        r && ([u, v] = [ v, u ]);
        let k, t, i = this._logs(u), j = this._logs(v), z = [];
        if (!(this._base % 1) && j - i < count) {
            if (i = Math.floor(i), j = Math.ceil(j), u > 0) {
                for (;i <= j; ++i) for (k = 1; k < this._base; ++k) if (t = i < 0 ? k / this._pows(-i) : k * this._pows(i), 
                !(t < u)) {
                    if (t > v) break;
                    z.push(t);
                }
            } else for (;i <= j; ++i) for (k = this._base - 1; k >= 1; --k) if (t = i > 0 ? k / this._pows(-i) : k * this._pows(i), 
            !(t < u)) {
                if (t > v) break;
                z.push(t);
            }
            2 * z.length < count && (z = (0, tick_sample_1.ticks)(u, v, count));
        } else z = (0, tick_sample_1.ticks)(i, j, Math.min(j - i, count)).map(this._pows);
        return z = z.filter((t => 0 !== t)), r ? z.reverse() : z;
    }
    ticks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return (0, tick_sample_1.ticksBaseTransform)(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
    }
    forceTicks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return (0, tick_sample_1.forceTicksBaseTransform)(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
    }
    stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return (0, tick_sample_1.forceTicksBaseTransform)(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
    }
    nice(count = 10, option) {
        var _a, _b;
        const originalDomain = this._domain;
        let niceMinMax = [], niceType = null;
        if (option) {
            const res = (0, tick_sample_1.parseNiceOptions)(originalDomain, option);
            if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, 
            res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else niceType = "all";
        if (niceType) {
            const niceDomain = (0, utils_1.nice)(originalDomain.slice(), {
                floor: x => this._pows(Math.floor(this._logs(this._limit(x)))),
                ceil: x => Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x))))
            });
            return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), 
            this._niceDomain = niceDomain, this.rescale(), this;
        }
        return this;
    }
    niceMin() {
        const maxD = this._domain[this._domain.length - 1];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, 
        this.rescale()), this;
    }
    niceMax() {
        const minD = this._domain[0];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), 
        this;
    }
}

exports.LogScale = LogScale;
//# sourceMappingURL=log-scale.js.map