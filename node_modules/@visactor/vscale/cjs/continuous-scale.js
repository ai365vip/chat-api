"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ContinuousScale = void 0;

const base_scale_1 = require("./base-scale"), interpolate_1 = require("./utils/interpolate"), utils_1 = require("./utils/utils"), vutils_1 = require("@visactor/vutils");

class ContinuousScale extends base_scale_1.BaseScale {
    constructor(transformer = utils_1.identity, untransformer = utils_1.identity) {
        super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, 
        this._forceAlign = !0, this._domain = [ 0, 1 ], this._range = [ 0, 1 ], this._clamp = utils_1.identity, 
        this._piecewise = utils_1.bimap, this._interpolate = interpolate_1.interpolate;
    }
    calculateVisibleDomain(range) {
        var _a;
        if ((0, vutils_1.isValid)(this._rangeFactorStart) && (0, vutils_1.isValid)(this._rangeFactorEnd) && 2 === range.length) {
            return [ this.invert(range[0]), this.invert(range[1]) ];
        }
        return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
    }
    fishEye(options, slience, clear) {
        return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, 
        this.rescale(slience)) : this._fishEyeOptions;
    }
    scale(x) {
        var _a;
        if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
        this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
        const output = this._output(this.transformer(this._clamp(x)));
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
    }
    invert(y) {
        var _a;
        return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), vutils_1.interpolateNumber)), 
        this._clamp(this.untransformer(this._input(y)));
    }
    domain(_, slience) {
        var _a;
        if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
        this._domainValidator = null, this._niceType = null, this._niceDomain = null;
        const nextDomain = Array.from(_, vutils_1.toNumber);
        return this._domain = nextDomain, this.rescale(slience);
    }
    range(_, slience) {
        if (!_) return this._range.slice();
        const nextRange = Array.from(_);
        return this._range = nextRange, this.rescale(slience);
    }
    rangeRound(_, slience) {
        const nextRange = Array.from(_);
        return this._range = nextRange, this._interpolate = vutils_1.interpolateNumberRound, 
        this.rescale(slience);
    }
    rescale(slience) {
        var _a;
        if (slience) return this;
        const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, domainLength = domain.length, rangeLength = this._range.length;
        let n = Math.min(domainLength, rangeLength);
        if (domainLength && domainLength < rangeLength && this._forceAlign) {
            const deltaStep = rangeLength - domainLength + 1, last = domain[domainLength - 1], delta = domainLength >= 2 ? (last - domain[domainLength - 2]) / deltaStep : 0;
            for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last - delta * (deltaStep - i);
            n = rangeLength;
        }
        return void 0 === this._clamp && (this._clamp = (0, vutils_1.clamper)(domain[0], domain[n - 1])), 
        this._piecewise = n > 2 ? utils_1.polymap : utils_1.bimap, this._output = this._input = null, 
        this._wholeRange = null, this.generateFishEyeTransform(), this;
    }
    clamp(_, f, slience) {
        return arguments.length ? (this._clamp = f || (_ ? void 0 : utils_1.identity), this.rescale(slience)) : this._clamp !== utils_1.identity;
    }
    interpolate(_, slience) {
        return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
    }
    ticks(count = 10) {
        return [];
    }
    tickData(count = 10) {
        const ticks = this.ticks(count);
        return (null != ticks ? ticks : []).map(((tick, index) => ({
            index: index,
            tick: tick,
            value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
        })));
    }
    rangeFactor(_, slience) {
        return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
    }
    rangeFactorStart(_, slience) {
        return (0, vutils_1.isNil)(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), 
        this._output = this._input = null, this);
    }
    rangeFactorEnd(_, slience) {
        return (0, vutils_1.isNil)(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), 
        this._output = this._input = null, this);
    }
    forceAlignDomainRange(forceAlign) {
        return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
    }
}

exports.ContinuousScale = ContinuousScale;
//# sourceMappingURL=continuous-scale.js.map