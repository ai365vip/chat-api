import { BaseScale } from "./base-scale";

import { interpolate } from "./utils/interpolate";

import { bimap, identity, polymap } from "./utils/utils";

import { clamper, toNumber, interpolateNumberRound, interpolateNumber, isValid, isNil } from "@visactor/vutils";

export class ContinuousScale extends BaseScale {
    constructor(transformer = identity, untransformer = identity) {
        super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, 
        this._forceAlign = !0, this._domain = [ 0, 1 ], this._range = [ 0, 1 ], this._clamp = identity, 
        this._piecewise = bimap, this._interpolate = interpolate;
    }
    calculateVisibleDomain(range) {
        var _a;
        if (isValid(this._rangeFactorStart) && isValid(this._rangeFactorEnd) && 2 === range.length) {
            return [ this.invert(range[0]), this.invert(range[1]) ];
        }
        return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
    }
    fishEye(options, slience, clear) {
        return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, 
        this.rescale(slience)) : this._fishEyeOptions;
    }
    scale(x) {
        var _a;
        if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
        this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
        const output = this._output(this.transformer(this._clamp(x)));
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
    }
    invert(y) {
        var _a;
        return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber)), 
        this._clamp(this.untransformer(this._input(y)));
    }
    domain(_, slience) {
        var _a;
        if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
        this._domainValidator = null, this._niceType = null, this._niceDomain = null;
        const nextDomain = Array.from(_, toNumber);
        return this._domain = nextDomain, this.rescale(slience);
    }
    range(_, slience) {
        if (!_) return this._range.slice();
        const nextRange = Array.from(_);
        return this._range = nextRange, this.rescale(slience);
    }
    rangeRound(_, slience) {
        const nextRange = Array.from(_);
        return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
    }
    rescale(slience) {
        var _a;
        if (slience) return this;
        const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, domainLength = domain.length, rangeLength = this._range.length;
        let n = Math.min(domainLength, rangeLength);
        if (domainLength && domainLength < rangeLength && this._forceAlign) {
            const deltaStep = rangeLength - domainLength + 1, last = domain[domainLength - 1], delta = domainLength >= 2 ? (last - domain[domainLength - 2]) / deltaStep : 0;
            for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last - delta * (deltaStep - i);
            n = rangeLength;
        }
        return void 0 === this._clamp && (this._clamp = clamper(domain[0], domain[n - 1])), 
        this._piecewise = n > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, 
        this.generateFishEyeTransform(), this;
    }
    clamp(_, f, slience) {
        return arguments.length ? (this._clamp = f || (_ ? void 0 : identity), this.rescale(slience)) : this._clamp !== identity;
    }
    interpolate(_, slience) {
        return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
    }
    ticks(count = 10) {
        return [];
    }
    tickData(count = 10) {
        const ticks = this.ticks(count);
        return (null != ticks ? ticks : []).map(((tick, index) => ({
            index: index,
            tick: tick,
            value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
        })));
    }
    rangeFactor(_, slience) {
        return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
    }
    rangeFactorStart(_, slience) {
        return isNil(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, 
        this);
    }
    rangeFactorEnd(_, slience) {
        return isNil(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, 
        this);
    }
    forceAlignDomainRange(forceAlign) {
        return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
    }
}
//# sourceMappingURL=continuous-scale.js.map