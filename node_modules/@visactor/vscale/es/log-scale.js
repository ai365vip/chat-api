import { ticks, ticksBaseTransform, forceTicksBaseTransform, parseNiceOptions } from "./utils/tick-sample";

import { ContinuousScale } from "./continuous-scale";

import { ScaleEnum } from "./type";

import { logp, nice, powp, logNegative, expNegative, identity } from "./utils/utils";

function reflect(f) {
    return x => -f(-x);
}

function limitPositiveZero(min = Number.EPSILON) {
    return x => Math.max(x, min);
}

function limitNegativeZero(min = Number.EPSILON) {
    return x => Math.min(x, -min);
}

export class LogScale extends ContinuousScale {
    constructor() {
        super(logp(10), powp(10)), this.type = ScaleEnum.Log, this._limit = limitPositiveZero(), 
        this._logs = this.transformer, this._pows = this.untransformer, this._domain = [ 1, 10 ], 
        this._base = 10;
    }
    clone() {
        return (new LogScale).domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate, !0).base(this._base);
    }
    rescale(slience) {
        var _a;
        if (slience) return this;
        super.rescale();
        const logs = logp(this._base), pows = powp(this._base);
        return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect(logs), 
        this._pows = reflect(pows), this._limit = limitNegativeZero(), this.transformer = logNegative, 
        this.untransformer = expNegative) : (this._logs = logs, this._pows = pows, this._limit = limitPositiveZero(), 
        this.transformer = this._logs, this.untransformer = pows), this;
    }
    scale(x) {
        var _a;
        if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
        this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
        const output = this._output(this.transformer(this._limit(this._clamp(x))));
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
    }
    base(_, slience) {
        return arguments.length ? (this._base = _, this.rescale(slience)) : this._base;
    }
    tickFormat() {
        return identity;
    }
    d3Ticks(count = 10) {
        const d = this.domain();
        let u = this._limit(d[0]), v = this._limit(d[d.length - 1]);
        const r = v < u;
        r && ([u, v] = [ v, u ]);
        let k, t, i = this._logs(u), j = this._logs(v), z = [];
        if (!(this._base % 1) && j - i < count) {
            if (i = Math.floor(i), j = Math.ceil(j), u > 0) {
                for (;i <= j; ++i) for (k = 1; k < this._base; ++k) if (t = i < 0 ? k / this._pows(-i) : k * this._pows(i), 
                !(t < u)) {
                    if (t > v) break;
                    z.push(t);
                }
            } else for (;i <= j; ++i) for (k = this._base - 1; k >= 1; --k) if (t = i > 0 ? k / this._pows(-i) : k * this._pows(i), 
            !(t < u)) {
                if (t > v) break;
                z.push(t);
            }
            2 * z.length < count && (z = ticks(u, v, count));
        } else z = ticks(i, j, Math.min(j - i, count)).map(this._pows);
        return z = z.filter((t => 0 !== t)), r ? z.reverse() : z;
    }
    ticks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return ticksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
    }
    forceTicks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
    }
    stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
    }
    nice(count = 10, option) {
        var _a, _b;
        const originalDomain = this._domain;
        let niceMinMax = [], niceType = null;
        if (option) {
            const res = parseNiceOptions(originalDomain, option);
            if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, 
            res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else niceType = "all";
        if (niceType) {
            const niceDomain = nice(originalDomain.slice(), {
                floor: x => this._pows(Math.floor(this._logs(this._limit(x)))),
                ceil: x => Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x))))
            });
            return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), 
            this._niceDomain = niceDomain, this.rescale(), this;
        }
        return this;
    }
    niceMin() {
        const maxD = this._domain[this._domain.length - 1];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, 
        this.rescale()), this;
    }
    niceMax() {
        const minD = this._domain[0];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), 
        this;
    }
}
//# sourceMappingURL=log-scale.js.map