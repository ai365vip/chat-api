import { isNil, getTimeFormatter, getFormatFromValue, toDate, isNumber } from "@visactor/vutils";

import { ContinuousScale } from "./continuous-scale";

import { ScaleEnum } from "./type";

import { getTickInterval, toDateNumber } from "./utils/time";

import { nice } from "./utils/utils";

export class TimeScale extends ContinuousScale {
    constructor(isUtc = !1) {
        super(), this.type = ScaleEnum.Time, this._domain = isUtc ? [ Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2) ] : [ +new Date(2e3, 0, 1), +new Date(2e3, 0, 2) ], 
        this._isUtc = isUtc;
    }
    invert(y) {
        return new Date(super.invert(y));
    }
    domain(_, slience) {
        if (!_) return this._domain.map(toDate);
        const nextDomain = Array.from(_, toDateNumber);
        return this._domain = nextDomain, this.rescale(slience);
    }
    ticks(interval) {
        const d = this.domain();
        let start = d[0], stop = d[d.length - 1];
        const reverse = stop < start;
        reverse && ([start, stop] = [ stop, start ]);
        let options = interval;
        (isNumber(interval) || isNil(interval)) && (options = getTickInterval(start, stop, isNil(interval) ? 10 : interval, this._isUtc)), 
        start = options.ceil(start);
        const tickValues = [];
        let cur = +start, i = 0;
        for (;cur <= +stop && i < 100; ) tickValues.push(new Date(cur)), cur = +options.offset(new Date(cur), 1), 
        i++;
        return reverse ? tickValues.reverse() : tickValues;
    }
    tickFormat(count, specifier) {
        return getTimeFormatter(null == specifier ? getFormatFromValue(this._domain[0], this._isUtc) : specifier, this._isUtc);
    }
    clone() {
        return new TimeScale(this._isUtc).domain(this.domain(), !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate);
    }
    nice(interval) {
        const d = this.domain();
        let options = interval;
        return (isNumber(interval) || isNil(interval)) && (options = getTickInterval(d[0], d[d.length - 1], isNil(interval) ? 10 : interval, this._isUtc)), 
        options && this.domain(nice(d, options)), this;
    }
    utc() {
        return this._isUtc;
    }
}